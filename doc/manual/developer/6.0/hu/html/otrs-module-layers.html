<html><head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../documentation.js"></script>
<link rel="icon" type="image/png" sizes="32x32" href="../../../../../../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../../../../../images/favicon-16x16.png">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Az OTRS modulrétegek erejének használata</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="OTRS 6 - Fejlesztői kézikönyv"><link rel="up" href="how-to-extend-otrs.html" title="3. fejezet - Hogyan bővíthető az OTRS"><link rel="prev" href="how-to-extend-otrs.html" title="3. fejezet - Hogyan bővíthető az OTRS"><link rel="next" href="how-to-publish-extensions.html" title="4. fejezet - Hogyan tehetők közzé az OTRS kiterjesztések"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Az OTRS modulrétegek erejének használata</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Vissza</a> </td><th width="60%" align="center">3. fejezet - Hogyan bővíthető az OTRS</th><td width="20%" align="right"> <a accesskey="n" href="how-to-publish-extensions.html">Előre</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="otrs-module-layers"></a>Az OTRS modulrétegek erejének használata</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="otrs-module-layers.html#authentication-user-management-modules">Hitelesítés és felhasználókezelés</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module">Ügyintézői hitelesítő modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-use_cases">Használati eset példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module">Hitelesítés szinkronizációs modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-use_cases">Használati eset példák</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-releases">Kiadási elérhetőség</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-caveats">Ellenjavaslatok és figyelmeztetések</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module">Ügyfél hitelesítő modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-use_cases">Használati eset példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#preferences-modules">Beállítások</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module">Ügyfél-felhasználó beállítások modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-use_cases">Használati eset példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module">Várólista beállítások modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-use_cases">Használati eset példák</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module">Szolgáltatás beállítások modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-use_cases">Használati eset példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module">SLA beállítások modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-use_cases">Használati eset példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#core-modules">Egyéb alapfüggvények</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#log-module">Naplózás modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#log-module-code">Kódpélda: <code class="literal">Kernel::System::Log::CustomFile</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-use_cases">Használati eset példák</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-caveats">Ellenjavaslatok és figyelmeztetések</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#outputfilter">Kimenetszűrő</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filterelement_post"><code class="literal">FilterElementPost</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filtercontent"><code class="literal">FilterContent</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filtertext"><code class="literal">FilterText</code></a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-usecases">Használati esetek</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-caveats">Ellenjavaslatok és figyelmeztetések</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-bestpractice">Bevált gyakorlatok</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#module-stats">Statisztikák modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#module-stats-dynamic">Dinamikus statisztikák</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#module-stats-static">Statikus statisztikák</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator">Jegyszám előállító modulok</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-usecases">Használati esetek</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-caveats">Ellenjavaslatok és figyelmeztetések</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticketevent">Jegyesemény modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-usecases">Használati esetek</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-caveats">Ellenjavaslatok és figyelmeztetések</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-releases">Kiadási elérhetőség</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#frontend-modules">Előtétprogram modulok</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#module-dashboard">Vezérlőpult modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dashboard-module-caveats">Ellenjavaslatok és figyelmeztetések</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dashboard-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#notify-module">Értesítési modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#notify-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-use_cases">Használati eset példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module">Jegymenü modul</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-code">Kódpélda</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-configuration">Beállítási példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-use_cases">Használati eset példa</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-caveats">Ellenjavaslatok és figyelmeztetések</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-releases">Kiadási elérhetőség</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#genericinterface-modules">Általános felület modulok</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#transport">Hálózati átvitel</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_transport">Átviteli háttérprogram</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#mapping">Leképezés</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_mapping">Leképező háttérprogram</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#invoker">Meghívó</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_invoker">Meghívó háttérprogram</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#operation">Művelet</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_operation">Műveleti háttérprogram</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#daemon-scheduler-modules">Démon és ütemező</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#daemon-overview">OTRS démon</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#daemon-modules">OTRS démonmodulok</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#scheduler-overview">OTRS ütemező</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#scheduler-task-managers">OTRS ütemező feladatkezelők</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#scheduler-task-workers">OTRS ütemező feladatelvégzők</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamicfields-modules">Dinamikus mezők</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-overview">Áttekintés</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework">Dinamikus mezők keretrendszer</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-backends">Dinamikus mező háttérprogram modulok</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-admin">Dinamikus mezők adminisztrátori moduljai</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-core">Dinamikus mezők alapmoduljai</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-database">Dinamikus mezők adatbázistáblái</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-configuration-files">Dinamikus mezők beállítófájljai</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-interaction">Dinamikus mező kölcsönhatása az előtétprogram modulokkal</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options">Hogyan lehet kiterjeszteni a dinamikus mezőket</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-new-field">Egy új dinamikus mező típus létrehozása (a jegy vagy bejegyzés
objektumokhoz)</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-new-field-new-object">Egy új dinamikus mező típus létrehozása (egyéb objektumokhoz)</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-new-packages">Egy új csomag létrehozása a dinamikus mezők használatához</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-options-backend-functionalities">A háttérprogram és az illesztőprogramok funkcionalitásainak kiterjesztése</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-options-extend-other">Egyéb kiterjesztések</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-new-field">Egy új dinamikus mező létrehozása</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-new-field-files">Dinamikus mező jelszó fájlok</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend">Egy dinamikus mező funkcionalitás kiterjesztés létrehozása</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extension-full-example-files">Dinamikus mező Foo kiterjesztés fájlok</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#email-handling-modules">E-mail kezelés</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticket-postmaster-module">Jegy levelezési modul</a></span></dt></dl></dd></dl></div><p>
        Az OTRS nagyszámú úgynevezett „modulréteggel” rendelkezik, amely nagyon
egyszerűvé teszi a rendszer kibővítését a meglévő kód foltozása nélkül. Egy
példa erre a számelőállító mechanizmus a jegyeknél. Ez egy <a class="link" href="otrs-module-layers.html#ticketnumber-generator" title="Jegyszám előállító modulok">csatlakoztatható modulokkal</a>
rendelkező „modulréteg”, és ha szeretné, hozzáadhatja a saját egyéni
számelőállító moduljait is. Nézzük meg részletesen a különböző rétegeket!
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="authentication-user-management-modules"></a>Hitelesítés és felhasználókezelés</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="agent-auth-module"></a>Ügyintézői hitelesítő modul</h4></div></div></div><p>
        Számos ügyintézői hitelesítő modul létezik (DB, LDAP és HTTPBasicAuth),
amelyek az OTRS keretrendszerrel érkeznek. Lehetőség van saját hitelesítő
modulok fejlesztésére is. Az ügyintézői hitelesítő modulok a
<code class="filename">Kernel/System/Auth/*.pm</code> alatt találhatók. Ezek
beállításáról további információkért nézze meg az adminisztrátori
kézikönyvet. Ezt követően egy egyszerű ügyintézői hitelesítő modul példája
található. Mentse el a <code class="filename">Kernel/System/Auth/Simple.pm</code>
helyre. Mindössze három függvényre van szüksége: <code class="code">new()</code>,
<code class="code">GetOption()</code> és <code class="code">Auth()</code>. Adja vissza az uid-t, és
ezután a hitelesítés rendben van.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-code"></a>Kódpélda</h5></div></div></div><p>
            A felületosztály neve <code class="literal">Kernel::System::Auth</code>. A példa
ügyintézői hitelesítés hívható
<code class="literal">Kernel::System::Auth::CustomAuth</code> néven. Lent találhat egy
példát.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/CustomAuth.pm - provides the CustomAuth authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# ID: CustomAuth.pm,v 1.1 2010/05/10 15:30:34 fk Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Auth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Host$Param{Count}.";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Password$Param{Count}.";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authenticate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a RADIUS object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni ügyintézői hitelesítés modul bekapcsolására. Ezt a
lenti Perl beállítás használatával lehet megtenni. Nem ajánlott az XML
beállítás használata, mert kizárhatja magát a rendszerbeállításokon
keresztül.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthModule'} = 'Kernel::System::Auth::CustomAuth';
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-use_cases"></a>Használati eset példa</h5></div></div></div><p>
            Egy hitelesítési megvalósítás hasznos példája lehet egy SOAP háttérprogram.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>RADIUS</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-sync-module"></a>Hitelesítés szinkronizációs modul</h4></div></div></div><p>
        Létezik egy LDAP hitelesítés szinkronizációs modul, amely az OTRS
keretrendszerrel érkezik. Lehetőség van saját hitelesítés modulok
fejlesztésére is. A hitelesítés szinkronizációs modulok a
<code class="filename">Kernel/System/Auth/Sync/*.pm</code> alatt találhatók. A
beállításaikkal kapcsolatban további információkért nézze meg az
adminisztrációs kézikönyvet. A következőkben egy hitelesítés szinkronizációs
modul példája található. Mentse el a
<code class="filename">Kernel/System/Auth/Sync/CustomAuthSync.pm</code>
fájlba. Mindössze két függvényre van szüksége: <code class="code">new()</code> és
<code class="code">Sync()</code>. Adjon vissza 1-et, és ezután a szinkronizáció rendben
van.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-code"></a>Kódpélda</h5></div></div></div><p>
            A felületosztály neve <code class="literal">Kernel::System::Auth</code>. A példa
ügyintézői hitelesítés hívható
<code class="literal">Kernel::System::Auth::Sync::CustomAuthSync</code> néven. Lent
találhat egy példát.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/Sync/CustomAuthSync.pm - provides the CustomAuthSync
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# Id: CustomAuthSync.pm,v 1.9 2010/03/25 14:42:45 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Auth::Sync::CustomAuthSync;

use strict;
use warnings;
use Net::LDAP;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject UserObject GroupObject EncodeObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

...

    return $Self;
}

sub Sync {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(User)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }
...
    return 1;
}

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Be kell kapcsolnia az egyéni szinkronizációs modult. Ezt a lenti Perl
beállítás használatával lehet megtenni. Nem ajánlott az XML beállítás
használata, mert az lehetővé teheti, hogy kizárja magát a
rendszerbeállításokon keresztül.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthSyncModule'} = 'Kernel::System::Auth::Sync::LDAP';
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-use_cases"></a>Használati eset példák</h5></div></div></div><p>
            Hasznos szinkronizációs megvalósítás lehet egy SOAP vagy egy RADIUS
háttérprogram.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>LDAP</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-caveats"></a>Ellenjavaslatok és figyelmeztetések</h5></div></div></div><p>
        Ne feledje, hogy a szinkronizáció a <code class="literal">Kernel::System::Auth</code>
hitelesítési osztály része volt a 2.4-es keretrendszer előtt.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="customer-auth-module"></a>Ügyfél hitelesítő modul</h4></div></div></div><p>
        Számos ügyfél hitelesítő modul létezik (DB, LDAP és HTTPBasicAuth), amelyek
az OTRS keretrendszerrel érkeznek. Lehetőség van saját hitelesítő modulok
fejlesztésére is. Az ügyfél hitelesítő modulok a
<code class="filename">Kernel/System/CustomerAuth/*.pm</code> alatt találhatók. Ezek
beállításáról további információkért nézze meg az adminisztrátori
kézikönyvet. Ezt követően egy egyszerű ügyfél hitelesítő modul példája
található. Mentse el a
<code class="filename">Kernel/System/CustomerAuth/Simple.pm</code> helyre. Mindössze
három függvényre van szüksége: <code class="code">new()</code>, <code class="code">GetOption()</code>
és <code class="code">Auth()</code>. Adja vissza az uid-t, és ezután a hitelesítés
rendben van.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-code"></a>Kódpélda</h5></div></div></div><p>
            A felületosztály neve <code class="literal">Kernel::System::CustomerAuth</code>. A
példa ügyfél hitelesítés hívható
<code class="literal">Kernel::System::CustomerAuth::CustomAuth</code> néven. Lent
találhat egy példát.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerAuth/CustomAuth.pm - provides the custom Authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# Id: CustomAuth.pm,v 1.11 2009/09/22 15:16:05 mb Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::CustomerAuth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Host$Param{Count} in Kernel/Config.pm";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Password$Param{Count} in Kernel/Config.pm";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authentificate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a custom object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthSecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni ügyfél hitelesítő modul bekapcsolására. Ezt a lenti
XML beállítás használatával lehet megtenni.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="AuthModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to authenticate customers.&lt;/Description&gt;
    &lt;Description Lang="hu"&gt;Egy modul az ügyfelek hitelesítéséhez.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::CustomerAuthAuth&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/CustomerAuth/*.pm" SelectedID="Kernel::System::CustomerAuth::CustomAuth"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-use_cases"></a>Használati eset példa</h5></div></div></div><p>
            Hasznos hitelesítés megvalósítás lehet egy SOAP háttérprogram.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>RADIUS</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="preferences-modules"></a>Beállítások</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="customer-user-preferences-module"></a>Ügyfél-felhasználó beállítások modul</h4></div></div></div><p>
        Létezik egy DB ügyfél-felhasználó beállítások modul, amely az OTRS
keretrendszerrel érkezik. Lehetőség van saját ügyfél-felhasználó beállítási
modulok fejlesztésére is. Az ügyfél-felhasználó beállítási modulok a
<code class="filename">Kernel/System/CustomerUser/Preferences/*.pm</code> alatt
találhatók. Ezek beállításáról további információkért nézze meg az
adminisztrátori kézikönyvet. A következőkben egy ügyfél-felhasználó
beállítások modul példája található. Mentse el a
<code class="filename">Kernel/System/CustomerUser/Preferences/Custom.pm</code>
helyre. Mindössze négy függvényre van szüksége: <code class="code">new()</code>,
<code class="code">SearchPreferences()</code>, <code class="code">SetPreferences()</code> és
<code class="code">GetPreferences()</code>.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-code"></a>Kódpélda</h5></div></div></div><p>
            A felületosztály neve <code class="literal">Kernel::System::CustomerUser</code>. A
példa ügyfél-felhasználó beállítások hívhatók
<code class="literal">Kernel::System::CustomerUser::Preferences::Custom</code>
néven. Lent találhat egy példát.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerUser/Preferences/Custom.pm - some customer user functions
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# Id: Custom.pm,v 1.20 2009/10/07 20:41:50 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::CustomerUser::Preferences::Custom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable} = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{Table}
        || 'customer_preferences';
    $Self-&gt;{PreferencesTableKey}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableKey}
        || 'preferences_key';
    $Self-&gt;{PreferencesTableValue}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableValue}
        || 'preferences_value';
    $Self-&gt;{PreferencesTableUserID}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableUserID}
        || 'user_id';

    return $Self;
}

sub SetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my $Key    = $Param{Key}    || return;
    my $Value = defined( $Param{Value} ) ? $Param{Value} : '';

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . " $Self-&gt;{PreferencesTableUserID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$UserID, \$Key ],
    );

    $Value .= 'Custom';

    # insert new data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableUserID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$UserID, \$Key, \$Value ],
    );

    return 1;
}

sub GetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my %Data;

    # get preferences

    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableUserID} = ?",
        Bind =&gt; [ \$UserID ],
    );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

sub SearchPreferences {
    my ( $Self, %Param ) = @_;

    my %UserID;
    my $Key   = $Param{Key}   || '';
    my $Value = $Param{Value} || '';

    # get preferences
    my $SQL = "SELECT $Self-&gt;{PreferencesTableUserID}, $Self-&gt;{PreferencesTableValue} "
        . " FROM "
        . " $Self-&gt;{PreferencesTable} "
        . " WHERE "
        . " $Self-&gt;{PreferencesTableKey} = '"
        . $Self-&gt;{DBObject}-&gt;Quote($Key) . "'" . " AND "
        . " LOWER($Self-&gt;{PreferencesTableValue}) LIKE LOWER('"
        . $Self-&gt;{DBObject}-&gt;Quote( $Value, 'Like' ) . "')";

    return if !$Self-&gt;{DBObject}-&gt;Prepare( SQL =&gt; $SQL );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $UserID{ $Row[0] } = $Row[1];
    }

    # return data
    return %UserID;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni ügyfél-felhasználó beállítások modul
bekapcsolására. Ezt a lenti XML beállítás használatával lehet megtenni.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="CustomerPreferences" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the customer preference table.&lt;/Description&gt;
    &lt;Description Lang="hu"&gt;Paraméterek az ügyfél beállításainak táblájához.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Customer::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::CustomerUser::Preferences::Custom&lt;/Item&gt;
            &lt;Item  Key="Params"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="Table"&gt;customer_preferences&lt;/Item&gt;
                    &lt;Item Key="TableKey"&gt;preferences_key&lt;/Item&gt;
                    &lt;Item Key="TableValue"&gt;preferences_value&lt;/Item&gt;
                    &lt;Item Key="TableUserID"&gt;user_id&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-use_cases"></a>Használati eset példa</h5></div></div></div><p>
            Hasznos beállítások megvalósítás lehet egy SOAP vagy egy LDAP háttérprogram.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>DB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="queue-preferences-module"></a>Várólista beállítások modul</h4></div></div></div><p>
        Létezik egy DB várólista beállítások modul, amely az OTRS keretrendszerrel
érkezik. Lehetőség van saját várólista beállítási modulok fejlesztésére
is. A várólista beállítási modulok a
<code class="filename">Kernel/System/Queue/*.pm</code> alatt találhatók. Ezek
beállításáról további információkért nézze meg az adminisztrátori
kézikönyvet. A következőkben egy várólista beállítások modul példája
található. Mentse el a
<code class="filename">Kernel/System/Queue/PreferencesCustom.pm</code>
helyre. Mindössze három függvényre van szüksége: <code class="code">new()</code>,
<code class="code">QueuePreferencesSet()</code> és
<code class="code">QueuePreferencesGet()</code>. Adjon vissza 1-et, és ezután a
szinkronizáció rendben van.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-code"></a>Kódpélda</h5></div></div></div><p>
            A felületosztály neve <code class="literal">Kernel::System::Queue</code>. A példa
várólista beállítások hívhatók
<code class="literal">Kernel::System::Queue::PreferencesCustom</code> néven. Lent
találhat egy példát.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Queue/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# Id: PreferencesCustom.pm,v 1.5 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Queue::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}        = 'queue_preferences';
    $Self-&gt;{PreferencesTableKey}     = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}   = 'preferences_value';
    $Self-&gt;{PreferencesTableQueueID} = 'queue_id';

    return $Self;
}

sub QueuePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableQueueID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key} ],
    );

    $Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableQueueID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub QueuePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if queue preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('QueuePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableQueueID} = ?",
        Bind =&gt; [ \$Param{QueueID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni várólista beállítások modul bekapcsolására. Ezt a
lenti XML beállítás használatával lehet megtenni.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Queue::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default queue preferences module.&lt;/Description&gt;
    &lt;Description Lang="hu"&gt;Alapértelmezett várólista beállítások modul.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Queue::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Queue::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-use_cases"></a>Használati eset példák</h5></div></div></div><p>
            Hasznos beállítások megvalósítás lehet egy SOAP vagy egy RADIUS
háttérprogram.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="service-preferences-module"></a>Szolgáltatás beállítások modul</h4></div></div></div><p>
        Létezik egy DB szolgáltatás beállítások modul, amely az OTRS
keretrendszerrel érkezik. Lehetőség van saját szolgáltatás beállítási
modulok fejlesztésére is. A szolgáltatás beállítási modulok a
<code class="filename">Kernel/System/Service/*.pm</code> alatt találhatók. Ezek
beállításáról további információkért nézze meg az adminisztrátori
kézikönyvet. A következőkben egy szolgáltatás beállítások modul példája
található. Mentse el a
<code class="filename">Kernel/System/Service/PreferencesCustom.pm</code>
helyre. Mindössze három függvényre van szüksége: <code class="code">new()</code>,
<code class="code">ServicePreferencesSet()</code> és
<code class="code">ServicePreferencesGet()</code>. Adjon vissza 1-et, és ezután a
szinkronizáció rendben van.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-code"></a>Kódpélda</h5></div></div></div><p>
            A felületosztály neve <code class="literal">Kernel::System::Service</code>. A példa
szolgáltatás beállítások hívhatók
<code class="literal">Kernel::System::Service::PreferencesCustom</code> néven. Lent
találhat egy példát.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Service/PreferencesCustom - some user functions
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# Id: PreferencesCustom.pm,v 1.2 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Service::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}          = 'service_preferences';
    $Self-&gt;{PreferencesTableKey}       = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}     = 'preferences_value';
    $Self-&gt;{PreferencesTableServiceID} = 'service_id';

    return $Self;
}

sub ServicePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableServiceID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableServiceID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub ServicePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if service preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('ServicePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableServiceID} = ?",
        Bind =&gt; [ \$Param{ServiceID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni szolgáltatás beállítások modul bekapcsolására. Ezt a
lenti XML beállítás használatával lehet megtenni.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Service::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default service preferences module.&lt;/Description&gt;
    &lt;Description Lang="hu"&gt;Alapértelmezett szolgáltatás beállítások modul.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Service::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Service::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-use_cases"></a>Használati eset példa</h5></div></div></div><p>
            Hasznos beállítások megvalósítás lehet egy SOAP vagy egy RADIUS
háttérprogram.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sla-preferences-module"></a>SLA beállítások modul</h4></div></div></div><p>
        Létezik egy DB SLA beállítások modul, amely az OTRS keretrendszerrel
érkezik. Lehetőség van saját SLA beállítási modulok fejlesztésére is. Az SLA
beállítási modulok a <code class="filename">Kernel/System/SLA/*.pm</code> alatt
találhatók. Ezek beállításáról további információkért nézze meg az
adminisztrátori kézikönyvet. A következőkben egy SLA beállítások modul
példája található. Mentse el a
<code class="filename">Kernel/System/SLA/PreferencesCustom.pm</code>
helyre. Mindössze három függvényre van szüksége: <code class="code">new()</code>,
<code class="code">SLAPreferencesSet()</code> és
<code class="code">SLAPreferencesGet()</code>. Győződjön meg arról, hogy a függvény 1-et
adjon vissza.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-code"></a>Kódpélda</h5></div></div></div><p>
            A felületosztály neve <code class="literal">Kernel::System::SLA</code>. A példa SLA
beállítások hívhatók
<code class="literal">Kernel::System::SLA::PreferencesCustom</code> néven. Lent
találhat egy példát.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/SLA/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::SLA::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}      = 'sla_preferences';
    $Self-&gt;{PreferencesTableKey}   = 'preferences_key';
    $Self-&gt;{PreferencesTableValue} = 'preferences_value';
    $Self-&gt;{PreferencesTableSLAID} = 'sla_id';

    return $Self;
}

sub SLAPreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableSLAID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableSLAID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub SLAPreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if SLA preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('SLAPreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableSLAID} = ?",
        Bind =&gt; [ \$Param{SLAID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni SLA beállítások modul bekapcsolására. Ezt a lenti XML
beállítás használatával lehet megtenni.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="SLA::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Default SLA preferences module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::SLA::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::SLA::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-use_cases"></a>Használati eset példa</h5></div></div></div><p>
            Hasznos beállítások megvalósítás lehet további értékek tárolása az SLA-khoz.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-modules"></a>Egyéb alapfüggvények</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="log-module"></a>Naplózás modul</h4></div></div></div><p>
Létezik egy globális naplózó felület az OTRS-hez, amely a saját naplózó
háttérprogramok létrehozásának lehetőségét biztosítja.
    </p><p>
Egy saját naplózó háttérprogram írása olyan egyszerű, mint újra
megvalósítani a <code class="literal">Kernel::System::Log::Log()</code> metódust.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-code"></a>Kódpélda: <code class="literal">Kernel::System::Log::CustomFile</code></h5></div></div></div><p>
            Ebben a kis példában írni fogunk egy kicsi fájl naplózó háttérprogramot,
amely hasonlóan működik mint a <code class="literal">Kernel::System::Log::File</code>,
de egy szöveget fűz minden naplóbejegyzés elé.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Log/CustomFile.pm - file log backend
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Log::CustomFile;

use strict;
use warnings;

umask "002";

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for (qw(ConfigObject EncodeObject)) {
        if ( $Param{$_} ) {
            $Self-&gt;{$_} = $Param{$_};
        }
        else {
            die "Got no $_!";
        }
    }

    # get logfile location
    $Self-&gt;{LogFile} = '/var/log/CustomFile.log';

    # set custom prefix
    $Self-&gt;{CustomPrefix} = 'CustomFileExample';

    # Fixed bug# 2265 - For IIS we need to create a own error log file.
    # Bind stderr to log file, because IIS do print stderr to web page.
    if ( $ENV{SERVER_SOFTWARE} &amp;&amp; $ENV{SERVER_SOFTWARE} =~ /^microsoft\-iis/i ) {
        if ( !open STDERR, '&gt;&gt;', $Self-&gt;{LogFile} . '.error' ) {
            print STDERR "ERROR: Can't write $Self-&gt;{LogFile}.error: $!";
        }
    }

    return $Self;
}

sub Log {
    my ( $Self, %Param ) = @_;

    my $FH;

    # open logfile
    if ( !open $FH, '&gt;&gt;', $Self-&gt;{LogFile} ) {

        # print error screen
        print STDERR "\n";
        print STDERR " &gt;&gt; Can't write $Self-&gt;{LogFile}: $! &lt;&lt;\n";
        print STDERR "\n";
        return;
    }

    # write log file
    $Self-&gt;{EncodeObject}-&gt;SetIO($FH);
    print $FH '[' . localtime() . ']';
    if ( lc $Param{Priority} eq 'debug' ) {
        print $FH "[Debug][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'info' ) {
        print $FH "[Info][$Param{Module}]  $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'notice' ) {
        print $FH "[Notice][$Param{Module}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'error' ) {
        print $FH "[Error][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    else {

        # print error messages to STDERR
        print STDERR
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";

        # and of course to logfile
        print $FH
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";
    }

    # close file handle
    close $FH;
    return 1;
}

1;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Az egyéni naplózómodul bekapcsolásához az adminisztrátor beállíthatja kézzel
a meglévő <code class="literal">LogModule</code> konfigurációs elemet a
<code class="literal">Kernel::System::Log::CustomFile</code> osztályhoz. Ennek
automatikus megvalósításához megadhat egy XML beállítófájlt, amely
felülbírálja az alapértelmezett beállítást.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="LogModule" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Set Kernel::System::Log::CustomFile as default logging backend.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Core::Log&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/Log/*.pm" SelectedID="Kernel::System::Log::CustomFile"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-use_cases"></a>Használati eset példák</h5></div></div></div><p>
Hasznos naplózó háttérprogram lehet egy webszolgáltatásba vagy egy
titkosított fájlba történő naplózás.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-caveats"></a>Ellenjavaslatok és figyelmeztetések</h5></div></div></div><p>
Ne feledje, hogy a <code class="literal">Kernel::System::Log</code> a
<code class="literal">Log()</code> metóduson kívül egyéb metódusokkal is rendelkezik,
amelyeket nem lehet újra megvalósítani, például az osztott
memóriaszakaszokkal történő munkához tartozó kód és a naplóadatok
gyorsítótárazása.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="outputfilter"></a>Kimenetszűrő</h4></div></div></div><p>
        A kimenetszűrők lehetővé teszik a HTML módosítását röptében. A bevált
gyakorlat a kimenetszűrők használata a <code class="filename">.tt</code> fájlok
közvetlen módosítása helyett. Három jó ok létezik erre. Amikor ugyanazt az
átdolgozást kell alkalmazni számos előtétprogram modulon, akkor az
átdolgozást csak egyszer kell megvalósítani. A második előnye, hogy amikor
az OTRS-t frissítik, akkor megvan az esély arra, hogy a szűrőt nem kell
frissíteni, ha a hozzá tartozó minta nem változott. Amikor két kiterjesztés
ugyanazt a fájlt módosítja, akkor ütközés lép fel a második csomag
telepítése során. Ez az ütközés feloldható két kimenetszűrő használatával,
amelyek ugyanazt az előtétprogram modult módosítják.
    </p><p>
        Három különböző fajta kimenetszűrő létezik. Ezek a HTML tartalom
előállításának különböző szakaszaiban aktívak.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filterelement_post"></a><code class="literal">FilterElementPost</code></h5></div></div></div><p>
            Ezek a szűrők lehetővé teszik egy sablon kimenetének módosítást, miután az
megjelenítésre került.
        </p><p>
            A tartalom lefordításához futtathatja közvetlenül a
<code class="code">$LayoutObject-&gt;Translate()</code> függvényt. Ha egyéb
sablonszolgáltatásokra van szüksége, akkor egyszerűen határozzon meg egy kis
sablonfájlt a kimenetszűrőhöz, és használja azt a tartalom megjelenítéséhez,
mielőtt beültetné azt a fő adatokba. Néhány esetben hasznos lehet a jQuery
DOM műveletek használata is a képernyőn lévő tartalom sorrendjének
megváltoztatásához vagy cseréjéhez a reguláris kifejezések használata
helyett. Ebben az esetben láthatatlan tartalomként kellene beültetnie az új
kódot valahova az oldalba (például a <code class="literal">Hidden</code> osztállyal),
majd ezután áthelyezni a jQuery használatával a megfelelő helyre a DOM-ban,
és megjeleníteni azt.
        </p><p>
            Az utó-kimenetszűrők használatának megkönnyítéséhez létezik egy mechanizmus
is a HTML megjegyzéshorgok lekéréséhez bizonyos sablonoknál vagy
blokkoknál. Hozzáadhatja a modulbeállító XML-be a következőhöz hasonlóan:
        </p><p>
            </p><pre class="programlisting">
&lt;ConfigItem
Name="Frontend::Template::GenerateBlockHooks###100-OTRSBusiness-ContactWithData"
Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Generate HTML comment hooks for
the specified blocks so that filters can use them.&lt;/Description&gt;
    &lt;Group&gt;OTRSBusiness&lt;/Group&gt;
    &lt;SubGroup&gt;Core&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="AgentTicketZoom"&gt;
                &lt;Array&gt;
                    &lt;Item&gt;CustomerTable&lt;/Item&gt;
                &lt;/Array&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            Ez azt fogja okozni, hogy az <code class="filename">AgentTicketZoom.tt</code> fájlban
lévő <code class="literal">CustomerTable</code> blokk át lesz alakítva a HTML
megjegyzésekben minden alkalommal, amikor megjelenítésre kerül:
        </p><p>
            </p><pre class="programlisting">
&lt;!--HookStartCustomerTable--&gt;
... blokk kimenet ...
&lt;!--HookEndCustomerTable--&gt;
            </pre><p>
        </p><p>
            Ezzel a mechanizmussal minden csomag csak azokat a blokkhorgokat kérheti,
amelyekre szüksége van, és következetesen kerülnek megjelenítésre. Ezek a
HTML megjegyzések használhatók ezután a kimenetszűrőben az egyszerű
reguláris kifejezés illesztéshez.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filtercontent"></a><code class="literal">FilterContent</code></h5></div></div></div><p>
            Ez a fajta szűrő lehetővé teszi a teljes HTML kimenet feldolgozását a
kérésnél közvetlenül azelőtt, hogy kiküldésre kerül a böngészőnek. Ez
globális átalakításokhoz használható.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filtertext"></a><code class="literal">FilterText</code></h5></div></div></div><p>
            Ez a fajta kimenetszűrő egy bővítmény a
<code class="literal">Kernel::Output::HTML::Layout::Ascii2HTML()</code> metódushoz, és
csak akkor aktív, amikor a <code class="literal">LinkFeature</code> paraméter 1-re van
állítva. Így a <code class="literal">FilterText</code> kimenetszűrők jelenleg csak az
egyszerű szöveges bejegyzések törzsének megjelenítésénél aktívak. Az
egyszerű szöveges bejegyzéseket a bejövő nem HTML levelek állítják elő,
illetve amikor az OTRS úgy van beállítva, hogy ne használja a Rich Text
szolgáltatást az előtétprogramon.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-code"></a>Kódpélda</h5></div></div></div><p>
            Lásd a <code class="literal">TemplateModule</code> csomagot.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Lásd a <code class="literal">TemplateModule</code> csomagot.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-usecases"></a>Használati esetek</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-10"></a>További jegyattribútumok megjelenítése az <code class="literal">AgentTicketZoom</code>
képernyőn</h6></div></div></div><p>
                Ez egy <code class="literal">FilterElementPost</code> kimenetszűrővel valósítható meg.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-30"></a>A szolgáltatásválasztás megjelenítése többszintű menüként</h6></div></div></div><p>
                Használjon egy <code class="literal">FilterElementPost</code> szűrőt ehhez a
szolgáltatáshoz. A választható szolgáltatások listája a feldolgozott
sablonkimenetből dolgozható fel. A többszintű választás a
szolgáltatáslistából építhető fel, és szúrható be a sablontartalomba. Egy
<code class="literal">FilterElementPost</code> kimenetszűrőt kell használni ehhez.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-40"></a>Hivatkozások létrehozása az egyszerű szöveges bejegyzés törzseiben</h6></div></div></div><p>
                Egy biotechnológiai vállalat IPI00217472 formátumú génneveket használ az
egyszerű szöveges bejegyzésekben. Egy <code class="literal">FilterText</code>
kimenetszűrő használható a szekvencia-adatbázisra mutató hivatkozások
létrehozásához a génneveknél, például
http://srs.ebi.ac.uk/srsbin/cgi-bin/wgetz?-e+[IPI-acc:IPI00217472]+-vn+2
formában.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-50"></a>Az aktív tartalom megtiltása</h6></div></div></div><p>
                Van egy olyan tűzfalszabály, amely megtiltja az összes aktív
tartalmat. Azért, hogy elkerüljük a tűzfal visszautasítását, az
<code class="literal">&lt;applet&gt;</code> HTML-címke kiszűrhető egy
<code class="literal">FilterContent</code> kimenetszűrővel.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-caveats"></a>Ellenjavaslatok és figyelmeztetések</h5></div></div></div><p>
            Minden <code class="literal">FilterElementPost</code> kimenetszűrő felépítésre és
futtatásra kerül minden olyan beállított sablonnál, amely szükséges az
aktuális kéréshez. Így a kimenetszűrő alacsony teljesítménye vagy a szűrők
nagy száma komolyan csökkentheti a teljesítményt.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-bestpractice"></a>Bevált gyakorlatok</h5></div></div></div><p>
            A rugalmasság növelésének érdekében az érintett sablonok listáját be kell
állítani a rendszerbeállításokban.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
            A kimenetszűrők az OTRS 2.4-es verziójától érhetők el. A
<code class="literal">FilterElementPre</code> típus eldobásra került az OTRS 5-tel.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="module-stats"></a>Statisztikák modul</h4></div></div></div><p>
A belső statisztikamoduloknak két különböző típusa létezik - dinamikus és
statikus. Ez a szakasz azt írja le, hogy az ilyen statisztikamodulok hogyan
fejleszthetők.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="module-stats-dynamic"></a>Dinamikus statisztikák</h5></div></div></div><p>
A statikus statisztikamodulokkal ellentétben a dinamikus statisztikák
beállíthatók az OTRS webes felületén keresztül. Ebben a szakaszban egy
egyszerű statisztikamodul kerül fejlesztésre. Minden egyes dinamikus
statisztikamodulnak meg kell valósítania ezeket a szubrutinokat:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">GetObjectName</code></p></li><li class="listitem"><p><code class="literal">GetObjectAttributes</code></p></li><li class="listitem"><p><code class="literal">ExportWrapper</code></p></li><li class="listitem"><p><code class="literal">ImportWrapper</code></p></li></ul></div><p>
        </p><p>
Továbbá a modulnak meg kell valósítania vagy a
<code class="literal">GetStatElement</code>, vagy a <code class="literal">GetStatTable</code>
rutint. És ha az eredménytábla fejlécsorát is meg kell változtatni, akkor
egy úgynevezett <code class="literal">GetHeaderLine</code> szubrutint is fejleszteni
kell.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-subroutines"></a>Kódpélda</h6></div></div></div><p>
Ebben a szakaszban egy minta statisztikamodul lesz megjelenítve, és minden
szubrutin elmagyarázásra kerül.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;
                </pre><p>
            </p><p>
Ez egy gyakori sabloncsomag, amely megtalálható a szokásos OTRS
modulokban. Az osztály/csomag neve a <code class="literal">package</code> kulcsszón
keresztül van deklarálva. Ezután a szükséges modulok használatának megadása
következik a <code class="literal">use</code> kulcsszóval.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # új kivonat lefoglalása az objektumhoz
    my $Self = {};
    bless( $Self, $Type );

    # a szükséges objektumok ellenőrzése
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Nincs $Object!";
    }

    # a létrehozott szükséges objektumok
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
A <code class="literal">new</code> a statisztikamodul konstruktora. Ez hozza létre az
osztály új példányát. A kódolási irányelveknek megfelelően az ebben a
modulban szükséges más osztályok objektumait is a <code class="literal">new</code>
konstruktorban kell létrehozni. A 27-29. sorban van létrehozva a
statisztikák modul objektuma. A 31-37. sorban azt ellenőrzik, hogy az ebben
a kódban szükséges objektumok - vagy más objektumok létrehozásánál, vagy
ebben a modulban - át vannak-e adva. Ezután a többi objektum kerül
létrehozásra.
            </p><p>
                </p><pre class="programlisting">
sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Minta statisztikák';
}
                </pre><p>
            </p><p>
A <code class="literal">GetObjectName</code> visszaad egy nevet a statisztikák
modulhoz. Ez az a címke, amely a lenyíló menüben jelenik meg a
beállításokban, valamint a meglévő statisztikák listájában (az „objektum”
oszlopban).
            </p><p>
                </p><pre class="programlisting">
sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # állapotlista lekérése
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # várólisták listájának lekérése
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # a jelenlegi idő lekérése a 3830. hiba javításához
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'Állapot',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Létrehozva várólistában',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Létrehozás ideje',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}
                </pre><p>
            </p><p>
Ebben a minta statisztikák modulban három olyan attribútumot szeretnénk
szolgáltatni, amelyből a felhasználó választhat: a várólisták listáját, az
állapotok listáját és egy idő legördülőt. A legördülőben megjelenített
értékek lekéréséhez szükséges néhány művelet. Ebben az esetben a
<code class="literal">StateList</code> és a <code class="literal">GetAllQueues</code> kerül
meghívásra.
            </p><p>
Ezután az attribútumok listája kerül létrehozásra. Minden egyes attribútum
egy kivonathivatkozáson keresztül van meghatározva. Ezeket a kulcsokat
használhatja:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">Name</code></p><p>A címke a webes felületen.</p></li><li class="listitem"><p><code class="literal">UseAsXvalue</code></p><p>Ez az attribútum használható az X-tengelyen.</p></li><li class="listitem"><p><code class="literal">UseAsValueSeries</code></p><p>Ez az attribútum használható az Y-tengelyen.</p></li><li class="listitem"><p><code class="literal">UseAsRestriction</code></p><p>Ez az attribútum használható a korlátozásokhoz.</p></li><li class="listitem"><p><code class="literal">Element</code></p><p>A HTML mező neve.</p></li><li class="listitem"><p><code class="literal">Block</code></p><p>A blokknév a sablonfájlban (például
<code class="filename">&lt;OTRS_HOME&gt;/Kernel/Output/HTML/Standard/AgentStatsEditXaxis.tt</code>).</p></li><li class="listitem"><p><code class="literal">Values</code></p><p>Az attribútumban megjelenített értékek.</p></li></ul></div><p>
            </p><p>
Tipp: Ha telepíti ezt a mintát, és beállít egy statisztikát néhány
várólistával (mondjuk „A várólista” és „B várólista”), akkor ezek a
várólisták az egyetlenek, amelyek láthatóak lesznek a felhasználónak, amikor
elindítja a statisztikát. Néha egy dinamikus legördülő vagy többválasztós
mező szükséges. Ebben az esetben beállíthatja a
<code class="literal">SelectedValues</code> kulcsot az attribútum meghatározásában:
            </p><p>
                </p><pre class="programlisting">
        {
            Name             =&gt; 'Létrehozva várólistában',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
            SelectedValues   =&gt; [ @SelectedQueues ],
        },
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # jegyek keresése
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}
                </pre><p>
            </p><p>
A <code class="literal">GetStatElement</code> kerül meghívásra minden egyes cellánál
az eredménytáblában. Így annak számszerű értéknek kell lennie. Ebben a
mintában egy egyszerű jegykeresést hajt végre. A <code class="literal">%Param</code>
kivonat tartalmaz információkat a „jelenlegi” X-értékről és Y-értékről,
valamint bármely korlátozásról. Így egy olyan cellánál, amelynek össze kell
számolnia a „nyitott” állapotban lévő létrehozott jegyeket a „Misc”
várólistánál, az átadott paraméter kivonat valahogy így néz ki:
            </p><p>
                </p><pre class="programlisting">
    'CreatedQueueIDs' =&gt; [
        '4'
    ],
    'StateIDs' =&gt; [
        '2'
    ]
                </pre><p>
            </p><p>
Ha a „cellánkénti” számítást el kellene kerülni, akkor a
<code class="literal">GetStatTable</code> egy alternatíva. A
<code class="literal">GetStatTable</code> visszaadja a sorok listáját, amely ezentúl
egy tömbhivatkozások tömbje. Ez ugyanahhoz az eredményhez vezet mint a
<code class="literal">GetStatElement</code> használata.
            </p><p>
                </p><pre class="programlisting">
sub GetStatTable {
    my ( $Self, %Param ) = @_;

    my @StatData;

    for my $StateName ( keys %{ $Param{TableStructure} } ) {
        my @Row;
        for my $Params ( @{ $Param{TableStructure}-&gt;{$StateName} } ) {
            my $Tickets = $Self-&gt;{TicketObject}-&gt;TicketSearch(
                UserID     =&gt; 1,
                Result     =&gt; 'COUNT',
                Permission =&gt; 'ro',
                Limit      =&gt; 100_000_000,
                %{$Params},
            );

            push @Row, $Tickets;
        }

        push @StatData, [ $StateName, @Row ];
    }

    return @StatData;
}
                </pre><p>
            </p><p>
A <code class="literal">GetStatTable</code> az összes olyan információt lekéri a
statisztikák lekérdezéssel kapcsolatban, amelyek szükségesek. Az átadott
paraméterek információkat tartalmaznak az attribútumokról
(<code class="literal">Restrictions</code>, olyan attribútumok, amelyek az
X/Y-tengelynél vannak használva) és a táblaszerkezetről. A táblaszerkezet
egy olyan kivonathivatkozás, ahol a kulcsok az Y-tengely értékei, és azok
értékei kivonathivatkozások a <code class="literal">GetStatElement</code>
szubrutinokhoz használt paraméterekkel.
            </p><p>
                </p><pre class="programlisting">
    'Restrictions' =&gt; {},
    'TableStructure' =&gt; {
        'closed successful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '2'
                ]
            },
        ],
        'closed unsuccessful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '3'
                ]
            },
        ],
    },
    'ValueSeries' =&gt; [
        {
            'Block' =&gt; 'MultiSelectField',
            'Element' =&gt; 'StateIDs',
            'Name' =&gt; 'Állapot',
            'SelectedValues' =&gt; [
                '5',
                '3',
                '2',
                '1',
                '4'
            ],
            'Translation' =&gt; 1,
            'Values' =&gt; {
                '1' =&gt; 'new',
                '10' =&gt; 'closed with workaround',
                '2' =&gt; 'closed successful',
                '3' =&gt; 'closed unsuccessful',
                '4' =&gt; 'open',
                '5' =&gt; 'removed',
                '6' =&gt; 'pending reminder',
                '7' =&gt; 'pending auto close+',
                '8' =&gt; 'pending auto close-',
                '9' =&gt; 'merged'
            }
        }
    ],
    'XValue' =&gt; {
        'Block' =&gt; 'MultiSelectField',
        'Element' =&gt; 'CreatedQueueIDs',
        'Name' =&gt; 'Létrehozva várólistában',
        'SelectedValues' =&gt; [
            '3',
            '4',
            '1',
            '2'
        ],
        'Translation' =&gt; 0,
        'Values' =&gt; {
            '1' =&gt; 'Postmaster',
            '2' =&gt; 'Raw',
            '3' =&gt; 'Junk',
            '4' =&gt; 'Misc'
        }
    }
                </pre><p>
            </p><p>
Néha a táblázat fejléceit meg kell változtatni. Ebben az esetben egy
<code class="literal">GetHeaderLine</code> nevű szubrutint kell megvalósítani. Ennek a
szubrutinnak egy tömbhivatkozást kell visszaadnia az oszlopfejlécekkel mint
elemekkel. Ez információkat kap az átadott X-értékekkel kapcsolatban.
            </p><p>
                </p><pre class="programlisting">
sub GetHeaderLine {
    my ( $Self, %Param ) = @_;

    my @HeaderLine = ('');
    for my $SelectedXValue ( @{ $Param{XValue}-&gt;{SelectedValues} } ) {
        push @HeaderLine, $Param{XValue}-&gt;{Values}-&gt;{$SelectedXValue};
    }

    return \@HeaderLine;
}
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # azonosítók átalakítása a használt helyesíráshoz
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}
                </pre><p>
            </p><p>
A beállított statisztikák exportálhatók XML-formátumba. De ahogy a
várólistáknál, ahol ugyanazok a várólistanevek rendelkezhetnek különböző
azonosítókkal a különböző OTRS példányoknál, különösen fájdalmas lehet az
azonosítók exportálása (a statisztikák ekkor rossz számokat számítanának
ki). Ezért egy exportálási átalakítót kell írni, hogy az azonosítók helyett
neveket használjon. Ezt a statisztikák modul minden egyes „dimenziójánál” el
kell végezni (X-tengely, Y-tengely és korlátozások).
            </p><p>
Az <code class="literal">ImportWrapper</code> fordítva működik - átalakítja a nevet az
azonosítóra abban a példányban, ahova a beállítások importálásra kerülnek.
            </p><p>
Ez egy minta exportálás:
            </p><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;otrs_stats&gt;
&lt;Cache&gt;0&lt;/Cache&gt;
&lt;Description&gt;Minta statisztikák modul&lt;/Description&gt;
&lt;File&gt;&lt;/File&gt;
&lt;Format&gt;CSV&lt;/Format&gt;
&lt;Format&gt;Print&lt;/Format&gt;
&lt;Object&gt;DeveloperManualSample&lt;/Object&gt;
&lt;ObjectModule&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/ObjectModule&gt;
&lt;ObjectName&gt;Sample Statistics&lt;/ObjectName&gt;
&lt;Permission&gt;stats&lt;/Permission&gt;
&lt;StatType&gt;dynamic&lt;/StatType&gt;
&lt;SumCol&gt;0&lt;/SumCol&gt;
&lt;SumRow&gt;0&lt;/SumRow&gt;
&lt;Title&gt;Sample 1&lt;/Title&gt;
&lt;UseAsValueSeries Element="StateIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;removed&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed unsuccessful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed successful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;new&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;open&lt;/SelectedValues&gt;
&lt;/UseAsValueSeries&gt;
&lt;UseAsXvalue Element="CreatedQueueIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;Junk&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Misc&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Postmaster&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Raw&lt;/SelectedValues&gt;
&lt;/UseAsXvalue&gt;
&lt;Valid&gt;1&lt;/Valid&gt;
&lt;/otrs_stats&gt;
                </pre><p>
            </p><p>
Most, hogy az összes szubrutin elmagyarázásra került, itt a teljes minta
statisztikák modul.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # created needed objects
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}

sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Sample Statistics';
}

sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # get state list
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # get queue list
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # get current time to fix bug#3830
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'State',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Create Time',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}

sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # search tickets
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}

sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap ids to used spelling
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}

sub ImportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap used spelling to ids
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    if ( $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} ) ) {
                        $ID-&gt;{Content}
                            = $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} );
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find the queue $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;

                    my %State = $Self-&gt;{StateObject}-&gt;StateGet(
                        Name  =&gt; $ID-&gt;{Content},
                        Cache =&gt; 1,
                    );
                    if ( $State{ID} ) {
                        $ID-&gt;{Content} = $State{ID};
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find state $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
        }
    }
    return \%Param;
}

1;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-configuration"></a>Beállítási példa</h6></div></div></div><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;otrs_config version="1.0" init="Config"&gt;
    &lt;ConfigItem Name="Stats::DynamicObjectRegistration###DynamicStatsTemplate" Required="0" Valid="1"&gt;
        &lt;Description Lang="en"&gt;Here you can decide if the common stats module may generate stats about the number of default tickets a requester created.&lt;/Description&gt;
        &lt;Group&gt;Framework&lt;/Group&gt;
        &lt;SubGroup&gt;Core::Stats&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
&lt;/otrs_config&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-use_cases"></a>Használati eset példák</h6></div></div></div><p>
Használati esetek.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-caveats"></a>Ellenjavaslatok és figyelmeztetések</h6></div></div></div><p>
Ha nagyon sok cellája van az eredménytáblázatban és a
<code class="literal">GetStatElement</code> meglehetősen összetett, akkor a kérés
eltarthat egy ideig.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-releases"></a>Kiadási elérhetőség</h6></div></div></div><p>
A dinamikus statisztikamodulok az OTRS 2.0 óta érhetők el.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="module-stats-static"></a>Statikus statisztikák</h5></div></div></div><p>
A következő bekezdések a statikus statisztikákat írják le. A statikus
statisztikákat nagyon könnyű létrehozni, mivel ezeknek a moduloknak csak
három szubrutint kell megvalósítaniuk.
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">Param</code></p></li><li class="listitem"><p><code class="literal">Run</code></p></li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-subroutines"></a>Kódpélda</h6></div></div></div><p>
A következő bekezdések a statikus statisztikákban szükséges szubrutinokat
mutatják be.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # új kivonat lefoglalása az objektumhoz
    my $Self = {%Param};
    bless( $Self, $Type );

    # az összes szükséges objektum ellenőrzése
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Nincs $Needed";
    }

    # a szükséges objektumok létrehozása
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
A <code class="literal">new</code> hozza létre a statikus statisztikák osztályának egy
új példányát. Először létrehoz egy új objektumot, és azután ellenőrzi a
szükséges objektumokat.
            </p><p>
                </p><pre class="programlisting">
sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}
                </pre><p>
            </p><p>
A <code class="literal">Param</code> metódus biztosítja az összes olyan paraméter és
attribútum listáját, amelyek kiválaszthatók egy statikus statisztika
létrehozásához. Megkap néhány átadott paramétert: az értékeket egy kérésben
szolgáltatott statisztikák attribútumaihoz, a statisztikák formátumát és az
objektum nevét (a modul nevét).
            </p><p>
A paramétereknek és az attribútumoknak kivonathivatkozásoknak kell lenniük
ezekkel a kulcs-érték párokkal:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">Frontend</code></p><p>A címke a webes felületen.</p></li><li class="listitem"><p><code class="literal">Name</code></p><p>A HTML mező neve.</p></li><li class="listitem"><p><code class="literal">Data</code></p><p>Az attribútumban megjelenített értékek.</p></li></ul></div><p>
            </p><p>
Egyéb paraméterek is használhatók a <code class="literal">LayoutObject</code>
<code class="literal">BuildSelection</code> metódusánál, ahogy az a
<code class="literal">Size</code> és <code class="literal">Multiple</code> paraméterekkel
történik ebben a minta modulban.
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # a szükséges dolgok ellenőrzése
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Szükséges: $Needed!",
            );
            return;
        }
    }

    # a jelentés címének beállítása
    my $Title = 'Jegyek várólistánként';

    # táblázat címsorok
    my @HeadData = (
        'Jegyszám',
        'Várólista',
        'Típus',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}
                </pre><p>
            </p><p>
Tulajdonképpen a <code class="literal">Run</code> metódus állítja elő a táblázat
adatait a statisztikákhoz. Megkapja az ennél a statisztikánál átadott
attribútumokat. Ebben a mintában a <code class="literal">%Param</code> paraméterben
egy <code class="literal">TypeIDs</code> kulcs és egy <code class="literal">QueueIDs</code>
kulcs létezik (lásd a <code class="literal">Param</code> metódusban lévő
attribútumokat), és ezek értékei tömbhivatkozások. A visszaadott adatok
három részből állnak: két tömbhivatkozásból és egy tömbből. Az első
tömbhivatkozásban a statisztika címe van eltárolva, a második tömbhivatkozás
tartalmazza a táblázatban lévő oszlopok címsorait. És ezután a táblázattörzs
adatai következnek.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Static/StaticStatsTemplate.pm
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Stats::Static::StaticStatsTemplate;

use strict;
use warnings;

use Kernel::System::Type;
use Kernel::System::Ticket;
use Kernel::System::Queue;

=head1 NAME

StaticStatsTemplate.pm - the module that creates the stats about tickets in a queue

=head1 SYNOPSIS

All functions

=head1 PUBLIC INTERFACE

=over 4

=cut

=item new()

create an object

    use Kernel::Config;
    use Kernel::System::Encode;
    use Kernel::System::Log;
    use Kernel::System::Main;
    use Kernel::System::Time;
    use Kernel::System::DB;
    use Kernel::System::Stats::Static::StaticStatsTemplate;

    my $ConfigObject = Kernel::Config-&gt;new();
    my $EncodeObject = Kernel::System::Encode-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $LogObject    = Kernel::System::Log-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $MainObject = Kernel::System::Main-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $TimeObject = Kernel::System::Time-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $DBObject = Kernel::System::DB-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
    );
    my $StatsObject = Kernel::System::Stats::Static::StaticStatsTemplate-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
        TimeObject   =&gt; $TimeObject,
        DBObject     =&gt; $DBObject,
        EncodeObject =&gt; $EncodeObject,
    );

=cut

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # check all needed objects
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed";
    }

    # create needed objects
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}

=item Param()

Get all parameters a user can specify.

    my @Params = $StatsObject-&gt;Param();

=cut

sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}

=item Run()

generate the statistic.

    my $StatsInfo = $StatsObject-&gt;Run(
        TypeIDs  =&gt; [
            1, 2, 4
        ],
        QueueIDs =&gt; [
            3, 4, 6
        ],
    );

=cut

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );
            return;
        }
    }

    # set report title
    my $Title = 'Tickets per Queue';

    # table headlines
    my @HeadData = (
        'Ticket Number',
        'Queue',
        'Type',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}

1;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-configuration"></a>Beállítási példa</h6></div></div></div><p>
Nincs szükség beállításokra. Közvetlenül telepítés után a modul elérhető egy
statisztika létrehozásához ennél a modulnál.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-use_cases"></a>Használati eset példák</h6></div></div></div><p>
Használati esetek.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-caveats"></a>Ellenjavaslatok és figyelmeztetések</h6></div></div></div><p>
Ellenjavaslatok és figyelmeztetések a statikus statisztikáknál.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-releases"></a>Kiadási elérhetőség</h6></div></div></div><p>
A statikus statisztikamodulok az OTRS 1.3 óta érhetők el.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-using-old-stats"></a>Régi statikus statisztikák használata</h6></div></div></div><p>
A szabványos 1.3-as és 2.0-ás OTRS verziók már megkönnyítették a
statisztikák előállítását. Az OTRS 1.3-as és 2.0-ás verzióinak különféle
statisztikái, amelyek különlegesen lettek kifejlesztve, hogy kielégítsék az
ügyfelek követelményeit, használhatók az újabb verziókban is.
            </p><p>
A fájlokat pusztán csak át kell helyezni a
<code class="filename">Kernel/System/Stats/</code> útvonalról a
<code class="filename">Kernel/System/Stats/Static/</code> könyvtárba. Továbbá a
megfelelő parancsfájl csomagnevét <code class="literal">::Static</code> névre kell
módosítani.
            </p><p>
A következő példa azt mutatja be, hogy hogyan kell az első útvonalat
módosítani.
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::AccountedTime;
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::Static::AccountedTime;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticketnumber-generator"></a>Jegyszám előállító modulok</h4></div></div></div><p>
        A jegyszám előállítókat elkülönülő azonosítók létrehozásához használják az
új jegyekhez, amelyeket jegyszámnak neveznek. Bármilyen metódus lehetséges a
számok karakterláncainak létrehozásához, de a józan ész határain belül kell
maradnia az eredményül kapott szöveg hosszával kapcsolatban (irányelv:
5-10).
    </p><p>
        Egy jegyszám létrehozásakor győződjön meg arról, hogy az eredmény megkapta-e
a <code class="literal">SystemID</code> rendszerbeállítási változót előtagként annak
érdekében, hogy engedélyezze a jegyszámok felismerését a bejövő e-mail
válaszoknál. Egy jegyszám előállító modulnak a következő két függvényre van
szüksége: <code class="code">TicketCreateNumber()</code> és <code class="code">GetTNByString()</code>.
    </p><p>
        A <code class="code">TicketCreateNumber()</code> metódus paraméterek nélkül kerül
meghívásra, és az új jegyszámot adja vissza.
    </p><p>
        A <code class="code">GetTNByString()</code> metódus egy olyan szöveg paraméterrel kerül
meghívásra, amely a feldolgozandó szöveget tartalmazza a jegyszámnál, és
visszaadja a jegyszámot, ha megtalálta.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-code"></a>Kódpélda</h5></div></div></div><p>
            Nézze meg a <code class="filename">Kernel/System/Ticket/Number/UserRandom.pm</code>
fájlt a <code class="literal">TemplateModule</code> csomagban.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Nézze meg a
<code class="filename">Kernel/Config/Files/TicketNumberGenerator.xml</code> fájlt a
<code class="literal">TemplateModule</code> csomagban.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-usecases"></a>Használati esetek</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-usecase-10"></a>A jegyszámoknak egy bizonyos sémát kell követniük.</h6></div></div></div><p>
                Akkor kell majd egy új jegyszám előállítót létrehoznia, ha az
alapértelmezett modulok nem biztosítják azt a jegyszám sémát, amelyet
használni szeretne.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-caveats"></a>Ellenjavaslatok és figyelmeztetések</h5></div></div></div><p>
            Ragaszkodnia kell a meglévő jegyszám előállítókban használt
<code class="code">GetTNByString()</code> kódjához, hogy megelőzze a jegyszám
feldolgozással kapcsolatos problémákat. A <code class="code">TicketCreateNumber()</code>
metódusban lévő hurok felismeréséhez használt rutint is érintetlenül kell
hagynia a kettőzött jegyszámok megelőzéséhez.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
            A jegyszám előállítók az OTRS 1.1 óta lettek elérhetők az OTRS-ben.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticketevent"></a>Jegyesemény modul</h4></div></div></div><p>
        A jegyesemény modulok közvetlenül azután futnak le, amikor egy jegyművelet
megtörténik. Megegyezés szerint ezek a modulok a
<code class="filename">Kernel/System/Ticket/Event</code> könyvtárban találhatók. Egy
jegyesemény modulnak mindössze két függvényre van szüksége:
<code class="code">new()</code> és <code class="code">Run()</code>. A <code class="code">Run()</code> metódus
legalább az <code class="literal">Event</code>, a <code class="literal">UserID</code> és a
<code class="literal">Data</code> paramétereket fogadja. A <code class="literal">Data</code> a
jegy adatait tartalmazó kivonathivatkozás, és a bejegyzésre vonatkozó
események esetében a bejegyzés adatait is tartalmazza.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-code"></a>Kódpélda</h5></div></div></div><p>
            Nézze meg a
<code class="filename">Kernel/System/Ticket/Event/EventModulePostTemplate.pm</code>
fájlt a <code class="literal">TemplateModule</code> csomagban.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Nézze meg a
<code class="filename">Kernel/Config/Files/EventModulePostTemplate.xml</code> fájlt a
<code class="literal">TemplateModule</code> csomagban.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-usecases"></a>Használati esetek</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-10"></a>Egy jegyet fel kell oldani egy áthelyezés művelet után.</h6></div></div></div><p>
                Ez a szabványos funkció a
<code class="literal">Kernel::System::Ticket::Event::ForceUnlock</code> jegyesemény
modullal lett megvalósítva. Amikor erre a funkcióra nincs szükség, akkor az
kikapcsolható a
<code class="literal">Ticket::EventModulePost###910-ForceUnlockOnMove</code>
rendszerbeállítási bejegyzés beállításának törlésével.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-20"></a>További tisztítóművelet végrehajtása egy jegy törlésekor.</h6></div></div></div><p>
                Egy személyre szabott OTRS tarthat nem szabványos adatokat további
adatbázistáblákban. Amikor egy jegyet törölnek, akkor ezeket a további
adatokat is törölni kell. Ez a funkcionalitás elérhető egy olyan jegyesemény
modullal, amely a <code class="literal">TicketDelete</code> eseményekre figyel.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-30"></a>Az új jegyeket közzé kell tenni a Twitteren.</h6></div></div></div><p>
                Egy <code class="literal">TicketCreate</code> eseményre figyelő jegyesemény modul
képes üzeneteket kiküldeni a Twitterre.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-caveats"></a>Ellenjavaslatok és figyelmeztetések</h5></div></div></div><p>
            Nincsenek ismert ellenjavaslatok.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
            A jegyesemények az OTRS 2.0 óta lettek elérhetők az OTRS-ben.
        </p><p>
            Az OTRS 6.0 verziójában elérhető jegyesemények:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>TicketCreate</p></li><li class="listitem"><p>TicketDelete</p></li><li class="listitem"><p>TicketTitleUpdate</p></li><li class="listitem"><p>TicketUnlockTimeoutUpdate</p></li><li class="listitem"><p>TicketQueueUpdate</p></li><li class="listitem"><p>TicketTypeUpdate</p></li><li class="listitem"><p>TicketServiceUpdate</p></li><li class="listitem"><p>TicketSLAUpdate</p></li><li class="listitem"><p>TicketCustomerUpdate</p></li><li class="listitem"><p>TicketPendingTimeUpdate</p></li><li class="listitem"><p>TicketLockUpdate</p></li><li class="listitem"><p>TicketArchiveFlagUpdate</p></li><li class="listitem"><p>TicketStateUpdate</p></li><li class="listitem"><p>TicketOwnerUpdate</p></li><li class="listitem"><p>TicketResponsibleUpdate</p></li><li class="listitem"><p>TicketPriorityUpdate</p></li><li class="listitem"><p>HistoryAdd</p></li><li class="listitem"><p>HistoryDelete</p></li><li class="listitem"><p>TicketAccountTime</p></li><li class="listitem"><p>TicketMerge</p></li><li class="listitem"><p>TicketSubscribe</p></li><li class="listitem"><p>TicketUnsubscribe</p></li><li class="listitem"><p>TicketFlagSet</p></li><li class="listitem"><p>TicketFlagDelete</p></li><li class="listitem"><p>EscalationResponseTimeNotifyBefore</p></li><li class="listitem"><p>EscalationUpdateTimeNotifyBefore</p></li><li class="listitem"><p>EscalationSolutionTimeNotifyBefore</p></li><li class="listitem"><p>EscalationResponseTimeStart</p></li><li class="listitem"><p>EscalationUpdateTimeStart</p></li><li class="listitem"><p>EscalationSolutionTimeStart</p></li><li class="listitem"><p>EscalationResponseTimeStop</p></li><li class="listitem"><p>EscalationUpdateTimeStop</p></li><li class="listitem"><p>EscalationSolutionTimeStop</p></li><li class="listitem"><p>NotificationNewTicket</p></li><li class="listitem"><p>NotificationFollowUp</p></li><li class="listitem"><p>NotificationLockTimeout</p></li><li class="listitem"><p>NotificationOwnerUpdate</p></li><li class="listitem"><p>NotificationResponsibleUpdate</p></li><li class="listitem"><p>NotificationAddNote</p></li><li class="listitem"><p>NotificationMove</p></li><li class="listitem"><p>NotificationPendingReminder</p></li><li class="listitem"><p>NotificationEscalation</p></li><li class="listitem"><p>NotificationEscalationNotifyBefore</p></li><li class="listitem"><p>NotificationServiceUpdate</p></li></ul></div><p>
        </p><p>
            Az OTRS 6.0 verziójában elérhető bejegyzésesemények:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>ArticleCreate</p></li><li class="listitem"><p>ArticleUpdate</p></li><li class="listitem"><p>ArticleSend</p></li><li class="listitem"><p>ArticleBounce</p></li><li class="listitem"><p>ArticleAgentNotification</p></li><li class="listitem"><p>ArticleCustomerNotification</p></li><li class="listitem"><p>ArticleAutoResponse</p></li><li class="listitem"><p>ArticleFlagSet</p></li><li class="listitem"><p>ArticleFlagDelete</p></li><li class="listitem"><p>ArticleAgentNotification</p></li><li class="listitem"><p>ArticleCustomerNotification</p></li></ul></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-modules"></a>Előtétprogram modulok</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="module-dashboard"></a>Vezérlőpult modul</h4></div></div></div><p>
Vezérlőpult modul statisztikák megjelenítéséhez vonaldiagram formájában.
        </p><p>
            </p><div class="figure"><a name="id-1.4.3.6.2.3.1"></a><p class="title"><b>3.1. ábra - Vezérlőpult felületi elem</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/dashboard.png" alt="Vezérlőpult felületi elem"></div></div></div></div><p><br class="figure-break">
        </p><p>
            </p><pre class="programlisting">
# --
# Kernel/Output/HTML/DashboardTicketStatsGeneric.pm - message of the day
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Output::HTML::DashboardTicketStatsGeneric;

use strict;
use warnings;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # get needed objects
    for (
        qw(Config Name ConfigObject LogObject DBObject LayoutObject ParamObject TicketObject UserID)
        )
    {
        die "Got no $_!" if !$Self-&gt;{$_};
    }

    return $Self;
}

sub Preferences {
    my ( $Self, %Param ) = @_;

    return;
}

sub Config {
    my ( $Self, %Param ) = @_;

    my $Key = $Self-&gt;{LayoutObject}-&gt;{UserLanguage} . '-' . $Self-&gt;{Name};
    return (
        %{ $Self-&gt;{Config} },
        CacheKey =&gt; 'TicketStats' . '-' . $Self-&gt;{UserID} . '-' . $Key,
    );

}

sub Run {
    my ( $Self, %Param ) = @_;

    my %Axis = (
        '7Day' =&gt; {
            0 =&gt; { Day =&gt; 'Sun', Created =&gt; 0, Closed =&gt; 0, },
            1 =&gt; { Day =&gt; 'Mon', Created =&gt; 0, Closed =&gt; 0, },
            2 =&gt; { Day =&gt; 'Tue', Created =&gt; 0, Closed =&gt; 0, },
            3 =&gt; { Day =&gt; 'Wed', Created =&gt; 0, Closed =&gt; 0, },
            4 =&gt; { Day =&gt; 'Thu', Created =&gt; 0, Closed =&gt; 0, },
            5 =&gt; { Day =&gt; 'Fri', Created =&gt; 0, Closed =&gt; 0, },
            6 =&gt; { Day =&gt; 'Sat', Created =&gt; 0, Closed =&gt; 0, },
        },
    );

    my @Data;
    my $Max = 1;
    for my $Key ( 0 .. 6 ) {

        my $TimeNow = $Self-&gt;{TimeObject}-&gt;SystemTime();
        if ($Key) {
            $TimeNow = $TimeNow - ( 60 * 60 * 24 * $Key );
        }
        my ( $Sec, $Min, $Hour, $Day, $Month, $Year, $WeekDay )
            = $Self-&gt;{TimeObject}-&gt;SystemTime2Date(
            SystemTime =&gt; $TimeNow,
            );

        $Data[$Key]-&gt;{Day} = $Self-&gt;{LayoutObject}-&gt;{LanguageObject}-&gt;Get(
            $Axis{'7Day'}-&gt;{$WeekDay}-&gt;{Day}
        );

        my $CountCreated = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCreateTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCreateTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Created} = $CountCreated;
        if ( $CountCreated &gt; $Max ) {
            $Max = $CountCreated;
        }

        my $CountClosed = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCloseTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCloseTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Closed} = $CountClosed;
        if ( $CountClosed &gt; $Max ) {
            $Max = $CountClosed;
        }
    }

    @Data = reverse @Data;
    my $Source = $Self-&gt;{LayoutObject}-&gt;JSONEncode(
        Data =&gt; \@Data,
    );

    my $Content = $Self-&gt;{LayoutObject}-&gt;Output(
        TemplateFile =&gt; 'AgentDashboardTicketStats',
        Data         =&gt; {
            %{ $Self-&gt;{Config} },
            Key    =&gt; int rand 99999,
            Max    =&gt; $Max,
            Source =&gt; $Source,
        },
    );

    return $Content;
}

1;
            </pre><p>
        </p><p>
Ezen modul használatához adja hozzá a következőket a
<code class="filename">Kernel/Config.pm</code> fájlhoz, és indítsa újra a
webkiszolgálóját (ha a <code class="literal">mod_perl</code> modult használja).
        </p><p>
            </p><pre class="programlisting">
&lt;ConfigItem Name="DashboardBackend###0250-TicketStats" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the dashboard backend. "Group" are used to restricted access to the plugin (e. g. Group: admin;group1;group2;). "Default" means if the plugin is enabled per default or if the user needs to enable it manually. "CacheTTL" means the cache time in minutes for the plugin.&lt;/Description&gt;
    &lt;Description Lang="hu"&gt;Paraméterek a vezérlőpult háttérprogramhoz. A „Csoport” használható a hozzáférés korlátozásához a bővítményre (például Csoport: admin;csoport1;csoport2;). Az „Alapértelmezett” azt jelenti, hogy a bővítmény alapértelmezetten engedélyezve van, vagy hogy a felhasználónak kézzel kell engedélyeznie azt. A „CacheTTL” a bővítmény gyorsítótár lejárati időtartamát jelenti percben.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Dashboard&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::DashboardTicketStatsGeneric&lt;/Item&gt;
            &lt;Item Key="Title"&gt;7 Day Stats&lt;/Item&gt;
            &lt;Item Key="Created"&gt;1&lt;/Item&gt;
            &lt;Item Key="Closed"&gt;1&lt;/Item&gt;
            &lt;Item Key="Permission"&gt;rw&lt;/Item&gt;
            &lt;Item Key="Block"&gt;ContentSmall&lt;/Item&gt;
            &lt;Item Key="Group"&gt;&lt;/Item&gt;
            &lt;Item Key="Default"&gt;1&lt;/Item&gt;
            &lt;Item Key="CacheTTL"&gt;45&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
            </pre><p>
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dashboard-module-caveats"></a>Ellenjavaslatok és figyelmeztetések</h5></div></div></div><p>
A napok vagy az önálló sorok túlzott száma teljesítmény-csökkenéshez
vezethet.
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dashboard-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
A 2.4.0-ás verziótól.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="notify-module"></a>Értesítési modul</h4></div></div></div><p>
        Az értesítési modulokat egy értesítés megjelenítéséhez használják a fő
navigáció alatt. Megírhatja és regisztrálhatja a saját értesítési
modulját. Jelenleg 5 jegymenü van az OTRS keretrendszerben.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">AgentOnline</code></p></li><li class="listitem"><p><code class="literal">AgentTicketEscalation</code></p></li><li class="listitem"><p><code class="literal">CharsetCheck</code></p></li><li class="listitem"><p><code class="literal">CustomerOnline</code></p></li><li class="listitem"><p><code class="literal">UIDCheck</code></p></li></ul></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-code"></a>Kódpélda</h5></div></div></div><p>
            Az értesítési modulok a
<code class="filename">Kernel/Output/HTML/TicketNotification*.pm</code> alatt
találhatók. Ezt követően egy értesítőmodul példája található. Mentse el a
<code class="filename">Kernel/Output/HTML/TicketNotificationCustom.pm</code>
fájlba. Mindössze két függvényre van szüksége: <code class="code">new()</code> és
<code class="code">Run()</code>.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/NotificationCustom.pm
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Output::HTML::NotificationCustom;

use strict;
use warnings;

use Kernel::System::Custom;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject TimeObject UserID)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }
    $Self-&gt;{CustomObject} = Kernel::System::Custom-&gt;new(%Param);
    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # get session info
    my %CustomParam      = ();
    my @Customs    = $Self-&gt;{CustomObject}-&gt;GetAllCustomIDs();
    my $IdleMinutes = $Param{Config}-&gt;{IdleMinutes} || 60 * 2;
    for (@Customs) {
        my %Data = $Self-&gt;{CustomObject}-&gt;GetCustomIDData( CustomID =&gt; $_, );
        if (
            $Self-&gt;{UserID} ne $Data{UserID}
            &amp;&amp; $Data{UserType} eq 'User'
            &amp;&amp; $Data{UserLastRequest}
            &amp;&amp; $Data{UserLastRequest} + ( $IdleMinutes * 60 ) &gt; $Self-&gt;{TimeObject}-&gt;SystemTime()
            &amp;&amp; $Data{UserFirstname}
            &amp;&amp; $Data{UserLastname}
            )
        {
            $CustomParam{ $Data{UserID} } = "$Data{UserFirstname} $Data{UserLastname}";
            if ( $Param{Config}-&gt;{ShowEmail} ) {
                $CustomParam{ $Data{UserID} } .= " ($Data{UserEmail})";
            }
        }
    }
    for ( sort { $CustomParam{$a} cmp $CustomParam{$b} } keys %CustomParam ) {
        if ( $Param{Message} ) {
            $Param{Message} .= ', ';
        }
        $Param{Message} .= "$CustomParam{$_}";
    }
    if ( $Param{Message} ) {
        return $Self-&gt;{LayoutObject}-&gt;Notify( Info =&gt; 'Custom Message: %s", "' . $Param{Message} );
    }
    else {
        return '';
    }
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni értesítési modul bekapcsolására. Ezt a lenti XML
beállítás használatával lehet megtenni. Lehetnek további paraméterek is a
beállítás kivonatában az értesítési moduljánál.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Frontend::NotifyModule###3-Custom" Required="0" Valid="0"&gt;
    &lt;Description Lang="en"&gt;Module to show custom message in the agent interface.&lt;/Description&gt;
    &lt;Description Lang="hu"&gt;Egy modul egyéni üzenet megjelenítéséhez az ügyintézői felületen.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::ModuleNotify&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::NotificationCustom&lt;/Item&gt;
            &lt;Item Key="Key1"&gt;1&lt;/Item&gt;
            &lt;Item Key="Key2"&gt;2&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-use_cases"></a>Használati eset példa</h5></div></div></div><p>
            Hasznos jegymenü megvalósítás lehet egy hivatkozás egy külső eszközre, ha a
paraméterek (például <code class="literal">FreeTextField</code>) be lettek állítva.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>NotificationAgentOnline</td><td>2.0</td></tr><tr><td>NotificationAgentTicketEscalation</td><td>2.0</td></tr><tr><td>NotificationCharsetCheck</td><td>1.2</td></tr><tr><td>NotificationCustomerOnline</td><td>2.0</td></tr><tr><td>NotificationUIDCheck</td><td>1.2</td></tr></tbody></table></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticket-menu-module"></a>Jegymenü modul</h4></div></div></div><p>
        A jegymenü modulokat egy további hivatkozás megjelenítéséhez használják a
jegy fölött lévő menüben. Megírhatja és regisztrálhatja a saját jegymenü
moduljait. Négy jegymenü létezik (Általános, Zárolás, Felelős és
Jegymegfigyelő), amely az OTRS keretrendszerrel érkezik. További
információkért nézzen bele az OTRS adminisztrációs kézikönyvébe.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-code"></a>Kódpélda</h5></div></div></div><p>
            A jegymenü modulok a <code class="filename">Kernel/Output/HTML/TicketMenu*.pm</code>
fájlokban találhatók. A következőkben egy jegymenü modul példája
található. Mentse el a
<code class="filename">Kernel/Output/HTML/TicketMenuCustom.pm</code>
helyre. Mindössze két függvényre van szüksége: <code class="code">new()</code> és
<code class="code">Run()</code>.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/TicketMenuCustom.pm
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# Id: TicketMenuCustom.pm,v 1.17 2010/04/12 21:34:06 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Output::HTML::TicketMenuCustom;

use strict;
use warnings;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject UserID TicketObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{Ticket} ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; 'Need Ticket!'
        );
        return;
    }

    # check if frontend module registered, if not, do not show action
    if ( $Param{Config}-&gt;{Action} ) {
        my $Module = $Self-&gt;{ConfigObject}-&gt;Get('Frontend::Module')-&gt;{ $Param{Config}-&gt;{Action} };
        return if !$Module;
    }

    # check permission
    my $AccessOk = $Self-&gt;{TicketObject}-&gt;Permission(
        Type     =&gt; 'rw',
        TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
        UserID   =&gt; $Self-&gt;{UserID},
        LogNo    =&gt; 1,
    );
    return if !$AccessOk;

    # check permission
    if ( $Self-&gt;{TicketObject}-&gt;CustomIsTicketCustom( TicketID =&gt; $Param{Ticket}-&gt;{TicketID} ) ) {
        my $AccessOk = $Self-&gt;{TicketObject}-&gt;OwnerCheck(
            TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
            OwnerID  =&gt; $Self-&gt;{UserID},
        );
        return if !$AccessOk;
    }

    # check acl
    return
        if defined $Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} }
            &amp;&amp; !$Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} };

    # if ticket is customized
    if ( $Param{Ticket}-&gt;{Custom} eq 'lock' ) {

        # if it is locked for somebody else
        return if $Param{Ticket}-&gt;{OwnerID} ne $Self-&gt;{UserID};

        # show custom action
        return {
            %{ $Param{Config} },
            %{ $Param{Ticket} },
            %Param,
            Name        =&gt; 'Custom',
            Description =&gt; 'Custom to give it back to the queue!',
            Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
        };
    }

    # if ticket is customized
    return {
        %{ $Param{Config} },
        %{ $Param{Ticket} },
        %Param,
        Name        =&gt; 'Custom',
        Description =&gt; 'Custom it to work on it!',
        Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
    };
}

1;

        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-configuration"></a>Beállítási példa</h5></div></div></div><p>
            Szükség van az egyéni jegymenü modul bekapcsolására. Ezt a lenti XML
beállítás használatával lehet megtenni. Lehetnek további paraméterek is a
beállítás kivonatában a jegymenü moduljánál.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Ticket::Frontend::MenuModule###110-Custom" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to show custom link in menu.&lt;/Description&gt;
    &lt;Description Lang="hu"&gt;Egy modul egyéni hivatkozás megjelenítéséhez a menüben.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Ticket::MenuModule&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::TicketMenuCustom&lt;/Item&gt;
            &lt;Item Key="Name"&gt;Custom&lt;/Item&gt;
            &lt;Item Key="Action"&gt;AgentTicketCustom&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-use_cases"></a>Használati eset példa</h5></div></div></div><p>
            Hasznos jegymenü megvalósítás lehet egy hivatkozás egy külső eszközre, ha a
paraméterek (például <code class="literal">FreeTextField</code>) be lettek állítva.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-caveats"></a>Ellenjavaslatok és figyelmeztetések</h5></div></div></div><p>
                A jegymenü egy olyan URL-re irányít, amely kezelhető. Ha ezt a kérést az
OTRS keretrendszeren keresztül szeretné kezelni, akkor meg kell írnia a
saját előtétprogram modulját.
            </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-releases"></a>Kiadási elérhetőség</h5></div></div></div><p>
        </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Név</th><th>Kiadás</th></tr></thead><tbody><tr><td>TicketMenuGeneric</td><td>2.0</td></tr><tr><td>TicketMenuLock</td><td>2.0</td></tr><tr><td>TicketMenuResponsible</td><td>2.1</td></tr><tr><td>TicketMenuTicketWatcher</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="genericinterface-modules"></a>Általános felület modulok</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="transport"></a>Hálózati átvitel</h4></div></div></div><p>
        A hálózati átvitelt használják az információk küldésének és fogadásának
módszereként az OTRS és egy távoli rendszer között. Az általános felület
beállításai lehetővé teszik egy webszolgáltatásnak, hogy különböző hálózati
átviteli modulokat használjon a szolgáltatónál és a kérelmezőnél, de a
leggyakoribb forgatókönyv az, hogy ugyanazt az átviteli modult használják
mindkettőnél.
    </p><p>
        <span class="emphasis"><em>OTRS mint szolgáltató:</em></span>
    </p><p>
        Az OTRS arra használja a hálózati átviteli modulokat, hogy lekérje az
adatokat a távoli rendszertől, valamint lekérje a végrehajtandó
műveleteket. A művelet végrehajtása után az OTRS ismét azokat használja a
válasz visszaküldéséhez a távoli rendszernek.
    </p><p>
        <span class="emphasis"><em>OTRS mint kérelmező:</em></span>
    </p><p>
        Az OTRS arra használja a hálózati átviteli modulokat, hogy kérelmeket
küldjön a távoli rendszernek egy távoli művelet végrehajtásához a szükséges
adatok mellett. Az OTRS várakozik a távoli rendszer válaszára, és
visszaküldi azt a kérelmező modulnak.
    </p><p>
        Mindkét irányban a hálózati átviteli modulok foglalkoznak a távoli rendszer
formátumában lévő adatokkal. Nem ajánlott semmilyen adatátalakítás
végrehajtása sem ezekben a modulokban, mivel a leképező réteg felelős a
kommunikáció során szükséges bármilyen adatátalakítás végrehajtásáért. Egy
kivétel erre az olyan adatátalakítás, amely kifejezetten az átvitelnél
szükséges, például XML vagy JSON és Perl átalakítások.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_transport"></a>Átviteli háttérprogram</h5></div></div></div><p>
            Ezután be fogjuk mutatni, hogy hogyan kell egy új átviteli háttérprogramot
kifejleszteni. Minden egyes átviteli háttérprogramnak meg kell valósítania
ezeket a szubrutinokat:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">ProviderProcessRequest</code></p></li><li class="listitem"><p><code class="literal">ProviderGenerateResponse</code></p></li><li class="listitem"><p><code class="literal">RequesterPerformRequest</code></p></li></ul></div><p>
        </p><p>
            Meg kell valósítanunk ezen metódusok mindegyikét azért, hogy képesek legyünk
mindkét irányban helyesen kommunikálni egy távoli rendszerrel. Az összes
átviteli háttérprogramot az átviteli modul kezeli
(<code class="filename">Kernel/GenericInterface/Transport.pm</code>).
        </p><p>
            Jelenleg az általános felület megvalósítja a HTTP SOAP és a HTTP REST
átviteleket. Ha a tervezett webszolgáltatás használhat HTTP SOAP vagy HTTP
SOAP átviteleket, akkor nincs szükség egy új hálózati átviteli modul
létrehozására, hanem ahelyett azt ajánljuk, hogy vessen egy pillantást a
HTTP SOAP vagy HTTP REST konfigurációira a beállításaik ellenőrzéséhez,
valamint hogy hogyan hangolhatók a távoli rendszernek megfelelően.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="transport_code_example"></a>Kódpélda</h6></div></div></div><p>
                Abban az esetben, ha a biztosított hálózati átvitelek nem illeszkednek a
webszolgáltatás igényeire, akkor ebben a szakaszban egy minta hálózati
átviteli modul van bemutatva, és minden egyes szubrutin elmagyarázásra
kerül. Normális esetben az átviteli modulok CPAN modulokat használnak
háttérprogramokként. Például a HTTP SOAP átviteli modulok a
<code class="literal">SOAP::Lite</code> modult használják háttérprogramként.
            </p><p>
                Ennél a példánál egy egyéni csomagot használnak az adatok visszaadásához
anélkül, hogy valódi hálózati kérést intéznének egy távoli rendszerhez,
ehelyett ez az egyéni modul működik visszacsatolási felületként.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Transport/HTTP/Test.pm - GenericInterface network transport interface for testing
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Transport::HTTP::Test;

use strict;
use warnings;

use HTTP::Request::Common;
use LWP::UserAgent;
use LWP::Protocol;

# prevent 'Used once' warning for Kernel::OM
use Kernel::System::ObjectManager;

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva. Az átvitelek nem példányosíthatók az objektumkezelővel.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    for my $Needed (qw( DebuggerObject TransportConfig)) {
        $Self-&gt;{$Needed} = $Param{$Needed} || return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Nincs $Needed!"
        };
    }

    return $Self;
}

                </pre><p>
            </p><p>
                A <code class="literal">new</code> konstruktor hozza létre az osztály új példányát. A
kódolási irányelvek szerint az objektumkezelő által nem kezelt más
osztályoknak csak azon objektumait kell a <code class="literal">new</code>
konstruktorban létrehozni, amelyek ebben a modulban szükségesek.
            </p><p>
                </p><pre class="programlisting">
sub ProviderProcessRequest {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "HTTP állapotkód: 500",
            Data         =&gt; {},
        };
    }

    my $ParamObject = $Kernel::OM-&gt;Get('Kernel::System::Web::Request');

    my %Result;
    for my $ParamName ( $ParamObject-&gt;GetParamNames() ) {
        $Result{$ParamName} = $ParamObject-&gt;GetParam( Param =&gt; $ParamName );
    }

    # különleges kezelés az üres POST kérésnél
    if ( scalar keys %Result == 1 &amp;&amp; exists $Result{POSTDATA} &amp;&amp; !$Result{POSTDATA} ) {
        %Result = ();
    }

    if ( !%Result ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Nem található kért adat.',
        );
    }

    return {
        Success   =&gt; 1,
        Data      =&gt; \%Result,
        Operation =&gt; 'test_operation',
    };
}
                </pre><p>
            </p><p>
                A <code class="literal">ProviderProcessRequest</code> függvény megkapja a kérést a
távoli kiszolgálótól (ebben az esetben ugyanaz az OTRS), és kibontja az
adatokat és a műveletet a kérésből a végrehajtáshoz. Ennél a példánál a
művelet mindig a <code class="literal">test_operation</code>.
            </p><p>
                Annak a módja, ahogy ez a függvény feldolgozza a kérést az adatok és a
művelet nevének lekéréséhez, az teljes egészében a megvalósítandó
protokolltól és azon külső moduloktól függ, amelyekhez használják azokat.
            </p><p>
                </p><pre class="programlisting">
sub ProviderGenerateResponse {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; 'A tesztválasz előállítása sikertelen.',
        };
    }

    my $Response;

    if ( !$Param{Success} ) {
        $Response
            = HTTP::Response-&gt;new( 500 =&gt; ( $Param{ErrorMessage} || 'Internal Server Error' ) );
        $Response-&gt;protocol('HTTP/1.0');
        $Response-&gt;content_type("text/plain; charset=UTF-8");
        $Response-&gt;date(time);
    }
    else {

        # egy kérésszöveg előállítása az adatokból
        my $Request
            = HTTP::Request::Common::POST( 'http://testhost.local/', Content =&gt; $Param{Data} );

        $Response = HTTP::Response-&gt;new( 200 =&gt; "OK" );
        $Response-&gt;protocol('HTTP/1.0');
        $Response-&gt;content_type("text/plain; charset=UTF-8");
        $Response-&gt;add_content_utf8( $Request-&gt;content() );
        $Response-&gt;date(time);
    }

    $Self-&gt;{DebuggerObject}-&gt;Debug(
        Summary =&gt; 'HTTP-válasz küldése',
        Data    =&gt; $Response-&gt;as_string(),
    );

    # a válasz elküldése a kliensnek most
    print STDOUT $Response-&gt;as_string();

    return {
        Success =&gt; 1,
    };
}
                </pre><p>
            </p><p>
                Ez a függvény visszaküldi a választ a távoli rendszernek a kért művelethez.
            </p><p>
                Ennél a bizonyos példánál minden esetben egy szabványos sikeres HTTP-választ
adunk vissza (200) vagy nem (500) a szükséges adatok mellett.
            </p><p>
                </p><pre class="programlisting">
sub RequesterPerformRequest {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "HTTP állapotkód: 500",
            Data         =&gt; {},
        };
    }

    # egyéni protokollkezelő használata a valódi hálózati kérések kiküldésének elkerüléséhez
    LWP::Protocol::implementor(
        testhttp =&gt; 'Kernel::GenericInterface::Transport::HTTP::Test::CustomHTTPProtocol'
    );
    my $UserAgent = LWP::UserAgent-&gt;new();
    my $Response = $UserAgent-&gt;post( 'testhttp://localhost.local/', Content =&gt; $Param{Data} );

    return {
        Success =&gt; 1,
        Data    =&gt; {
            ResponseContent =&gt; $Response-&gt;content(),
        },
    };
}
                </pre><p>
            </p><p>
                Ez az egyetlen olyan függvény, amelyet az OTRS mint kérelmező
használ. Elküldi a kérést a távoli rendszernek, és várakozik annak
válaszára.
            </p><p>
                Ennél a példánál egy egyéni protokollkezelőt használunk a valódi hálózatra
történő kérésküldés elkerüléséhez. Ez az egyéni protokoll az alábbiakban van
megadva.
            </p><p>
                </p><pre class="programlisting">
package Kernel::GenericInterface::Transport::HTTP::Test::CustomHTTPProtocol;

use base qw(LWP::Protocol);

sub new {
    my $Class = shift;

    return $Class-&gt;SUPER::new(@_);
}

sub request {    ## nem kritikus
    my $Self = shift;

    my ( $Request, $Proxy, $Arg, $Size, $Timeout ) = @_;

    my $Response = HTTP::Response-&gt;new( 200 =&gt; "OK" );
    $Response-&gt;protocol('HTTP/1.0');
    $Response-&gt;content_type("text/plain; charset=UTF-8");
    $Response-&gt;add_content_utf8( $Request-&gt;content() );
    $Response-&gt;date(time);

    #print $Request-&gt;as_string();
    #print $Response-&gt;as_string();

    return $Response;
}

                </pre><p>
            </p><p>
                Ez a kód ahhoz az egyéni protokollhoz van, amelyet használunk. Ez a
megközelítés csak gyakorlásnál vagy olyan tesztelési környezeteknél hasznos,
ahol a távoli rendszerek nem érhetők el.
            </p><p>
                Egy új modul kifejlesztéséhez nem ajánljuk ezen megközelítés használatát,
egy valódi protokollt kell megvalósítani.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="transport-configuration"></a>Beállítási példa</h6></div></div></div><p>
                Szükség van ezen hálózati átviteli modul regisztrálására, hogy elérhető
legyen az OTRS grafikus felhasználói felületén. Ezt a lenti XML beállítás
használatával lehet megtenni.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Transport::Module###HTTP::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the transport layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Transport::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Protocol"&gt;HTTP&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceTransportHTTPTest&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mapping"></a>Leképezés</h4></div></div></div><p>
        A leképezést adatok átalakításához használják az OTRS és a távoli rendszer
között, illetve fordítva. Ezek az adatok kulcs =&gt; érték párokként vannak
ábrázolva. Leképező modulok fejleszthetők ki nem csak az értékek, hanem a
kulcsok átalakításához is.
    </p><p>
        <span class="emphasis"><em>Például:</em></span>
    </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Erről</th><th>Erre</th></tr></thead><tbody><tr><td>Prio =&gt; Warning</td><td>PriorityID =&gt; 3</td></tr></tbody></table></div><p>
        A leképező réteg nem feltétlenül szükséges, egy webszolgáltatás teljesen
kihagyhatja azt a webszolgáltatás beállításaitól, valamint a meghívók és
műveletek megvalósításának módjától függően. De ha egy kis átalakítás
szükséges, akkor erősen ajánlott egy meglévő leképezőmodul használata, vagy
egy új létrehozása.
    </p><p>
        A leképező modulok egynél több alkalommal is meghívhatók egy normál
kommunikáció közben. Vessen egy pillantást a következő példákra.
    </p><p>
        <span class="emphasis"><em>OTRS mint szolgáltató példa:</em></span>
    </p><p>
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    A távoli rendszer elküldi a kérést az adatokkal a távoli rendszer
formátumában
                </p></li><li class="listitem"><p>
                    Az adatok leképezésre kerülnek a távoli rendszer formátumáról az OTRS
formátumára
                </p></li><li class="listitem"><p>
                    Az OTRS végrehajtja a műveletet, és visszaadja a választ az OTRS
formátumában
                </p></li><li class="listitem"><p>
                    Az adatok leképezésre kerülnek az OTRS formátumáról a távoli rendszer
formátumára
                </p></li><li class="listitem"><p>
                    A válasz a távoli rendszer formátumában lévő adatokkal elküldésre kerül a
távoli rendszernek
                </p></li></ol></div><p>
    </p><p>
        <span class="emphasis"><em>OTRS mint kérelmező példa:</em></span>
    </p><p>
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Az OTRS előkészíti a kérést a távoli rendszerhez az OTRS formátumában lévő
adatokkal
                </p></li><li class="listitem"><p>
                    Az adatok leképezésre kerülnek az OTRS formátumáról a távoli rendszer
formátumára
                </p></li><li class="listitem"><p>
                    A kérés elküldésre kerül a távoli rendszernek, amely végrehajtja a
műveletet, és visszaküldi a választ az OTRS-nek a távoli rendszer
formátumában lévő adatokkal
                </p></li><li class="listitem"><p>
                    Az adatok (ismét) leképezésre kerülnek a távoli rendszer formátumáról az
OTRS formátumára
                </p></li><li class="listitem"><p>
                    Az OTRS feldolgozza a választ
                </p></li></ol></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_mapping"></a>Leképező háttérprogram</h5></div></div></div><p>
            Az általános felület biztosít egy <span class="emphasis"><em>Simple</em></span> nevű
leképezőmodult. Ezzel a modullal a legtöbb adatátalakítás (beleértve a kulcs
és érték leképezést) elvégezhető, és szabályokat is meghatároz az
alapértelmezett leképezések kezeléséhez mind a kulcsoknál, mind az
értékeknél.
        </p><p>
            Ezért erősen valószínű, hogy nem lesz szüksége egy egyéni leképezőmodul
kifejlesztésére. A folytatás előtt nézze meg a <span class="emphasis"><em>Simple</em></span>
leképezőmodult
(<code class="filename">Kernel/GenericInterface/Mapping/Simple.pm</code>) és annak
internetes dokumentációját.
        </p><p>
            Ha a <span class="emphasis"><em>Simple</em></span> leképezőmodul nem felel meg az igényeinek,
akkor meg fogjuk mutatni, hogy hogyan lehet kifejleszteni egy új leképező
háttérprogramot. Minden egyes leképező háttérprogramnak meg kell valósítania
ezeket a szubrutinokat:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">Map</code></p></li></ul></div><p>
        </p><p>
            Meg kell valósítanunk ezen metódusok mindegyikét azért, hogy képesek legyünk
az adatok leképezésére a kommunikációban, amelyet vagy a kérelmező, vagy a
szolgáltató kezel. Az összes leképező háttérprogramot a leképezőmodul kezeli
(<code class="filename">Kernel/GenericInterface/Mapping.pm</code>).
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="mapping_code_example"></a>Kódpélda</h6></div></div></div><p>
                Ebben a szakaszban egy minta leképezőmodul lesz megjelenítve, és minden
szubrutin elmagyarázásra kerül.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Mapping/Test.pm - GenericInterface test data mapping backend
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Mapping::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsHashRefWithData IsStringWithData);

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva.
            </p><p>
                Felveszünk egy <code class="literal">VariableCheck</code> modult is bizonyos
ellenőrzések végrehajtásához néhány változón. A leképezések nem
példányosíthatók az objektumkezelővel.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # új kivonat lefoglalása az objektumhoz
    my $Self = {};
    bless( $Self, $Type );

    # a szükséges paraméterek ellenőrzése
    for my $Needed (qw(DebuggerObject MappingConfig)) {
        if ( !$Param{$Needed} ) {

            return {
                Success      =&gt; 0,
                ErrorMessage =&gt; "Nincs $Needed!"
            };
        }
        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    # leképezési beállítás ellenőrzése
    if ( !IsHashRefWithData( $Param{MappingConfig} ) ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Nincs MappingConfig objektum kivonathivatkozásként tartalommal!',
        );
    }

    # beállítás ellenőrzése - ha van leképezési beállításunk, akkor annak
    # nem üres kivonathivatkozásnak kell lennie
    if (
        defined $Param{MappingConfig}-&gt;{Config}
        &amp;&amp; !IsHashRefWithData( $Param{MappingConfig}-&gt;{Config} )
        )
    {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Van MappingConfig adatokkal, de az adat nem kivonathivatkozás tartalommal!',
        );
    }

    return $Self;
}
                </pre><p>
            </p><p>
                A <code class="literal">new</code> konstruktor hozza létre az osztály új példányát. A
kódolási irányelvek szerint az objektumkezelő által nem kezelt más
osztályoknak csak azon objektumait kell a <code class="literal">new</code>
konstruktorban létrehozni, amelyek ebben a modulban szükségesek.
            </p><p>
                </p><pre class="programlisting">
sub Map {
    my ( $Self, %Param ) = @_;

    # adatok ellenőrzése - csak meghatározatlant vagy kivonathivatkozást fogad el
    if ( defined $Param{Data} &amp;&amp; ref $Param{Data} ne 'HASH' ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Van adat, de az nem kivonathivatkozás a leképezésteszt háttérprogramban!'
        );
    }

    # visszatérés, ha az adat üres
    if ( !defined $Param{Data} || !%{ $Param{Data} } ) {

        return {
            Success =&gt; 1,
            Data    =&gt; {},
        };
    }

    # ha nincs beállítás, akkor az azt jelenti, hogy egyszerűen visszaadjuk a bemeneti adatot
    if (
        !defined $Self-&gt;{MappingConfig}-&gt;{Config}
        || !defined $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption}
        )
    {

        return {
            Success =&gt; 1,
            Data    =&gt; $Param{Data},
        };
    }

    # a TestOption formátum ellenőrzése
    if ( !IsStringWithData( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} ) ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Nincs TestOption szövegként értékkel!',
        );
    }

    # adatok feldolgozása a beállítások szerint
    my $ReturnData = {};
    if ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'ToUpper' ) {
        $ReturnData = $Self-&gt;_ToUpper( Data =&gt; $Param{Data} );
    }
    elsif ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'ToLower' ) {
        $ReturnData = $Self-&gt;_ToLower( Data =&gt; $Param{Data} );
    }
    elsif ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'Empty' ) {
        $ReturnData = $Self-&gt;_Empty( Data =&gt; $Param{Data} );
    }
    else {
        $ReturnData = $Param{Data};
    }

    # az eredmény visszaadása
    return {
        Success =&gt; 1,
        Data    =&gt; $ReturnData,
    };
}
                </pre><p>
            </p><p>
                A <code class="literal">Map</code> függvény az egyes leképezőmodulok fő része. Fogadja
a leképezési beállításokat (szabályokat) és az eredeti formátumban lévő
adatokat (vagy az OTRS vagy a távoli rendszer formátumában lévőket), és
átalakítja azokat egy új formátumra még akkor is, ha az adatok szerkezete
megváltozhat a leképezési folyamat során.
            </p><p>
                Ebben a bizonyos példában három szabály van az értékek leképezéséhez. Ezek a
szabályok a leképezési beállítások <code class="literal">TestOption</code> kulcsában
vannak beállítva, és a következők: <code class="literal">ToUpper</code>,
<code class="literal">ToLower</code> és <code class="literal">Empty</code>.
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                        <code class="literal">ToUpper</code>: nagybetűsre alakít át minden egyes adatértéket.
                    </p></li><li class="listitem"><p>
                        <code class="literal">ToLower</code>: kisbetűsre alakít át minden egyes adatértéket.
                    </p></li><li class="listitem"><p>
                        <code class="literal">Empty</code>: egy üres szövegre alakít át minden egyes
adatértéket.
                    </p></li></ul></div><p>
                Ebben a példában nem lettek adatkulcs átalakítások megvalósítva.
            </p><p>
                </p><pre class="programlisting">
sub _ToUpper {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( sort keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = uc $Param{Data}-&gt;{$Key};
    }

    return $ReturnData;
}

sub _ToLower {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( sort keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = lc $Param{Data}-&gt;{$Key};
    }

    return $ReturnData;
}

sub _Empty {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( sort keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = '';
    }

    return $ReturnData;
}

                </pre><p>
            </p><p>
                Ezek azok a segédfüggvények, amelyek ténylegesen végrehajtják a
szövegátalakításokat.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="mapping-configuration"></a>Beállítási példa</h6></div></div></div><p>
                Szükség van ezen leképezőmodul regisztrálására, hogy elérhető legyen az OTRS
grafikus felhasználói felületén. Ezt a lenti XML beállítás használatával
lehet megtenni.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Mapping::Module###Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the mapping layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Mapping::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="ConfigDialog"&gt;&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="invoker"></a>Meghívó</h4></div></div></div><p>
        A meghívót arra használják, hogy egy kérést hozzon létre az OTRS-ből egy
távoli rendszerhez. Az általános ügyintéző ezen része felelős a szükséges
feladatok végrehajtásáért az OTRS oldalán, illetve a szükséges adatok
begyűjtéséért a kérés felépítésének érdekében.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_invoker"></a>Meghívó háttérprogram</h5></div></div></div><p>
            Ezután be fogjuk mutatni, hogy hogyan kell egy új meghívót
kifejleszteni. Minden egyes meghívónak meg kell valósítania ezeket a
szubrutinokat:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">PrepareRequest</code></p></li><li class="listitem"><p><code class="literal">HandleResponse</code></p></li></ul></div><p>
        </p><p>
            Meg kell valósítanunk ezen metódusok mindegyikét azért, hogy képesek legyünk
végrehajtani egy kérést a kéréskezelő használatával
(<code class="filename">Kernel/GenericInterface/Requester.pm</code>).
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="invoker_code_example"></a>Kódpélda</h6></div></div></div><p>
                Ebben a szakaszban egy minta meghívómodul lesz megjelenítve, és minden
szubrutin elmagyarázásra kerül.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Invoker/Test.pm - GenericInterface test data Invoker backend
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Invoker::Test::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsString IsStringWithData);

# prevent 'Used once' warning for Kernel::OM
use Kernel::System::ObjectManager;

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva. A meghívók nem példányosíthatók az objektumkezelővel.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # új kivonat lefoglalása az objektumhoz
    my $Self = {};
    bless( $Self, $Type );

    # a szükséges paraméterek ellenőrzése
    if ( !$Param{DebuggerObject} ) {
        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Nem sikerült lekérni a hibakezelő objektumot!"
        };
    }

    $Self-&gt;{DebuggerObject} = $Param{DebuggerObject};

    return $Self;
}
                </pre><p>
            </p><p>
                A <code class="literal">new</code> konstruktor hozza létre az osztály új példányát. A
kódolási irányelvek szerint az objektumkezelő által nem kezelt más
osztályoknak csak azon objektumait kell a <code class="literal">new</code>
konstruktorban létrehozni, amelyek ebben a modulban szükségesek.
            </p><p>
                </p><pre class="programlisting">
sub PrepareRequest {
    my ( $Self, %Param ) = @_;

    # szükségünk van egy jegyszámra
    if ( !IsStringWithData( $Param{Data}-&gt;{TicketNumber} ) ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error( Summary =&gt; 'Nem kaptunk jegyszámot' );
    }

    my %ReturnData;

    $ReturnData{TicketNumber} = $Param{Data}-&gt;{TicketNumber};

    # a művelet ellenőrzése
    if ( IsStringWithData( $Param{Data}-&gt;{Action} ) ) {
        $ReturnData{Action} = $Param{Data}-&gt;{Action} . 'Test';
    }

    # a rendszeridő kérésének ellenőrzése
    if ( IsStringWithData( $Param{Data}-&gt;{GetSystemTime} ) &amp;&amp; $Param{Data}-&gt;{GetSystemTime} ) {
        $ReturnData{SystemTime} = $Kernel::OM-&gt;Get('Kernel::System::Time')-&gt;SystemTime();
    }

    return {
        Success =&gt; 1,
        Data    =&gt; \%ReturnData,
    };
}
                </pre><p>
            </p><p>
                A <code class="literal">PrepareRequest</code> függvényt használják a kérésbe küldendő
összes szükséges adat kezeléséhez és összegyűjtéséhez. Itt fogadhatunk
adatokat a kéréskezelőtől, használhatjuk azokat, kiterjeszthetjük azokat, új
adatokat állíthatunk elő, és ezután átvihetjük az eredményeket a leképező
réteghez.
            </p><p>
                Ennél a példánál azt várjuk, hogy kapunk egy jegyszámot. Ha nem, akkor az
<code class="code">Error()</code> hibakeresési metódust használjuk, amely létrehoz egy
bejegyzést a hibakeresési naplóban, és visszaad egy szerkezetet is a
<code class="literal">Success</code> paraméterrel 0-ként, és egy hibaüzenetet az
átadott <code class="literal">Summary</code> értékként.
            </p><p>
                Ez a példa hozzáfűzi a „Test” szót is az <code class="literal">Action</code>
paraméterhez, és ha a <code class="literal">GetSystemTime</code> kérve volt, akkor ki
fogja tölteni a <code class="literal">SystemTime</code> paramétert az aktuális
rendszeridővel. A kód ezen része azért van, hogy előkészítse az elküldendő
adatokat. Egy valódi meghívónál itt kell elvégezni néhány hívást az
alapmodulokhoz (<code class="filename">Kernel/System/*.pm</code>).
            </p><p>
                Ha a kérést a <code class="literal">PrepareRequest</code> függvény bármely része
közben le kell állítani a hibakeresési naplóba való bejegyzés előállítása és
hibajelzése nélkül, akkor a következő kód használható:
            </p><p>
                </p><pre class="programlisting">
# a kérelmező kommunikációjának leállítása
return {
    Success           =&gt; 1,
    StopCommunication =&gt; 1,
};
                </pre><p>
            </p><p>
                Ennek használatával a kérelmező meg foga érteni, hogy a kérést nem szabad
folytatni (nem kerül elküldésre a leképező réteghez, és nem kerül elküldésre
a hálózati átvitelhez sem). A kérelmező nem fog hibát küldeni a hibakeresési
naplóba, hanem csak csendben le fog állni.
            </p><p>
                </p><pre class="programlisting">
sub HandleResponse {
    my ( $Self, %Param ) = @_;

    # ha hiba volt a válaszban, akkor továbbítja
    if ( !$Param{ResponseSuccess} ) {
        if ( !IsStringWithData( $Param{ResponseErrorMessage} ) ) {

            return $Self-&gt;{DebuggerObject}-&gt;Error(
                Summary =&gt; 'Hiba volt a válaszban, de nincs válasz hibaüzenet!',
            );
        }

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; $Param{ResponseErrorMessage},
        };
    }

    # szükségünk van egy jegyszámra
    if ( !IsStringWithData( $Param{Data}-&gt;{TicketNumber} ) ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error( Summary =&gt; 'Nem kaptunk jegyszámot!' );
    }

    # a jegyszám előkészítése
    my %ReturnData = (
        TicketNumber =&gt; $Param{Data}-&gt;{TicketNumber},
    );

    # a művelet ellenőrzése
    if ( IsStringWithData( $Param{Data}-&gt;{Action} ) ) {
        if ( $Param{Data}-&gt;{Action} !~ m{ \A ( .*? ) Test \z }xms ) {

            return $Self-&gt;{DebuggerObject}-&gt;Error(
                Summary =&gt; 'Kaptunk műveletet, nem az nem megfelelő formátumú!',
            );
        }
        $ReturnData{Action} = $1;
    }

    return {
        Success =&gt; 1,
        Data    =&gt; \%ReturnData,
    };
}
                </pre><p>
            </p><p>
                A <code class="literal">HandleResponse</code> függvényt használják az előző kérésből
származó adatok fogadásához és feldolgozásához, amelyet a távoli rendszernek
készítettek. Ezeket az adatokat már átadta a leképező réteg, hogy átalakítsa
azokat a távoli rendszer formátumáról az OTRS formátumára (ha szükséges).
            </p><p>
                Ennél a bizonyos példánál ismét ellenőrzi a jegyszámot, és azt is ellenőrzi,
hogy a művelet a „Test” szóval végződik-e (amint az a
<code class="literal">PrepareRequest</code> függvényben történt).
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                    Ez a meghívó csak tesztelésekhez van, egy valódi meghívó ellenőrizni fogja,
hogy a válasz a távoli rendszer által leírt formátumban volt-e, és
végrehajthat néhány műveletet, mint például: egy másik meghívó meghívása,
egy hívás végrehajtása egy alapmodulhoz, az adatbázis frissítése, hiba
küldése, stb.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="invoker-configuration"></a>Beállítási példa</h6></div></div></div><p>
                Szükség van ezen meghívómodul regisztrálására, hogy elérhető legyen az OTRS
grafikus felhasználói felületén. Ezt a lenti XML beállítás használatával
lehet megtenni.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Invoker::Module###Test::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the invoker layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Invoker::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Controller"&gt;Test&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceInvokerDefault&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="operation"></a>Művelet</h4></div></div></div><p>
        A műveletet egy tevékenység végrehajtásához használják az OTRS-en belül. Ezt
a tevékenységet a távoli rendszer kéri, és tartalmazhat különleges
paramétereket azért, hogy helyesen végrehajtsa a tevékenységet. A
tevékenység végrehajtása után az OTRS elküld egy meghatározott megerősítést
a távoli rendszernek.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="adding_operation"></a>Műveleti háttérprogram</h5></div></div></div><p>
            Ezután be fogjuk mutatni, hogy hogyan kell egy új műveletet
kifejleszteni. Minden egyes műveletnek meg kell valósítania ezeket a
szubrutinokat:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p><code class="literal">new</code></p></li><li class="listitem"><p><code class="literal">Run</code></p></li></ul></div><p>
        </p><p>
            Meg kell valósítanunk ezen metódusok mindegyikét azért, hogy képesek legyünk
végrehajtani a szolgáltató által kezelt műveletet
(<code class="filename">Kernel/GenericInterface/Provider.pm</code>).
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation_code_example"></a>Kódpélda</h6></div></div></div><p>
                Ebben a szakaszban egy minta műveletmodul lesz megjelenítve, és minden
szubrutin elmagyarázásra kerül.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Operation/Test/Test.pm - GenericInterface test operation backend
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::GenericInterface::Operation::Test::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsHashRefWithData);

our $ObjectManagerDisabled = 1;
                </pre><p>
            </p><p>
                Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva.
            </p><p>
                Felveszünk egy <code class="literal">VariableCheck</code> modult is bizonyos
ellenőrzések végrehajtásához néhány változón. A műveletek nem
példányosíthatók az objektumkezelővel.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    # a szükséges objektumok ellenőrzése
    for my $Needed (qw(DebuggerObject)) {
        if ( !$Param{$Needed} ) {
            return {
                Success      =&gt; 0,
                ErrorMessage =&gt; "Nincs $Needed!"
            };
        }

        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    return $Self;
}
                </pre><p>
            </p><p>
                A <code class="literal">new</code> konstruktor hozza létre az osztály új példányát. A
kódolási irányelvek szerint az objektumkezelő által nem kezelt más
osztályoknak csak azon objektumait kell a <code class="literal">new</code>
konstruktorban létrehozni, amelyek ebben a modulban szükségesek.
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # adatok ellenőrzése - csak meghatározatlant vagy kivonathivatkozást fogad el
    if ( defined $Param{Data} &amp;&amp; ref $Param{Data} ne 'HASH' ) {

        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Van adat, de az nem kivonathivatkozás a műveletteszt háttérprogramban!'
        );
    }

    if ( defined $Param{Data} &amp;&amp; $Param{Data}-&gt;{TestError} ) {

        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Hibaüzenet a következő hibakódhoz: $Param{Data}-&gt;{TestError}",
            Data         =&gt; {
                ErrorData =&gt; $Param{Data}-&gt;{ErrorData},
            },
        };
    }

    # adatok másolása
    my $ReturnData;

    if ( ref $Param{Data} eq 'HASH' ) {
        $ReturnData = \%{ $Param{Data} };
    }
    else {
        $ReturnData = undef;
    }

    # az eredmény visszaadása
    return {
        Success =&gt; 1,
        Data    =&gt; $ReturnData,
    };
}
                </pre><p>
            </p><p>
                A <code class="literal">Run</code> függvény az egyes műveletek fő része. Fogadja az
összes belsőleg leképezett adatot a távoli rendszertől, amelyre a
szolgáltatónak szüksége van a művelet végrehajtásához, végrehajtja a
műveletet, és visszaadja az eredményt a szolgáltatónak a külső leképezéshez,
valamint visszaszállítja a távoli rendszerhez.
            </p><p>
                Ez a bizonyos példa ugyanúgy adja vissza az adatokat, ahogy azok a távoli
rendszertől jönnek, hacsak a <code class="literal">TestError</code> paraméter át nincs
adva. Ebben az esetben egy hibát ad vissza.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-configuration"></a>Beállítási példa</h6></div></div></div><p>
                Szükség van ezen műveletmodul regisztrálására, hogy elérhető legyen az OTRS
grafikus felhasználói felületén. Ezt a lenti XML beállítás használatával
lehet megtenni.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Operation::Module###Test::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the operation layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Operation::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Controller"&gt;Test&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceOperationDefault&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-unittest"></a>Egységteszt példa</h6></div></div></div><p>
                Az általános felület műveleteinek egységtesztjei nem különböznek más
egységtesztektől, de fontolóra kell venni a helyi tesztelést, viszont egy
távoli kapcsolatot is szimulálni kell. Egy jó bevált gyakorlat mindkettőt
különválasztva tesztelni, mivel az eredmények némileg különbözők lehetnek.
            </p><p>
                Ha többet szeretne megtudni az egységtesztekről, akkor vessen egy pillantást
az <a class="link" href="unit-tests.html" title="Egységtesztek">egységteszt fejezetre</a>.
            </p><p>
                A következő csak a kezdési pont egy egységteszthez:
            </p><p>
                </p><pre class="programlisting">
# --
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

## no critic (Modules::RequireExplicitPackage)
use strict;
use warnings;
use utf8;

use vars (qw($Self));

use Kernel::GenericInterface::Debugger;
use Kernel::GenericInterface::Operation::Test::Test;

use Kernel::System::VariableCheck qw(:all);

# Skip SSL certificate verification (RestoreDatabase must not be used in this test).
$Kernel::OM-&gt;ObjectParamAdd(
    'Kernel::System::UnitTest::Helper' =&gt; {
        SkipSSLVerify =&gt; 1,
    },
);
my $Helper = $Kernel::OM-&gt;Get('Kernel::System::UnitTest::Helper');

# get a random number
my $RandomID = $Helper-&gt;GetRandomNumber();

# create a new user for current test
my $UserLogin = $Helper-&gt;TestUserCreate(
    Groups =&gt; ['users'],
);
my $Password = $UserLogin;

my $UserID = $Kernel::OM-&gt;Get('Kernel::System::User')-&gt;UserLookup(
    UserLogin =&gt; $UserLogin,
);

# set web-service name
my $WebserviceName = '-Test-' . $RandomID;

# create web-service object
my $WebserviceObject = $Kernel::OM-&gt;Get('Kernel::System::GenericInterface::Webservice');
$Self-&gt;Is(
    'Kernel::System::GenericInterface::Webservice',
    ref $WebserviceObject,
    "Create web service object",
);

my $WebserviceID = $WebserviceObject-&gt;WebserviceAdd(
    Name   =&gt; $WebserviceName,
    Config =&gt; {
        Debugger =&gt; {
            DebugThreshold =&gt; 'debug',
        },
        Provider =&gt; {
            Transport =&gt; {
                Type =&gt; '',
            },
        },
    },
    ValidID =&gt; 1,
    UserID  =&gt; 1,
);
$Self-&gt;True(
    $WebserviceID,
    "Added Web Service",
);

# get remote host with some precautions for certain unit test systems
my $Host = $Helper-&gt;GetTestHTTPHostname();

my $ConfigObject = $Kernel::OM-&gt;Get('Kernel::Config');

# prepare web-service config
my $RemoteSystem =
    $ConfigObject-&gt;Get('HttpType')
    . '://'
    . $Host
    . '/'
    . $ConfigObject-&gt;Get('ScriptAlias')
    . '/nph-genericinterface.pl/WebserviceID/'
    . $WebserviceID;

my $WebserviceConfig = {
    Description =&gt;
        'Test for Ticket Connector using SOAP transport backend.',
    Debugger =&gt; {
        DebugThreshold =&gt; 'debug',
        TestMode       =&gt; 1,
    },
    Provider =&gt; {
        Transport =&gt; {
            Type   =&gt; 'HTTP::SOAP',
            Config =&gt; {
                MaxLength =&gt; 10000000,
                NameSpace =&gt; 'http://otrs.org/SoapTestInterface/',
                Endpoint  =&gt; $RemoteSystem,
            },
        },
        Operation =&gt; {
            Test =&gt; {
                Type =&gt; 'Test::Test',
            },
        },
    },
    Requester =&gt; {
        Transport =&gt; {
            Type   =&gt; 'HTTP::SOAP',
            Config =&gt; {
                NameSpace =&gt; 'http://otrs.org/SoapTestInterface/',
                Encoding  =&gt; 'UTF-8',
                Endpoint  =&gt; $RemoteSystem,
            },
        },
        Invoker =&gt; {
            Test =&gt; {
                Type =&gt; 'Test::TestSimple'
                ,    # requester needs to be Test::TestSimple in order to simulate a request to a remote system
            },
        },
    },
};

# update web-service with real config
# the update is needed because we are using
# the WebserviceID for the Endpoint in config
my $WebserviceUpdate = $WebserviceObject-&gt;WebserviceUpdate(
    ID      =&gt; $WebserviceID,
    Name    =&gt; $WebserviceName,
    Config  =&gt; $WebserviceConfig,
    ValidID =&gt; 1,
    UserID  =&gt; $UserID,
);
$Self-&gt;True(
    $WebserviceUpdate,
    "Updated Web Service $WebserviceID - $WebserviceName",
);

# debugger object
my $DebuggerObject = Kernel::GenericInterface::Debugger-&gt;new(
    DebuggerConfig =&gt; {
        DebugThreshold =&gt; 'debug',
        TestMode       =&gt; 1,
    },
    WebserviceID      =&gt; $WebserviceID,
    CommunicationType =&gt; 'Provider',
);
$Self-&gt;Is(
    ref $DebuggerObject,
    'Kernel::GenericInterface::Debugger',
    'DebuggerObject instantiate correctly',
);

# define test cases
my @Tests = (
    {
        Name           =&gt; 'Test case name',
        SuccessRequest =&gt; 1,                  # 1 or 0
        RequestData    =&gt; {

            # ... add test data
        },
        ExpectedReturnLocalData =&gt; {
            Data =&gt; {

                # ... add expected local results
            },
            Success =&gt; 1,                     # 1 or 0
        },
        ExpectedReturnRemoteData =&gt; {
            Data =&gt; {

                # ... add expected remote results
            },
            Success =&gt; 1,                     # 1 or 0
        },
        Operation =&gt; 'Test',
    },

    # ... add more test cases
);

TEST:
for my $Test (@Tests) {

    # create local object
    my $LocalObject = "Kernel::GenericInterface::Operation::Test::$Test-&gt;{Operation}"-&gt;new(
        DebuggerObject =&gt; $DebuggerObject,
        WebserviceID   =&gt; $WebserviceID,
    );

    $Self-&gt;Is(
        "Kernel::GenericInterface::Operation::Test::$Test-&gt;{Operation}",
        ref $LocalObject,
        "$Test-&gt;{Name} - Create local object",
    );

    my %Auth = (
        UserLogin =&gt; $UserLogin,
        Password  =&gt; $Password,
    );
    if ( IsHashRefWithData( $Test-&gt;{Auth} ) ) {
        %Auth = %{ $Test-&gt;{Auth} };
    }

    # start requester with our web-service
    my $LocalResult = $LocalObject-&gt;Run(
        WebserviceID =&gt; $WebserviceID,
        Invoker      =&gt; $Test-&gt;{Operation},
        Data         =&gt; {
            %Auth,
            %{ $Test-&gt;{RequestData} },
        },
    );

    # check result
    $Self-&gt;Is(
        'HASH',
        ref $LocalResult,
        "$Test-&gt;{Name} - Local result structure is valid",
    );

    # create requester object
    my $RequesterObject = $Kernel::OM-&gt;Get('Kernel::GenericInterface::Requester');
    $Self-&gt;Is(
        'Kernel::GenericInterface::Requester',
        ref $RequesterObject,
        "$Test-&gt;{Name} - Create requester object",
    );

    # start requester with our web-service
    my $RequesterResult = $RequesterObject-&gt;Run(
        WebserviceID =&gt; $WebserviceID,
        Invoker      =&gt; $Test-&gt;{Operation},
        Data         =&gt; {
            %Auth,
            %{ $Test-&gt;{RequestData} },
        },
    );

    # check result
    $Self-&gt;Is(
        'HASH',
        ref $RequesterResult,
        "$Test-&gt;{Name} - Requester result structure is valid",
    );

    $Self-&gt;Is(
        $RequesterResult-&gt;{Success},
        $Test-&gt;{SuccessRequest},
        "$Test-&gt;{Name} - Requester successful result",
    );

    # ... add tests for the results
}

# delete web service
my $WebserviceDelete = $WebserviceObject-&gt;WebserviceDelete(
    ID     =&gt; $WebserviceID,
    UserID =&gt; $UserID,
);
$Self-&gt;True(
    $WebserviceDelete,
    "Deleted Web Service $WebserviceID",
);

# also delete any other added data during the this test, since RestoreDatabase must not be used.

1;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-wsdl"></a>WSDL-kiterjesztés példa</h6></div></div></div><p>
                A WSDL-fájlok tartalmazzák a webszolgáltatás és a SOAP-üzenethez tartozó
műveleteinek meghatározásait abban az esetben, a kibővítjük a
<code class="filename">development/webservices/GenericTickeConnectorSOAP.wsdl</code>
fájlt néhány helyen:
            </p><p>
                Port típusa:
            </p><p>
                </p><pre class="programlisting">
    &lt;wsdl:portType name="GenericTicketConnector_PortType"&gt;
        &lt;!-- ... --&gt;
        &lt;wsdl:operation name="Test"&gt;
            &lt;wsdl:input message="tns:TestRequest"/&gt;
            &lt;wsdl:output message="tns:TestResponse"/&gt;
        &lt;/wsdl:operation&gt;
    &lt;!-- ... --&gt;
                </pre><p>
            </p><p>
                Kötés:
            </p><p>
                </p><pre class="programlisting">
    &lt;wsdl:binding name="GenericTicketConnector_Binding" type="tns:GenericTicketConnector_PortType"&gt;
        &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
        &lt;!-- ... --&gt;
        &lt;wsdl:operation name="Test"&gt;
            &lt;soap:operation soapAction="http://www.otrs.org/TicketConnector/Test"/&gt;
            &lt;wsdl:input&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
        &lt;!-- ... --&gt;
    &lt;/wsdl:binding&gt;
                </pre><p>
            </p><p>
                Típus:
            </p><p>
                </p><pre class="programlisting">
    &lt;wsdl:types&gt;
        &lt;xsd:schema targetNamespace="http://www.otrs.org/TicketConnector/" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
        &lt;!-- ... --&gt;
            &lt;xsd:element name="Test"&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                            &lt;xsd:element minOccurs="0" name="Param1" type="xsd:string"/&gt;
                            &lt;xsd:element minOccurs="0" name="Param2" type="xsd:positiveInteger"/&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
            &lt;xsd:element name="TestResponse"&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                        &lt;xsd:element maxOccurs="unbounded" minOccurs="1" name="Attribute1" type="xsd:string"/&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
        &lt;!-- ... --&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;
                </pre><p>
            </p><p>
                Üzenet:
            </p><p>
                </p><pre class="programlisting">
    &lt;!-- ... --&gt;
    &lt;wsdl:message name="TestRequest"&gt;
        &lt;wsdl:part element="tns:Test" name="parameters"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="TestResponse"&gt;
        &lt;wsdl:part element="tns:TestResponse" name="parameters"/&gt;
    &lt;/wsdl:message&gt;
    &lt;!-- ... --&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-wadl"></a>WADL-kiterjesztés példa</h6></div></div></div><p>
                A WADL-fájlok tartalmazzák a webszolgáltatás és a REST-felülethez tartozó
műveleteinek meghatározásait. Adjon hozzá egy új erőforrást a
<code class="filename">development/webservices/GenericTickeConnectorREST.wadl</code>fájlhoz.
            </p><p>
                </p><pre class="programlisting">
  &lt;resources base="http://localhost/otrs/nph-genericinterface.pl/Webservice/GenericTicketConnectorREST"&gt;
    &lt;!-- ... --&gt;
    &lt;resource path="Test" id="Test"&gt;
      &lt;doc xml:lang="en" title="Test"/&gt;
        &lt;param name="Param1" type="xs:string" required="false" default="" style="query" xmlns:xs="http://www.w3.org/2001/XMLSchema"/&gt;
        &lt;param name="Param2" type="xs:string" required="false" default="" style="query" xmlns:xs="http://www.w3.org/2001/XMLSchema"/&gt;
        &lt;method name="GET" id="GET_Test"&gt;
          &lt;doc xml:lang="en" title="GET_Test"/&gt;
          &lt;request/&gt;
          &lt;response status="200"&gt;
            &lt;representation mediaType="application/json; charset=UTF-8"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/resource&gt;
    &lt;/resource&gt;
    &lt;!-- ... --&gt;
  &lt;/resources&gt;
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-soap"></a>Webszolgáltatás SOAP-kiterjesztés példa</h6></div></div></div><p>
                A webszolgáltatások importálhatók az OTRS-be egy előre meghatározott
szerkezettel rendelkező YAML-fájllal. Ebben az esetben a
<code class="filename">development/webservices/GenericTickeConnectorSOAP.yml</code>
fájlt bővítjük ki egy SOAP webszolgáltatáshoz.
            </p><p>
                </p><pre class="programlisting">
Provider:
  Operation:
    # ...
    Test:
      Description: Ez csak egy teszt
      MappingInbound: {}
      MappingOutbound: {}
      Type: Test::Test
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="operation-rest"></a>Webszolgáltatás REST-kiterjesztés példa</h6></div></div></div><p>
                A webszolgáltatások importálhatók az OTRS-be egy előre meghatározott
szerkezettel rendelkező YAML-fájllal. Ebben az esetben a
<code class="filename">development/webservices/GenericTickeConnectorREST.yml</code>
fájlt bővítjük ki egy REST webszolgáltatáshoz.
            </p><p>
                </p><pre class="programlisting">
Provider:
  Operation:
    # ...
    Test:
      Description: Ez csak egy teszt
      MappingInbound: {}
      MappingOutbound: {}
      Type: Test::Test
  # ...
  Transport:
    Config:
      # ...
      RouteOperationMapping:
        # ..
        Test:
          RequestMethod:
          - GET
          Route: /Test
                </pre><p>
            </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="daemon-scheduler-modules"></a>Démon és ütemező</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="daemon-overview"></a>OTRS démon</h4></div></div></div><p>
        Az OTRS démon egy elkülönített folyamat, amely segít az OTRS-nek bizonyos
műveleteket aszinkron módon és a webszolgáltatás folyamattól leválasztva
végrehajtani, de ugyanazt az adatbázist megosztva.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="daemon-modules"></a>OTRS démonmodulok</h5></div></div></div><p>
            A <code class="filename">bin/otrs.Daemon.pl</code> OTRS démon fő célja, hogy meghívja
(démonizálja) a rendszerbeállításokban lévő összes regisztrált démonmodult.
        </p><p>
            Minden egyes démonmodulnak meg kell valósítania egy közös API-t annak
érdekében, hogy az OTRS démon helyesen tudja meghívni, és félig állandó
folyamat legyen a rendszeren. Az állandó folyamat megnövelheti a méretét és
memóriahasználatát az idő múlásával, és normális esetben nem válaszolnak a
beállításokban lévő változásokra. Ezért kell a démonmoduloknak
megvalósítaniuk egy eldobási mechanizmust, hogy leállíthatók és újra
meghívhatók legyenek időről időre, felszabadítva a rendszer erőforrásait és
újraolvasva a beállításokat.
        </p><p>
            Egy démonmodul lehet mindenre jó megoldás bizonyos feladat végrehajtásánál,
de lehet olyan eset is, amikor egy megoldás különböző démonmodulokat igényel
az összetettsége miatt. Pontosan ez az eset az OTRS ütemező démonjával,
amely fel van osztva számos démonmodulra, beleértve a feladatkezeléshez és a
feladatvégrehajtáshoz szükséges néhány démonmodult.
        </p><p>
            Nem szükséges mindig új démonmodult létrehozni bizonyos feladatok
végrehajtásához. Általában az OTRS ütemező démon elboldogul ezek jelentős
részével – akár ha egy olyan OTRS függvényről van szó, amelyet rendszeresen
végre kell hajtani (CRON-szerűen), vagy ha egy OTRS esemény aktiválta azt –
az OTRS ütemezőnek képesnek kell lenni kezelnie mindenféle beállítás nélkül,
vagy egy új ütemező feladatelvégző modul hozzáadásával.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="creating-new-daemon-module"></a>Új démonmodul létrehozása</h6></div></div></div><p>
                Az összes démonmodulnak regisztrálva kell lennie a rendszerbeállításokban
azért, hogy a fő OTRS démon meg tudja hívni azokat.
            </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="daemon-module-registration-code-example"></a>Démonmodul regisztrációs kódpélda</h6></div></div></div><p>
                    </p><pre class="programlisting">
&lt;Setting Name="DaemonModules###TestDaemon" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;The daemon registration for the scheduler generic agent task manager.&lt;/Description&gt;
    &lt;Navigation&gt;Daemon::ModuleRegistration&lt;/Navigation&gt;
    &lt;Value&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::Daemon::DaemonModules::TestDaemon&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Value&gt;
&lt;/Setting&gt;
                    </pre><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="demon-module-code-example"></a>Démonmodul kódpélda</h6></div></div></div><p>
                    A következő kód egy olyan démonmodult valósít meg, amely megjeleníti a
rendszeridőt 2 másodpercenként.
                </p><p>
                    </p><pre class="programlisting">
# --
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Daemon::DaemonModules::TestDaemon;

use strict;
use warnings;
use utf8;

use Kernel::System::VariableCheck qw(:all);

use parent qw(Kernel::System::Daemon::BaseDaemon);

our @ObjectDependencies = (
    'Kernel::Config',
    'Kernel::System::Cache',
    'Kernel::System::DB',
);
                    </pre><p>
                </p><p>
                    Ez egy gyakori fejléc, amely megtalálható a legtöbb OTRS modulban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva.
                </p><p>
                    Ebben az esetben a <code class="literal">BaseDaemon</code> osztályból származtatunk
le, és az objektumkezelő függőségei be vannak állítva.
                </p><p>
                    </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # Új kivonat lefoglalása az objektumhoz.
    my $Self = {};
    bless $Self, $Type;

    # Objektumok lekérése a konstruktorban a teljesítmény megtartásáért.
    $Self-&gt;{ConfigObject} = $Kernel::OM-&gt;Get('Kernel::Config');
    $Self-&gt;{CacheObject}  = $Kernel::OM-&gt;Get('Kernel::System::Cache');
    $Self-&gt;{DBObject}     = $Kernel::OM-&gt;Get('Kernel::System::DB');

    # Letiltás a memóriagyorsítótárban, hogy fürtözhető legyen.
    $Self-&gt;{CacheObject}-&gt;Configure(
        CacheInMemory  =&gt; 0,
        CacheInBackend =&gt; 1,
    );

    $Self-&gt;{SleepPost} = 2;          # 2 másodperc alvás minden hurok után
    $Self-&gt;{Discard}   = 60 * 60;    # eldobás minden órában

    $Self-&gt;{DiscardCount} = $Self-&gt;{Discard} / $Self-&gt;{SleepPost};

    $Self-&gt;{Debug}      = $Param{Debug};
    $Self-&gt;{DaemonName} = 'Daemon: TestDaemon';

    return $Self;
}
                    </pre><p>
                </p><p>
                    A <code class="literal">new</code> konstruktor hozza létre az osztály új
példányát. Néhány felhasznált objektum is itt lesz létrehozva. Erősen
ajánlott a memóriába történő gyorsítótárazás letiltása a démonmodulokban,
különösen akkor, ha az OTRS fürtözött környezetben fut.
                </p><p>
                    Azért, hogy ez a démonmodul minden második másodpercben végrehajtható
legyen, egy alvási idő meghatározása szükséges annak megfelelően, egyébként
azonnal végrehajtásra kerül, amint lehetséges.
                </p><p>
                    A démonmodul frissítése időről időre azért szükséges, hogy meghatározható
legyen, mikor kell eldobni.
                </p><p>
                    A következő függvényeknél (<code class="literal">PreRun</code>, <code class="literal">Run</code>
és <code class="literal">PostRun</code>) ha azok hamis értékkel térnek vissza, akkor a
fő OTRS démon el fogja dobni az objektumot, és egy újat hoz létre, amint
lehetséges.
                </p><p>
                    </p><pre class="programlisting">
sub PreRun {
    my ( $Self, %Param ) = @_;

    # Annak ellenőrzése, hogy az adatbázis elérhető-e.
    return 1 if $Self-&gt;{DBObject}-&gt;Ping();

    sleep 10;

    return;
}
                    </pre><p>
                </p><p>
                    A <code class="literal">PreRun</code> metódus a fő démonmodul metódusa előtt kerül
végrehajtásra, és a célja néhány teszt elvégzése a valódi műfelet
előtt. Ebben az esetben az adatbázis ellenőrzése készen van (mindig
javasolt), egyébként 10 másodpercet alszik. Ez azért szükséges, hogy
megvárja az adatbázis-kapcsolat ismételt felépítését.
                </p><p>
                    </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    print "Jelenlegi idő: " . localtime . "\n";

    return 1;
}
                    </pre><p>
                </p><p>
                    A <code class="literal">Run</code> metódus az, ahol a fő démonmodul kódja
található. Ebben az esetben csak az aktuális időt írja ki.
                </p><p>
                    </p><pre class="programlisting">
sub PostRun {
    my ( $Self, %Param ) = @_;
    sleep $Self-&gt;{SleepPost};
    $Self-&gt;{DiscardCount}--;

    if ( $Self-&gt;{Debug} ) {
        print "  $Self-&gt;{DaemonName} eldobásainak száma: $Self-&gt;{DiscardCount}\n";
    }

    return if $Self-&gt;{DiscardCount} &lt;= 0;

    return 1;
}
                    </pre><p>
                </p><p>
                    A <code class="literal">PostRun</code> metódus használható az alvások végrehajtásához
(annak megakadályozásához, hogy a démonmodul túl gyakran legyen
végrehajtva), valamint az objektum biztonságos eldobásának kezeléséhez
is. Egyéb műveletek is elvégezhetők itt, mint például ellenőrzés vagy
tisztítás.
                </p><p>
                    </p><pre class="programlisting">
sub Summary {
    my ( $Self, %Param ) = @_;

    my %Summary = (
        Header =&gt; 'Tesztdémon összegzés:',
        Column =&gt; [
            {
                Name        =&gt; 'SomeColumn',
                DisplayName =&gt; 'Valamilyen oszlop',
                Size        =&gt; 15,
            },
            {
                Name        =&gt; 'AnotherColumn',
                DisplayName =&gt; 'Egy másik oszlop',
                Size        =&gt; 15,
            },
            # ...
        ],
        Data =&gt; [
            {
                SomeColumn    =&gt; '1. valamilyen adat',
                AnotherColumn =&gt; '1. másik adat',
            },
            {
                SomeColumn    =&gt; '2. valamilyen adat',
                AnotherColumn =&gt; '2. másik adat',
            },
            # ...
        ],
        NoDataMesssage =&gt; '',
    );

    return \%Summary;
}
                    </pre><p>
                </p><p>
                    A <code class="literal">Summary</code> metódust a
<code class="literal">Maint::Daemon::Summary</code> konzolparancs hívja meg, és
<code class="literal">Header</code>, <code class="literal">Column</code>,
<code class="literal">Data</code> és <code class="literal">NoDataMessages</code> kulcsokat kell
visszaadnia. A <code class="literal">Column</code> és a <code class="literal">Data</code>
kulcsoknak tömböknek vagy kivonatoknak kell lenniük. Arra használható, hogy
hasznos információkat jelenítsen meg arról, amit a démonmodul éppen csinál,
vagy ami eddig történt. Ez a metódus elhagyható.
                </p><p>
                    </p><pre class="programlisting">
1;
                    </pre><p>
                </p><p>
                    Fájl vége.
                </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scheduler-overview"></a>OTRS ütemező</h4></div></div></div><p>
        Az OTRS ütemező a démonmodulok és a feladatelvégzők együttese, amelyek
együtt futnak azért, hogy az összes szükséges OTRS feladatot aszinkron módon
végrehajtsák a webkiszolgáló folyamatából.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="scheduler-task-managers"></a>OTRS ütemező feladatkezelők</h5></div></div></div><p>
            A <code class="literal">SchedulerCronTaskManager</code> kiolvassa a regisztrált
cron-feladatokat az OTRS rendszerbeállításaiból, és meghatározza a helyes
időt a végrehajtandó feladat létrehozásához.
        </p><p>
            A <code class="literal">SchedulerFutureTaskManager</code> ellenőrzi azokat a
feladatokat, amelyek úgy vannak beállítva, hogy csak egy alkalommal fussanak
a jövőben, és beállítja, hogy a feladat időben kerüljön
végrehajtásra. Például amikor egy általános felület meghívónak nem sikerül
elérnie a távoli kiszolgálót, akkor ütemezni tudja magát, hogy 5 perccel
később újra fusson.
        </p><p>
            A <code class="literal">SchedulerGenericAgentTaskManager</code> folyamatosan olvassa a
<code class="literal">GenericAgent</code> feladatot, amely rendszeres időközönkénti
futáshoz van beállítva, és annak megfelelően állítja be azok végrehajtását.
        </p><p>
            Amikor ezek a feladatkezelők nem elegendőek, akkor egy új démonmodul hozható
létre. Egy feladat regisztrálásához a <code class="literal">Run()</code> metódusuk egy
bizonyos pontján meg kell hívni a <code class="literal">TaskAdd()</code> függvényt a
<code class="literal">chedulerDB</code> objektumból, és amint regisztrálva lett, akkor
a <code class="literal">SchedulerTaskWorker</code> végrehajtja a következő szabad
időszeletben.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="scheduler-task-workers"></a>OTRS ütemező feladatelvégzők</h5></div></div></div><p>
                A <code class="literal">SchedulerTaskWorker</code> az aszinkron végrehajtó
használatával végrehajtja az előző feladatkezelő által tervezett összes
feladatot, és még azokat is, amelyek közvetlenül a kódból jönnek.
            </p><p>
                Annak érdekében, hogy az összes feladatot végrehajtsa, a
<code class="literal">SchedulerTaskWorker</code> meghív egy háttérprogram-modult
(feladatelvégzőt) az adott feladat végrehajtásához. Az elvégző modult a
feladat típusa határozza meg. Ha új feladattípus kerül hozzáadásra, akkor az
új feladatelvégzőt is igényel.
            </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="creating-new-scheduler-task-worker"></a>Új ütemező feladatelvégző létrehozása</h6></div></div></div><p>
                    A
<code class="filename">Kernel/System/Daemon/DaemonModules/SchedulerTaskWorker</code>
mappa alatt elhelyezett összes fájl lehet potenciális feladatelvégző, és
azok nem igényelnek semmilyen regisztrációt a rendszerbeállításokban.
                </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="scheduler-task-worker-code-example"></a>Ütemező feladatelvégző kódpélda</h6></div></div></div><p>
                        </p><pre class="programlisting">
# --
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::Daemon::DaemonModules::SchedulerTaskWorker::TestWorker;

use strict;
use warnings;

use parent qw(Kernel::System::Daemon::DaemonModules::BaseTaskWorker);

our @ObjectDependencies = (
    'Kernel::System::Log',
);
                        </pre><p>
                    </p><p>
                        Ez egy gyakori fejléc, amely megtalálható a legtöbb OTRS modulban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva.
                    </p><p>
                        Ebben az esetben a <code class="literal">BaseTaskWorker</code> osztályból
származtatunk le, és az objektumkezelő függőségei be vannak állítva.
                    </p><p>
                        </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    $Self-&gt;{Debug}      = $Param{Debug};
    $Self-&gt;{WorkerName} = 'Worker: Test';

    return $Self;
}
                        </pre><p>
                    </p><p>
                        A <code class="literal">new</code> konstruktor hozza létre az osztály új példányát.
                    </p><p>
                        </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # Feladatparaméterek ellenőrzése.
    my $CheckResult = $Self-&gt;_CheckTaskParams(
        %Param,
        NeededDataAttributes =&gt; [ 'NeededAtrribute1', 'NeededAtrribute2' ],
        DataParamsRef        =&gt; 'HASH', # vagy 'ARRAT'
    );

    # Végrehajtás leállítása, ha hiba található a paraméterekben.
    return if !$CheckResult;

    my $Success;
    my $ErrorMessage;

    if ( $Self-&gt;{Debug} ) {
        print "    $Self-&gt;{WorkerName} végrehajtja a feladatot: $Param{TaskName}\n";
    }

    do {

        # A szabványos hiba lokalizálása.
        local *STDERR;

        # A szabványos hiba átirányítása egy változóba.
        open STDERR, "&gt;&gt;", \$ErrorMessage;

        $Success = $Kernel::OM-&gt;Get('Kernel::System::MyPackage')-&gt;Run(
            Param1 =&gt; 'someparam',
        );
    };

    if ( !$Success ) {

        $ErrorMessage ||= "$Param{TaskName} végrehajtása sikertelen egy hibaüzenettel!";

        $Self-&gt;_HandleError(
            TaskName     =&gt; $Param{TaskName},
            TaskType     =&gt; 'Test',
            LogMessage   =&gt; "Hiba történt a(z) $Param{TaskName} végrehajtásakor: $ErrorMessage",
            ErrorMessage =&gt; "$ErrorMessage",
        );
    }

    return $Success;
}
                        </pre><p>
                    </p><p>
                        A <code class="literal">Run</code> a fő metódus. Egy
<code class="literal">_CheckTaskParams()</code> hívás az alaposztályból megspórol
néhány kódsort. A feladat végrehajtása a szabványos hibakimenet megszerzése
közben nagyon jó gyakorlat, mivel az OTRS ütemező normális esetben
felügyelet nélkül fut, és az összes hiba egy változóba történő mentése
lehetővé fogja tenni a későbbi feldolgozást. A
<code class="literal">_HandleError()</code> közös felületet biztosít a hibaüzenetek
e-mailben történő küldéséhez a rendszerbeállításokban megadott címzetteknek.
                    </p><p>
                        </p><pre class="programlisting">
1;
                        </pre><p>
                    </p><p>
                        Fájl vége.
                    </p></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicfields-modules"></a>Dinamikus mezők</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-overview"></a>Áttekintés</h4></div></div></div><p>
        A dinamikus mezők olyan egyéni mezők, amelyek hozzáadhatók egy képernyőhöz,
hogy javítsák és információkat adjanak hozzá egy objektumhoz (például egy
jegyhez vagy egy bejegyzéshez).
    </p><p>
        A dinamikus mezők a jegy és a bejegyzés szabad mezőinek
(<code class="literal">TikcetFreeText</code>, <code class="literal">TicketFreeKey</code>,
<code class="literal">TicketFreeTime</code>, <code class="literal">ArticleFreeText</code>,
<code class="literal">ArticleFreeKey</code> és <code class="literal">ArticleFreeTime</code>)
evolúciója az OTRS régebbi verzióiból.
    </p><p>
        Az OTRS 3.1-es verziójától a régi szabad mezőket lecserélték az új dinamikus
mezőkre. A korábbi verziókról történő frissítéskor a jobb visszafelé
kompatibilitáshoz és az adatmegőrzéshez egy költöztető parancsfájlt
fejlesztettek ki a meglévő szabad mezők dinamikus mezőkre való
átalakításához, és azok értékeinek áthelyezéséhez az adatbázisban lévő
<span class="emphasis"><em>ticket</em></span> és <span class="emphasis"><em>article</em></span> táblákból az új
dinamikus mezők tábláiba.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
            Minden szabad mezőket használó egyéni fejlesztést át kell írni az új
dinamikus mezők kódszerkezetére, különben többé nem fognak működni. Emiatt
nagyon fontos tudni azt, hogy az OTRS 3.0-nak csak a frissített telepítései
rendelkeznek a dinamikus mezőkre átalakított régi szabad mezőkkel, az OTRS
új vagy tiszta telepítéseinek nincsenek „eredetileg” meghatározott dinamikus
mezői, és az egyéni fejlesztés által szükséges összes dinamikus mezőt hozzá
kell adni.
        </p></div><p>
        A jegyenkénti vagy bejegyzésenkénti mezők számának korlátozása eltávolításra
került. Ez azt jelenti, hogy egy jegy vagy egy bejegyzés annyi mezővel
rendelkezhet, amennyi szükséges. És mostantól lehetséges a dinamikus mezők
keretrendszerének használata egyéb objektumoknál is ahelyett, hogy csak a
jegynél vagy a bejegyzésnél lenne használható.
    </p><p>
        Az új dinamikus mezők ugyanazokat az adattípusokat tudják eltárolni mint a
szabad mezők (szöveg és dátum/idő), és ugyanúgy határozhatók meg mint azok
(egysoros beviteli mező, legördülő és dátum/idő), de a dinamikus mezők
túlmennek ezen, ugyanis egy új egész szám adattípus került hozzáadásra,
valamint új lehetőségek is az olyan mezők meghatározásához, mint például
többsoros beviteli mezők, jelölőnégyzetek, többválasztós mezők és (idő
nélküli) dátum mezők. Minden egyes mezőtípus saját adattípust határoz meg.
    </p><p>
        A moduláris tervezésének köszönhetően az egyes dinamikus mezőtípusok egy
keretrendszerhez tartozó bővítményként láthatók, és ez a bővítmény lehet egy
szabványos OTRS csomag is a dinamikus mezők elérhető típusainak
kiterjesztéséhez, vagy akár a jelenlegi dinamikus mező további függvényekkel
való kiterjesztéséhez.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-framework"></a>Dinamikus mezők keretrendszer</h4></div></div></div><p>
        Az új dinamikus mezők létrehozása előtt szükséges megérteni azok
keretrendszerét, és hogy az OTRS képernyők hogyan lépnek kölcsönhatásba
azokkal, valamint a mögöttes API-t.
    </p><p>
        A következő kép a dinamikus mezők keretrendszer szerkezetét mutatja be.
    </p><p>
        </p><div class="figure"><a name="id-1.4.3.9.3.4.1"></a><p class="title"><b>3.2. ábra - Dinamikus mezők szerkezete</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/dfframework.png" alt="Dinamikus mezők szerkezete"></div></div></div></div><p><br class="figure-break">
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-backends"></a>Dinamikus mező háttérprogram modulok</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-backend"></a>Dinamikus mező (háttérprogram)</h6></div></div></div><p>
                Az előtétprogram modulokban normális esetben a
<code class="literal">BackendObject</code> nevű objektum a közvetítő az előtétprogram
modulok és az egyes konkrét dinamikus mező megvalósítás vagy illesztőprogram
között. Ez határoz meg egy általános közbenső API-t az összes dinamikus mező
illesztőprogramhoz, és az egyes illesztőprogramok felelőssége a közbenső API
megvalósítása a mező sajátos szükségleteihez.
            </p><p>
                A dinamikus mező háttérprogram az összes illesztőprogram fő vezérlője. Ebben
a modulban minden egyes függvény felelős a szükséges paraméterek
ellenőrzéséért, és ugyanazon függvény meghívásáért az adott
illesztőprogramban a kapott dinamikus mező beállítási paraméter szerint.
            </p><p>
                Ez a modul felelős bizonyos függvények meghívásáért is minden egyes
objektumtípus delegáltnál (úgymint jegy vagy bejegyzés). Például egy
előzmény bejegyzés hozzáadásához vagy egy esemény elsütéséhez.
            </p><p>
                Ez a modul az
<code class="filename">$OTRS_HOME/Kernel/System/DynamicField/Backend.pm</code>
fájlban található.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-drivers"></a>Dinamikus mező illesztőprogramok</h6></div></div></div><p>
                Egy dinamikus mező illesztőprogram a dinamikus mező megvalósítása. Minden
egyes illesztőprogramnak meg kell valósítania a háttérprogramban
meghatározott összes kötelező függvényt (van néhány olyan függvény, amely
egy viselkedéstől függ, és nem szükséges megvalósítani azokat, ha a
dinamikus mező nem rendelkezik azzal a bizonyos viselkedéssel).
            </p><p>
                Egy illesztőprogram felelős annak ismeretéért, hogy hogyan kérje le a saját
értékét vagy értékeit egy webkérésből vagy egy profilból (mint például egy
keresési profilból). Szükséges tudnia a HTML kódot is a szerkesztő vagy
megjelenítő képernyőkön lévő mező megjelenítéséhez, vagy hogy hogyan lépjen
kölcsönhatásba a statisztikák modullal, többek között a függvényekkel.
            </p><p>
                Ezek a modulok az
<code class="filename">$OTRS_HOME/Kernel/System/DynamicField/Driver/*.pm</code>
fájlokban találhatók.
            </p><p>
                Létezik néhány alap illesztőprogram, úgymint <code class="filename">Base.pm</code>,
<code class="filename">BaseText.pm</code>, <code class="filename">BaseSelect.pm</code> és
<code class="filename">BaseDateTime.pm</code>, amely gyakori függvényeket valósít meg
bizonyos illesztőprogramokhoz (például a <code class="filename">TextArea.pm</code>
illesztőprogram a <code class="filename">BaseText.pm</code> fájlt használja, amely a
<code class="filename">Base.pm</code> fájlt használja, ekkor a
<code class="literal">TextArea</code> csak azon függvények megvalósítását igényli,
amelyek hiányoznak a <code class="filename">Base.pm</code> és
<code class="filename">BateText.pm</code> fájlokból, vagy azokat, amelyek különleges
esetek).
            </p><p>
                A következő az illesztőprogramok öröklődési fája:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>Base.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>BaseText.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>Text.pm</p></li><li class="listitem"><p>TextArea.pm</p></li></ul></div></li><li class="listitem"><p>BaseSelect.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>Dropdown.pm</p></li><li class="listitem"><p>Multiselect.pm</p></li></ul></div></li><li class="listitem"><p>BaseDateTime.pm</p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>DateTime.pm</p></li><li class="listitem"><p>Date.pm</p></li></ul></div></li><li class="listitem"><p>Checkbox.pm</p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-object-type-delegates"></a>Objektumtípus delegált</h6></div></div></div><p>
                Egy objektumtípus delegált felelős bizonyos függvények végrehajtásáért a
dinamikus mezőhöz kapcsolt objektumon. Ezeket a függvényeket a háttérprogram
objektum aktiválja, amint szükség van rájuk.
            </p><p>
                Ezek a modulok az
<code class="filename">$OTRS_HOME/Kernel/System/DynamicField/ObjectType/*.pm</code>
fájlokban találhatók.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-admin"></a>Dinamikus mezők adminisztrátori moduljai</h5></div></div></div><p>
            A dinamikus mezők kezeléséhez (hozzáadás, szerkesztés és felsorolás) már egy
csomó modul van kifejlesztve. Van egy bizonyos fő modul
(<code class="filename">AdminDynamicField.pm</code>), amely megjeleníti a
meghatározott dinamikus mezők listáját, és más modulokon belülről hívják meg
új dinamikus mezők létrehozásához vagy a meglévők módosításához.
        </p><p>
            Normális esetben egy dinamikus mező illesztőprogramnak saját adminisztrátori
modulra van szüksége (adminisztrátori párbeszédablak) a tulajdonságai
meghatározásához. Ez a párbeszédablak esetleg eltérhet a többi
illesztőprogramtól. De ez nem kötelező, az illesztőprogramok megoszthatják
az adminisztrátori párbeszédablakokat, ha szükséges információkat
biztosíthatnak az összes olyan illesztőprogramhoz, amelyek hozzájuk vannak
kapcsolva, nem számít, hogy eltérő típusból származnak. Ami kötelező, hogy
minden egyes illesztőprogramnak hozzákapcsolva kell lennie egy
adminisztrátori párbeszédablakhoz (például a szöveg és a szövegterület
illesztőprogramok megosztják az
<code class="filename">AdminDynamicFieldText.pm</code> adminisztrátori
párbeszédablakot, és a dátum és a dátum/idő illesztőprogramok megosztják az
<code class="filename">AdminDynamicFieldDateTime.pm</code> adminisztrátori
párbeszédablakot).
        </p><p>
            Az adminisztrátori párbeszédablakok a normál OTRS adminisztrátori
modulszabályokat és szerkezetet követik. De a szabványosításhoz az összes
beállítás közös részének az összes dinamikus mezőnél ugyanolyan
megjelenésűnek kell lennie az összes adminisztrátori párbeszédablaknál.
        </p><p>
            Ezek a modulok az <code class="filename">$OTRS_HOME/Kernel/Modules/*.pm</code>
fájlokban találhatók.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                Minden adminisztrátori párbeszédablaknak szüksége van a neki megfelelő HTML
sablonfájlra (<code class="filename">.tt</code>).
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-core"></a>Dinamikus mezők alapmoduljai</h5></div></div></div><p>
            Ezek a modulok olvassák és írják a dinamikus mezők információit az
adatbázistáblákban.
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-core-dynamicfield"></a><code class="filename">DynamicField.pm</code> alapmodul</h6></div></div></div><p>
                Ez a modul felelős a dinamikus mező meghatározások kezeléséért. Ez
biztosítja az alap API-t a hozzáadáshoz, megváltoztatáshoz, törléshez,
felsoroláshoz és a dinamikus mezők lekéréséhez. Ez a modul az
<code class="filename">$OTRS_HOME/Kernel/System/DynamicField.pm</code> fájlban
található.
            </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-core-dynamicfieldvalue"></a><code class="filename">DynamicFieldValue.pm</code> alapmodul</h6></div></div></div><p>
                Ez a modul felelős a dinamikus mező értékeinek olvasásáért és írásáért az
űrlapon és az adatbázisban. Ezt a modult erősen használják az
illesztőprogramok, és az
<code class="filename">$OTRS_HOME/Kernel/System/DynamicFieldValue.pm</code> fájlban
található.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-database"></a>Dinamikus mezők adatbázistáblái</h5></div></div></div><p>
            Két tábla van az adatbázisban a dinamikus mező információinak tárolásához:
        </p><p>
            <span class="emphasis"><em>dynamic_field</em></span>: a <code class="filename">DynamicField.pm</code>
alapmodul használja, és a dinamikus mező meghatározásokat tárolja.
        </p><p>
            <span class="emphasis"><em>dynamic_field_value</em></span>: a
<code class="filename">DynamicFieldValue.pm</code> alapmodul használja a dinamikus
mező értékeinek mentéséhez minden egyes dinamikus mező és minden egyes
objektumtípus példánynál.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-configuration-files"></a>Dinamikus mezők beállítófájljai</h5></div></div></div><p>
            A háttérprogram modulnak szüksége van egy módra megtudni azt, hogy mely
illesztőprogramok léteznek, mivel az illesztőprogramok mennyisége egyszerűen
kiterjeszthető. Ezek kezelésének legegyszerűbb módja a rendszerbeállítás
használata, ahol a dinamikus mező illesztőprogramok és az objektumtípus
illesztőprogramok információi eltárolhatók és kiterjeszthetők.
        </p><p>
            A fő adminisztrátori modulnak is szükséges tudnia ezeket az információkat az
elérhető dinamikus mező illesztőprogramokról a hozzájuk kapcsolt
adminisztrátori párbeszédablakok használatához, a dinamikus mezők
létrehozásához vagy módosításához.
        </p><p>
            Az előtétprogram moduloknak szükségük van a rendszerbeállítások olvasására
megtudni azt, hogy mely dinamikus mezők vannak bekapcsolva az egyes
képernyőknél, és melyek kötelezőek. Például a
<code class="literal">Ticket::Frontend::AgentTicketPhone###DynamicField</code> tárolja
az aktív, kötelező és inaktív dinamikus mezőket az új telefonos jegy
képernyőnél.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-interaction"></a>Dinamikus mező kölcsönhatása az előtétprogram modulokkal</h4></div></div></div><p>
        Ismerve azt, hogy az előtétprogram modulok hogyan lépnek kölcsönhatásba a
dinamikus mezőkkel, nem feltétlenül szükséges a dinamikus mezők
kiterjesztése a jegy vagy bejegyzés objektumokhoz, mivel már elő van
készítve az összes olyan képernyő, amely dinamikus mezőket tud használni. De
egyéni fejlesztések esetén vagy a dinamikus mezők más objektumokhoz történő
kiterjesztéséhez nagyon hasznos tudni, hogy a dinamikus mezők keretrendszere
hogyan érhető el egy előtétprogram modulból.
    </p><p>
        A következő kép egy egyszerű példáját mutatja be annak, hogy a dinamikus
mezők hogyan lépnek kölcsönhatásba az OTRS keretrendszer többi részével.
    </p><p>
        </p><div class="figure"><a name="id-1.4.3.9.4.4.1"></a><p class="title"><b>3.3. ábra - Dinamikus mezők kölcsönhatása</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/dfInteraction.png" alt="Dinamikus mezők kölcsönhatása"></div></div></div></div><p><br class="figure-break">
    </p><p>
        Az első lépés, hogy az előtétprogram modul beolvassa a beállított dinamikus
mezőket. Például az <code class="literal">AgentTicketNote</code> modulnak be kell
olvasnia a
<code class="literal">Ticket::Frontend::AgentTicketNote###DynamicField</code>
beállítást. Ez a beállítás használható szűrőparaméterként a
<code class="code">DynamicFieldListGet()</code> dinamikus mező alapmodul függvénynél. A
képernyő tárolhatja ennek a függvénynek az eredményeit, hogy meglegyen az
aktivált dinamikus mezők listája ennél a bizonyos képernyőnél.
    </p><p>
        Ezután a képernyőnek meg kell próbálnia lekérni az értékeket a
webkérésből. Erre a célra használhatja az <code class="code">EditFieldValueGet()</code>
háttérprogram-objektum függvényt, és használhatja ezeket az értékeket az
ACL-ek aktiválásához. A háttérprogram-objektum minden egyes
illesztőprogramot használni fog a különleges műveletek végrehajtásához az
összes függvénynél.
    </p><p>
        A folytatáshoz a képernyőnek le kell kérnie a HTML-t minden egyes mezőhöz
annak megjelenítéséhez. Az <code class="code">EditFieldRender()</code>
háttérprogram-objektum függvény használható ezen művelet és az ACL-ek
korlátozásának végrehajtásához, valamint a webkérésből származó értékek
átadhatók ennek a függvénynek azért, hogy jobb eredményeket kapjon. Egy
elküldés esetén a képernyő használhatja az
<code class="code">EditFieldValueValidate()</code> háttérprogram-objektum függvényt is a
kötelező mezők ellenőrzéséhez.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
            A többi képernyő használhatja a <code class="code">DisplayFieldRender()</code> függvényt
az <code class="code">EditFieldRender()</code> helyett, ha a képernyő csak a mezőértéket
jeleníti meg, és ilyen esetben nincs szükség értékellenőrzésre.
        </p></div><p>
        A dinamikus mező értékének tárolásához szükséges az objektumazonosító
lekérése. Ennél a példánál ha a dinamikus mező hozzá van kapcsolva egy jegy
objektumhoz, akkor a képernyőnek már rendelkeznie kell a jegyazonosítóval,
egyébként ha a mező hozzá van kapcsolva egy bejegyzés objektumhoz azért,
hogy beállítsa a mező értékét, akkor először a bejegyzés létrehozása
szükséges. A háttérprogram-objektumból a <code class="code">ValueSet()</code> függvény
használható a dinamikus mező értékének beállításához.
    </p><p>
        Összefoglalva, az előtétprogram moduloknak nem szükséges tudniuk, hogy az
egyes dinamikus mezők hogyan működnek belsőleg azért, hogy lekérjék vagy
beállítsák az értékeiket vagy megjelenítsék azokat. Egyszerűen csak meg kell
hívnia a háttérprogram-objektum modult, és általános módon kell használnia a
mezőket.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-extend-options"></a>Hogyan lehet kiterjeszteni a dinamikus mezőket</h4></div></div></div><p>
        Számos módszer létezik a dinamikus mezők kiterjesztésére. A következő
szakaszok meg fogják próbálni a leggyakoribb forgatókönyveket bemutatni.
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-new-field"></a>Egy új dinamikus mező típus létrehozása (a jegy vagy bejegyzés
objektumokhoz)</h5></div></div></div><p>
            Egy új dinamikus mező típus létrehozásához a következők szükségesek:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Hozzon létre egy dinamikus mező illesztőprogramot
                </p><p>
                    Ez az új mező fő modulja.
                </p></li><li class="listitem"><p>
                    Hozzon létre vagy használjon egy meglévő adminisztrátori párbeszédablakot
                </p><p>
                    Egy kezelőfelület megszerzéséhez, és a konfigurációs beállításainak
megadásához.
                </p></li><li class="listitem"><p>
                    Hozzon létre egy beállítófájlt
                </p><p>
                    Az új mező regisztrálásához a háttérprogramban (vagy a keretrendszerben lévő
új adminisztrátori párbeszédablakokban, ha szükséges), valamint hogy képes
legyen példányokat vagy azt létrehozni.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-new-field-new-object"></a>Egy új dinamikus mező típus létrehozása (egyéb objektumokhoz)</h5></div></div></div><p>
            Egy új dinamikus mező típus létrehozásához más objektumoknál a következők
szükségesek:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Hozzon létre egy dinamikus mező illesztőprogramot
                </p><p>
                    Ez az új mező fő modulja.
                </p></li><li class="listitem"><p>
                    Hozzon létre egy objektumtípus delegáltat
                </p><p>
                    Ez akkor is szükséges, ha a „másik objektum” nem igényel semmilyen
különleges adatkezelést a függvényeiben (például egy érték beállítása
után). Az összes objektumtípus delegáltnak meg kell valósítania azokat a
függvényeket, amelyeket a háttérprogram igényel.
                </p><p>
                    Vessen egy pillantást a jelenlegi objektumtípus delegáltakra ugyanazon
függvények megvalósításához még akkor is, ha azok csak egy sikeres értéket
adnak vissza a „másik objektumnál”.
                </p></li><li class="listitem"><p>
                    Hozzon létre vagy használjon egy meglévő adminisztrátori párbeszédablakot
                </p><p>
                    Egy kezelőfelület megszerzéséhez, és a konfigurációs beállításainak
megadásához.
                </p></li><li class="listitem"><p>
                    Valósítsa meg a dinamikus mezőket az előtétprogram modulokban
                </p><p>
                    Hogy képes legyen használni a dinamikus mezőket.
                </p></li><li class="listitem"><p>
                    Hozzon létre egy beállítófájlt
                </p><p>
                    Az új mező regisztrálásához a háttérprogramban (vagy a keretrendszerben lévő
új adminisztrátori párbeszédablakokban, ha szükséges), valamint hogy képes
legyen példányokat vagy azt létrehozni. És végezze el a szükséges
beállításokat az új képernyőkön történő megjelenítéshez, elrejtéshez vagy a
dinamikus mezők kötelezőként való megjelenítéséhez.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-new-packages"></a>Egy új csomag létrehozása a dinamikus mezők használatához</h5></div></div></div><p>
            Egy csomag létrehozásához a meglévő dinamikus mezők használata érdekében a
következők szükségesek:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Valósítsa meg a dinamikus mezőket az előtétprogram modulokban
                </p><p>
                    Hogy képes legyen használni a dinamikus mezőket.
                </p></li><li class="listitem"><p>
                    Hozzon létre egy beállítófájlt
                </p><p>
                    Hogy lehetőséget adjon a végfelhasználónak az új képernyőkön történő
megjelenítéshez, elrejtéshez vagy a dinamikus mezők kötelezőként való
megjelenítéséhez.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-options-backend-functionalities"></a>A háttérprogram és az illesztőprogramok funkcionalitásainak kiterjesztése</h5></div></div></div><p>
            Lehetséges lehet, hogy a háttérprogram objektum nem rendelkezik egy
szükséges függvénnyel az egyéni fejlesztésekhez, vagy az is előfordulhat,
hogy megvan ugyan a szükséges függvénye, de a visszatérési formátum nem
felel meg az egyéni fejlesztés szükségleteinek, vagy hogy egy új viselkedés
az új vagy a régi függvények végrehajtását igényli.
        </p><p>
            A legegyszerűbb mód ennek elvégzéséhez a jelenlegi mezőfájlok
kiterjesztése. Ehhez egy olyan új háttérprogram kiterjesztésfájlt szükséges
létrehozni, amely meghatározza az új függvényeket, és olyan illesztőprogram
kiterjesztéseket is létre kell hozni, amelyek megvalósítják ezeket az új
függvényeket minden egyes mezőnél. Ezeknek az új illesztőprogramoknak csak
az új függvényeket kell majd megvalósítaniuk, mivel az eredeti
illesztőprogramok törődnek a szabványos függvényekkel. Ezen új fájlok
egyikének sincs szüksége konstruktorra, mivel ezek egy alapként lesznek
betöltve a háttérprogram objektumhoz és az illesztőprogramokhoz.
        </p><p>
            Az egyetlen korlátozás, hogy a függvényeket eltérően kell elnevezni a
háttérprogramnál és az illesztőprogramnál lévőknél, különben felül fognak
íródni a jelenlegi objektumokkal.
        </p><p>
            Tegye az új háttérprogram kiterjesztést a <code class="filename">DynamicField</code>
könyvtárba (például
<code class="filename">/$OTRS_HOME/Kernel/System/DynamicField/NewPackageBackend.pm</code>
és az illesztőprogramjait a
<code class="filename">/$OTRS_HOME/Kernel/System/DynamicField/Driver/NewPackage*.pm</code>
fájlokba).
        </p><p>
            Az új viselkedéseknek csak egy kis beállítás szükséges a kiterjesztések
beállítófájljában.
        </p><p>
            Az új háttérprogram függvények létrehozásához a következők szükségesek:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                    Hozzon létre egy új háttérprogram kiterjesztés modult
                </p><p>
                    Csak az új függvények meghatározásához.
                </p></li><li class="listitem"><p>
                    Hozza létre a dinamikus mezők illesztőprogram kiterjesztéseit
                </p><p>
                    Csak az új függvények megvalósításához.
                </p></li><li class="listitem"><p>
                    Valósítsa meg az új dinamikus mezők függvényeit az előtétprogram modulokban
                </p><p>
                    Hogy képes legyen használni az új dinamikus mezők függvényeit.
                </p></li><li class="listitem"><p>
                    Hozzon létre egy beállítófájlt
                </p><p>
                    Az új háttérprogram és az illesztőprogramok kiterjesztéseinek és
viselkedéseinek regisztrálásához.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-options-extend-other"></a>Egyéb kiterjesztések</h5></div></div></div><p>
            Egyéb kiterjesztések lehetnek a fenti példák kombinációi.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-new-field"></a>Egy új dinamikus mező létrehozása</h4></div></div></div><p>
        A folyamat bemutatásához egy új „jelszó” dinamikus mező lesz létrehozva. Ez
az új dinamikus mező típus egy új jelszómezőt fog megjeleníteni a jegy és a
bejegyzés objektumokhoz. Mivel nagyon hasonló egy szöveg dinamikus mezőhöz,
ezért a <code class="literal">Base</code> és a <code class="literal">BaseText</code>
illesztőprogramokat fogjuk használni alapként ezen új mező felépítéséhez.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
            Az új jelszómező megvalósítása csak oktatási célokra van, nem biztosít
semmilyen biztonsági szintet, és nem ajánlott termelési rendszereknél.
        </p></div><p>
        A dinamikus mező létrehozásához négy fájlt fogunk létrehozni: egy
beállítófájlt (XML) a modulok regisztrálásához, egy adminisztrátori
párbeszédablak modult (Perl) a mezőlehetőségek beállításához, egy
sablonmodult az adminisztrátori párbeszédablakhoz és egy dinamikus mező
illesztőprogramot (Perl).
    </p><p>
        Fájlszerkezet:
    </p><pre class="programlisting">
$HOME (például /opt/otrs/)
|
...
|--/Kernel/
|   |--/Config/
|   |   |--/Files/
|   |   |   |DynamicFieldPassword.xml
...
|   |--/Modules/
|   |   |AdminDynamicFieldPassword.pm
...
|   |--/Output/
|   |   |--/HTML/
|   |   |   |--/Standard/
|   |   |   |   |AdminDynamicFieldPassword.tt
...
|   |--/System/
|   |   |--/DynamicField/
|   |   |   |--/Driver/
|   |   |   |   |Password.pm
...
        </pre><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-new-field-files"></a>Dinamikus mező jelszó fájlok</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-config"></a>Dinamikus mező beállítófájl példa</h6></div></div></div><p>
        A beállítófájlokat használják a dinamikus mező típusok (illesztőprogram) és
az objektumtípus illesztőprogramok regisztrálásához a
<code class="literal">BackendObject</code> számára. Ezek szabványos regisztrációkat is
tárolnak az adminisztrátori modulokhoz a keretrendszerben.
    </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-config-code"></a>Kódpélda:</h6></div></div></div><p>
                Ebben a szakaszban a jelszó dinamikus mezőhöz egy beállítófájl van
megjelenítve és elmagyarázva.
            </p><p>
            </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;otrs_config version="1.0" init="Application"&gt;
            </pre><p>
        </p><p>
            Ez a normál fejléc egy beállítófájlhoz.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="DynamicFields::Driver###Password" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Dinamikus mező háttérprogram regisztráció.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldPassword&lt;/Group&gt;
        &lt;SubGroup&gt;DynamicFields::Backend::Registration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="DisplayName" Translatable="1"&gt;Jelszó&lt;/Item&gt;
                &lt;Item Key="Module"&gt;Kernel::System::DynamicField::Driver::Password&lt;/Item&gt;
                &lt;Item Key="ConfigDialog"&gt;AdminDynamicFieldPassword&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            Ez a beállítás regisztrálja a jelszó dinamikus mező illesztőprogramot a
háttérprogram modulhoz, így az felvehető az elérhető dinamikus mezők
típusainak listájába. A saját adminisztrátori párbeszédablakát is
meghatározza a <code class="literal">ConfigDialog</code> kulcsban. Ezt a kulcsot a fő
dinamikus mező adminisztrátori modul használja ennek az új dinamikus mező
típusának a kezeléséhez.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="Frontend::Module###AdminDynamicFieldPassword" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Előtétprogram-modul regisztráció az ügyintézői felülethez.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldPassword&lt;/Group&gt;
        &lt;SubGroup&gt;Frontend::Admin::ModuleRegistration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;FrontendModuleReg&gt;
                &lt;Group&gt;admin&lt;/Group&gt;
                &lt;Description&gt;Admin&lt;/Description&gt;
                &lt;Title Translatable="1"&gt;Dinamikus mezők szöveg háttérprogram grafikus felület&lt;/Title&gt;
                &lt;Loader&gt;
                    &lt;JavaScript&gt;Core.Agent.Admin.DynamicField.js&lt;/JavaScript&gt;
                &lt;/Loader&gt;
            &lt;/FrontendModuleReg&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            Ez egy szabványos modulregisztráció a jelszó adminisztrátori
párbeszédablakhoz az adminisztrátori felületen.
        </p><p>
            </p><pre class="programlisting">
&lt;/otrs_config&gt;
            </pre><p>
        </p><p>
            Egy beállítófájl szabványos lezárása.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module"></a>Dinamikus mező adminisztrátori párbeszédablak példa</h6></div></div></div><p>
        Az adminisztrátori párbeszédablakok szabványos adminisztrátori modulok a
dinamikus mezők kezeléséhez (hozzáadás vagy szerkesztés).
    </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-code"></a>Kódpélda:</h6></div></div></div><p>
                Ebben a szakaszban a jelszó dinamikus mezőhöz egy adminisztrátori
párbeszédablak van megjelenítve és elmagyarázva.
            </p><p>
            </p><pre class="programlisting">
# --
# Kernel/Modules/AdminDynamicFieldPassword.pm - provides a dynamic fields password config view for admins
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::Modules::AdminDynamicFieldPassword;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);
use Kernel::System::Valid;
use Kernel::System::CheckItem;
use Kernel::System::DynamicField;
            </pre><p>
        </p><p>
            Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva.
        </p><p>
            </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {%Param};
    bless( $Self, $Type );

    for (qw(ParamObject LayoutObject LogObject ConfigObject)) {
        if ( !$Self-&gt;{$_} ) {
            $Self-&gt;{LayoutObject}-&gt;FatalError( Message =&gt; "Nincs $_!" );
        }
    }

    # további objektumok létrehozása
    $Self-&gt;{ValidObject} = Kernel::System::Valid-&gt;new( %{$Self} );

    $Self-&gt;{DynamicFieldObject} = Kernel::System::DynamicField-&gt;new( %{$Self} );

    # beállított objektumtípusok lekérése
    $Self-&gt;{ObjectTypeConfig} = $Self-&gt;{ConfigObject}-&gt;Get('DynamicFields::ObjectType');

    # a mezők beállításának lekérése
    $Self-&gt;{FieldTypeConfig} = $Self-&gt;{ConfigObject}-&gt;Get('DynamicFields::Backend') || {};

    $Self-&gt;{DefaultValueMask} = '****';
    return $Self;
}
            </pre><p>
        </p><p>
            A <code class="literal">new</code> konstruktor hozza létre az osztály új példányát. A
kódolási irányelvek szerint más osztályoknak azon objektumait kell a
<code class="literal">new</code> konstruktorban létrehozni, amelyek ebben a modulban
szükségesek.
        </p><p>
            </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{Subaction} eq 'Add' ) {
        return $Self-&gt;_Add(
            %Param,
        );
    }
    elsif ( $Self-&gt;{Subaction} eq 'AddAction' ) {

        # kihívási token ellenőrzése az írási művelethez
        $Self-&gt;{LayoutObject}-&gt;ChallengeTokenCheck();

        return $Self-&gt;_AddAction(
            %Param,
        );
    }
    if ( $Self-&gt;{Subaction} eq 'Change' ) {

        return $Self-&gt;_Change(
            %Param,
        );
    }
    elsif ( $Self-&gt;{Subaction} eq 'ChangeAction' ) {

        # kihívási token ellenőrzése az írási művelethez
        $Self-&gt;{LayoutObject}-&gt;ChallengeTokenCheck();

        return $Self-&gt;_ChangeAction(
            %Param,
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
        Message =&gt; "Meghatározatlan alművelet.",
    );
}
            </pre><p>
        </p><p>
            A <code class="literal">Run</code> a webkérés által meghívott alapértelmezett
függvény. Megpróbáljuk ezt a függvényt annyira egyszerűvé tenni, amennyire
csak lehetséges, és lehetővé tenni a segítő függvényeknek a „kemény” munka
elvégzését.
        </p><p>
            </p><pre class="programlisting">
sub _Add {
    my ( $Self, %Param ) = @_;

    my %GetParam;
    for my $Needed (qw(ObjectType FieldType FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$Needed ) {

            return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
                Message =&gt; "Szükséges: $Needed",
            );
        }
    }

    # az objektumtípus és a mezőtípus megjelenített nevének lekérése
    my $ObjectTypeName = $Self-&gt;{ObjectTypeConfig}-&gt;{ $GetParam{ObjectType} }-&gt;{DisplayName} || '';
    my $FieldTypeName  = $Self-&gt;{FieldTypeConfig}-&gt;{ $GetParam{FieldType} }-&gt;{DisplayName}   || '';

    return $Self-&gt;_ShowScreen(
        %Param,
        %GetParam,
        Mode           =&gt; 'Add',
        ObjectTypeName =&gt; $ObjectTypeName,
        FieldTypeName  =&gt; $FieldTypeName,
    );
}
            </pre><p>
        </p><p>
            Az <code class="code">_Add</code> függvény is nagyon egyszerű, csak lekér néhány
paramétert a webkérésből, és meghívja a <code class="code">_ShowScreen()</code>
függvényt. Normális esetben ezt a függvényt nem szükséges módosítani.
        </p><p>
            </p><pre class="programlisting">
sub _AddAction {
    my ( $Self, %Param ) = @_;

    my %Errors;
    my %GetParam;

    for my $Needed (qw(Name Label FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$GetParam{$Needed} ) {
            $Errors{ $Needed . 'ServerError' }        = 'ServerError';
            $Errors{ $Needed . 'ServerErrorMessage' } = 'Ez a mező kötelező.';
        }
    }

    if ( $GetParam{Name} ) {

        # annak ellenőrzése, hogy a név csak betűket és számokat tartalmaz-e
        if ( $GetParam{Name} !~ m{\A ( ?: [a-zA-Z] | \d )+ \z}xms ) {

            # kiszolgálóhiba hibaosztály hozzáadása
            $Errors{NameServerError} = 'ServerError';
            $Errors{NameServerErrorMessage} =
                'A mező nem csak ASCII betűket és számokat tartalmaz.';
        }

        # annak ellenőrzése, hogy a név kettőzött-e
        my %DynamicFieldsList = %{
            $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldList(
                Valid      =&gt; 0,
                ResultType =&gt; 'HASH',
                )
        };

        %DynamicFieldsList = reverse %DynamicFieldsList;

        if ( $DynamicFieldsList{ $GetParam{Name} } ) {

            # kiszolgálóhiba hibaosztály hozzáadása
            $Errors{NameServerError}        = 'ServerError';
            $Errors{NameServerErrorMessage} = 'Már létezik egy másik ugyanilyen nevű mező.';
        }
    }

    if ( $GetParam{FieldOrder} ) {

        # annak ellenőrzése, hogy a mezősorrend számszerű és pozitív-e
        if ( $GetParam{FieldOrder} !~ m{\A ( ?: \d )+ \z}xms ) {

            # kiszolgálóhiba hibaosztály hozzáadása
            $Errors{FieldOrderServerError}        = 'ServerError';
            $Errors{FieldOrderServerErrorMessage} = 'A mezőnek számnak kell lennie.';
        }
    }

    for my $ConfigParam (
        qw(
        ObjectType ObjectTypeName FieldType FieldTypeName DefaultValue ValidID ShowValue
        ValueMask
        )
        )
    {
        $GetParam{$ConfigParam} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $ConfigParam );
    }

    # kijavíthatatlan hibák
    if ( !$GetParam{ValidID} ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Szükséges: ValidID",
        );
    }

    # visszatérés a hozzáadás képernyőre, ha hibák vannak
    if (%Errors) {

        return $Self-&gt;_ShowScreen(
            %Param,
            %Errors,
            %GetParam,
            Mode =&gt; 'Add',
        );
    }

    # bizonyos beállítások elvégzése
    my $FieldConfig = {
        DefaultValue =&gt; $GetParam{DefaultValue},
        ShowValue    =&gt; $GetParam{ShowValue},
        ValueMask    =&gt; $GetParam{ValueMask} || $Self-&gt;{DefaultValueMask},
    };

    # egy új mező létrehozása
    my $FieldID = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldAdd(
        Name       =&gt; $GetParam{Name},
        Label      =&gt; $GetParam{Label},
        FieldOrder =&gt; $GetParam{FieldOrder},
        FieldType  =&gt; $GetParam{FieldType},
        ObjectType =&gt; $GetParam{ObjectType},
        Config     =&gt; $FieldConfig,
        ValidID    =&gt; $GetParam{ValidID},
        UserID     =&gt; $Self-&gt;{UserID},
    );

    if ( !$FieldID ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Nem sikerült létrehozni az új mezőt",
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;Redirect(
        OP =&gt; "Action=AdminDynamicField",
    );
}
            </pre><p>
        </p><p>
            Az <code class="code">_AddAction</code> függvény kéri le a beállítási paramétereket egy
új dinamikus mezőből, és ellenőrzi, hogy a dinamikus mező neve csak betűket
és számokat tartalmaz-e. Ez a függvény képes ellenőrizni bármilyen egyéb
paramétert is.
        </p><p>
            A <code class="literal">Name</code>, <code class="literal">Label</code>,
<code class="literal">FieldOrder</code>, <code class="literal">Validity</code> közös paraméterek
az összes dinamikus mezőnél, és ezek kötelezők. Minden egyes dinamikus
mezőnek megvan a saját különleges beállítása, amelynek tartalmaznia kell
legalább a <code class="literal">DefaultValue</code> paramétert. Ebben az esetben a
<code class="literal">ShowValue</code> és a <code class="literal">ValueMask</code>
paraméterekkel is rendelkezik a jelszómezőnél.
        </p><p>
            Ha a mező rendelkezik egy rögzített listájú értékek tárolásának
képességével, akkor azokat a <code class="literal">PossibleValues</code> paraméterben
kell tárolni a különleges beállítási kivonaton belül.
        </p><p>
            Mint más adminisztrátori modulokban, ha egy paraméter nem érvényes, akkor ez
a függvény visszatér a hozzáadás képernyőre, kiemelve a hibás űrlapmezőket.
        </p><p>
            Ha az összes paraméter helyes, akkor létrehoz egy új dinamikus mezőt.
        </p><p>
            </p><pre class="programlisting">
sub _Change {
    my ( $Self, %Param ) = @_;

    my %GetParam;
    for my $Needed (qw(ObjectType FieldType)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$Needed ) {

            return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
                Message =&gt; "Szükséges: $Needed",
            );
        }
    }

    # az objektumtípus és a mezőtípus megjelenített nevének lekérése
    my $ObjectTypeName = $Self-&gt;{ObjectTypeConfig}-&gt;{ $GetParam{ObjectType} }-&gt;{DisplayName} || '';
    my $FieldTypeName  = $Self-&gt;{FieldTypeConfig}-&gt;{ $GetParam{FieldType} }-&gt;{DisplayName}   || '';

    my $FieldID = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; 'ID' );

    if ( !$FieldID ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Azonosító szükséges",
        );
    }

    # dinamikus mező adatainak lekérése
    my $DynamicFieldData = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldGet(
        ID =&gt; $FieldID,
    );

    # érvényes dinamikus mező beállítások ellenőrzése
    if ( !IsHashRefWithData($DynamicFieldData) ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Nem sikerült lekérni az adatokat a dinamikus mezőhöz: $FieldID",
        );
    }

    my %Config = ();

    # beállítások kibontása
    if ( IsHashRefWithData( $DynamicFieldData-&gt;{Config} ) ) {
        %Config = %{ $DynamicFieldData-&gt;{Config} };
    }

    return $Self-&gt;_ShowScreen(
        %Param,
        %GetParam,
        %${DynamicFieldData},
        %Config,
        ID             =&gt; $FieldID,
        Mode           =&gt; 'Change',
        ObjectTypeName =&gt; $ObjectTypeName,
        FieldTypeName  =&gt; $FieldTypeName,
    );
}
            </pre><p>
        </p><p>
            A <code class="code">_Change</code> függvény nagyon hasonló az <code class="code">_Add</code>
függvényhez, de mivel ezt a függvényt egy meglévő mező szerkesztéséhez
használják, ellenőriznie kell a <code class="literal">FieldID</code> paramétert, és be
kell gyűjtenie a jelenlegi dinamikus mező adatait.
        </p><p>
            </p><pre class="programlisting">
sub _ChangeAction {
    my ( $Self, %Param ) = @_;

    my %Errors;
    my %GetParam;

    for my $Needed (qw(Name Label FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$GetParam{$Needed} ) {
            $Errors{ $Needed . 'ServerError' }        = 'ServerError';
            $Errors{ $Needed . 'ServerErrorMessage' } = 'Ez a mező kötelező.';
        }
    }

    my $FieldID = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; 'ID' );
    if ( !$FieldID ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Azonosító szükséges",
        );
    }

    if ( $GetParam{Name} ) {

        # annak ellenőrzése, hogy a név kisbetűs-e
        if ( $GetParam{Name} !~ m{\A ( ?: [a-zA-Z] | \d )+ \z}xms ) {

            # kiszolgálóhiba hibaosztály hozzáadása
            $Errors{NameServerError} = 'ServerError';
            $Errors{NameServerErrorMessage} =
                'A mező nem csak ASCII betűket és számokat tartalmaz.';
        }

        # annak ellenőrzése, hogy a név kettőzött-e
        my %DynamicFieldsList = %{
            $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldList(
                Valid      =&gt; 0,
                ResultType =&gt; 'HASH',
                )
        };

        %DynamicFieldsList = reverse %DynamicFieldsList;

        if (
            $DynamicFieldsList{ $GetParam{Name} } &amp;&amp;
            $DynamicFieldsList{ $GetParam{Name} } ne $FieldID
            )
        {

            # kiszolgálóhiba hibaosztály hozzáadása
            $Errors{NameServerError}        = 'ServerError';
            $Errors{NameServerErrorMessage} = 'Már létezik egy másik ugyanilyen nevű mező.';
        }
    }

    if ( $GetParam{FieldOrder} ) {

        # annak ellenőrzése, hogy a mezősorrend számszerű és pozitív-e
        if ( $GetParam{FieldOrder} !~ m{\A ( ?: \d )+ \z}xms ) {

            # add server error error class
            $Errors{FieldOrderServerError}        = 'ServerError';
            $Errors{FieldOrderServerErrorMessage} = 'A mezőnek számnak kell lennie.';
        }
    }

    for my $ConfigParam (
        qw(
        ObjectType ObjectTypeName FieldType FieldTypeName DefaultValue ValidID ShowValue
        ValueMask
        )
        )
    {
        $GetParam{$ConfigParam} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $ConfigParam );
    }

    # kijavíthatatlan hibák
    if ( !$GetParam{ValidID} ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Szükséges: ValidID",
        );
    }

    # a dinamikus mező adatainak lekérése
    my $DynamicFieldData = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldGet(
        ID =&gt; $FieldID,
    );

    # érvényes dinamikus mező beállítások ellenőrzése
    if ( !IsHashRefWithData($DynamicFieldData) ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Nem sikerült lekérni az adatokat a dinamikus mezőhöz: $FieldID",
        );
    }

    # visszatérés a változtatás képernyőhöz, ha hibák vannak
    if (%Errors) {

        return $Self-&gt;_ShowScreen(
            %Param,
            %Errors,
            %GetParam,
            ID   =&gt; $FieldID,
            Mode =&gt; 'Change',
        );
    }

    # különleges beállítások elvégzése
    my $FieldConfig = {
        DefaultValue =&gt; $GetParam{DefaultValue},
        ShowValue    =&gt; $GetParam{ShowValue},
        ValueMask    =&gt; $GetParam{ValueMask},
    };

    # dinamikus mező frissítése (a FieldType és az ObjectType nem változtatható meg; régi értékek használata)
    my $UpdateSuccess = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldUpdate(
        ID         =&gt; $FieldID,
        Name       =&gt; $GetParam{Name},
        Label      =&gt; $GetParam{Label},
        FieldOrder =&gt; $GetParam{FieldOrder},
        FieldType  =&gt; $DynamicFieldData-&gt;{FieldType},
        ObjectType =&gt; $DynamicFieldData-&gt;{ObjectType},
        Config     =&gt; $FieldConfig,
        ValidID    =&gt; $GetParam{ValidID},
        UserID     =&gt; $Self-&gt;{UserID},
    );

    if ( !$UpdateSuccess ) {

        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Nem sikerült frissíteni a mezőt: $GetParam{Name}",
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;Redirect(
        OP =&gt; "Action=AdminDynamicField",
    );
}
            </pre><p>
        </p><p>
            A <code class="code">_ChangeAction()</code> nagyon hasonló az <code class="code">_AddAction()</code>
függvényhez, de át van írva egy meglévő mező frissítéséhez egy új
létrehozása helyett.
        </p><p>
            </p><pre class="programlisting">
sub _ShowScreen {
    my ( $Self, %Param ) = @_;

    $Param{DisplayFieldName} = 'New';

    if ( $Param{Mode} eq 'Change' ) {
        $Param{ShowWarning}      = 'ShowWarning';
        $Param{DisplayFieldName} = $Param{Name};
    }

    # fejléc
    my $Output = $Self-&gt;{LayoutObject}-&gt;Header();
    $Output .= $Self-&gt;{LayoutObject}-&gt;NavigationBar();

    # az összes mező lekérése
    my $DynamicFieldList = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldListGet(
        Valid =&gt; 0,
    );

    # a sorrendszámok listájának lekérése (már rendezve van).
    my @DynamicfieldOrderList;
    for my $Dynamicfield ( @{$DynamicFieldList} ) {
        push @DynamicfieldOrderList, $Dynamicfield-&gt;{FieldOrder};
    }

    # hozzáadáskor létre kell hoznunk egy további sorrendszámot az új mezőhöz
    if ( $Param{Mode} eq 'Add' ) {

        # az utolsó elem lekérése a sorrendlistából, és 1 hozzáadása
        my $LastOrderNumber = $DynamicfieldOrderList[-1];
        $LastOrderNumber++;

        # ezen új sorrendszám hozzáadása a lista végéhez
        push @DynamicfieldOrderList, $LastOrderNumber;
    }

    my $DynamicFieldOrderSrtg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data          =&gt; \@DynamicfieldOrderList,
        Name          =&gt; 'FieldOrder',
        SelectedValue =&gt; $Param{FieldOrder} || 1,
        PossibleNone  =&gt; 0,
        Class         =&gt; 'W50pc Validate_Number',
    );

    my %ValidList = $Self-&gt;{ValidObject}-&gt;ValidList();

    # az ellenőrzés kiválasztás létrehozása
    my $ValidityStrg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data         =&gt; \%ValidList,
        Name         =&gt; 'ValidID',
        SelectedID   =&gt; $Param{ValidID} || 1,
        PossibleNone =&gt; 0,
        Translation  =&gt; 1,
        Class        =&gt; 'W50pc',
    );

    # a beállítási mezőre jellemző beállítások meghatározása
    my $DefaultValue = ( defined $Param{DefaultValue} ? $Param{DefaultValue} : '' );

    # az érték megjelenítése választás létrehozása
    my $ShowValueStrg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data =&gt; [ 'No', 'Yes' ],
        Name =&gt; 'ShowValue',
        SelectedValue =&gt; $Param{ShowValue} || 'No',
        PossibleNone  =&gt; 0,
        Translation   =&gt; 1,
        Class         =&gt; 'W50pc',
    );

    # kimenet előállítása
    $Output .= $Self-&gt;{LayoutObject}-&gt;Output(
        TemplateFile =&gt; 'AdminDynamicFieldPassword',
        Data         =&gt; {
            %Param,
            ValidityStrg          =&gt; $ValidityStrg,
            DynamicFieldOrderSrtg =&gt; $DynamicFieldOrderSrtg,
            DefaultValue          =&gt; $DefaultValue,
            ShowValueStrg         =&gt; $ShowValueStrg,
            ValueMask             =&gt; $Param{ValueMask} || $Self-&gt;{DefaultValueMask},
        },
    );

    $Output .= $Self-&gt;{LayoutObject}-&gt;Footer();

    return $Output;
}

1;
            </pre><p>
        </p><p>
            A <code class="code">_ShowScreen</code> függvényt használják egy sablonból történő HTML
elemek és blokkok beállítására és meghatározására az adminisztrátori
párbeszédablak HTML kódjának előállításához.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-template"></a>Dinamikus mező sablon az adminisztrátori párbeszédablak példához</h6></div></div></div><p>
        A sablon az a hely, ahol a párbeszédablak HTML kódja el van tárolva.
    </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-template-code"></a>Kódpélda:</h6></div></div></div><p>
                Ebben a szakaszban a jelszó dinamikus mezőhöz egy adminisztrátori
párbeszédablak sablon van megjelenítve és elmagyarázva.
            </p><p>
            </p><pre class="programlisting">
# --
# AdminDynamicFieldPassword.tt - provides HTML form for AdminDynamicFieldPassword
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --
            </pre><p>
        </p><p>
            Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban.
        </p><p>
            </p><pre class="programlisting">
&lt;div class="MainBox ARIARoleMain LayoutFixedSidebar SidebarFirst"&gt;
    &lt;h1&gt;[% Translate("Dynamic Fields") | html %] - [% Translate(Data.ObjectTypeName) | html %]: [% Translate(Data.Mode) | html %] [% Translate(Data.FieldTypeName) | html %] [% Translate("Mező") | html %]&lt;/h1&gt;

    &lt;div class="Clear"&gt;&lt;/div&gt;

    &lt;div class="SidebarColumn"&gt;
        &lt;div class="WidgetSimple"&gt;
            &lt;div class="Header"&gt;
                &lt;h2&gt;[% Translate("Műveletek") | html %]&lt;/h2&gt;
            &lt;/div&gt;
            &lt;div class="Content"&gt;
                &lt;ul class="ActionList"&gt;
                    &lt;li&gt;
                        &lt;a href="[% Env("Baselink") %]Action=AdminDynamicField" class="CallForAction"&gt;&lt;span&gt;[% Translate("Ugrás vissza az áttekintőhöz") | html %]&lt;/span&gt;&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
            </pre><p>
        </p><p>
            A kód ezen része rendelkezik a fő dobozzal és a műveletek oldalsávval
is. Nincs szükség módosításokra ebben a szakaszban.
        </p><p>
            </p><pre class="programlisting">
    &lt;div class="ContentColumn"&gt;
        &lt;form action="[% Env("CGIHandle") %]" method="post" class="Validate PreventMultipleSubmits"&gt;
            &lt;input type="hidden" name="Action" value="AdminDynamicFieldPassword" /&gt;
            &lt;input type="hidden" name="Subaction" value="[% Data.Mode | html %]Action" /&gt;
            &lt;input type="hidden" name="ObjectType" value="[% Data.ObjectType | html %]" /&gt;
            &lt;input type="hidden" name="FieldType" value="[% Data.FieldType | html %]" /&gt;
            &lt;input type="hidden" name="ID" value="[% Data.ID | html %]" /&gt;
            </pre><p>
        </p><p>
            A kód ezen szakaszában van meghatározva a párbeszédablak jobboldali
része. Figyelje meg, hogy a rejtett <code class="literal">Action</code> beviteli mező
értékének egyeznie kell az adminisztrátori párbeszédablak nevével.
        </p><p>
            </p><pre class="programlisting">
            &lt;div class="WidgetSimple"&gt;
                &lt;div class="Header"&gt;
                    &lt;h2&gt;[% Translate("Általános") | html %]&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class="Content"&gt;
                    &lt;div class="LayoutGrid ColumnsWithSpacing"&gt;
                        &lt;div class="Size1of2"&gt;
                            &lt;fieldset class="TableLike"&gt;
                                &lt;label class="Mandatory" for="Name"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; [% Translate("Név") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="Name" class="W50pc [% Data.NameServerError | html %] [% Data.ShowWarning | html %]  Validate_Alphanumeric" type="text" maxlength="200" value="[% Data.Name | html %]" name="Name"/&gt;
                                    &lt;div id="NameError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate("Ez a mező kötelező, és az értéke csak betű és szám karakter lehet.") | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="NameServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate(Data.NameServerErrorMessage) | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;[% Translate("Egyedinek kell lennie, és csak betű és szám karaktereket fogad el.") | html %]&lt;/p&gt;
                                    &lt;p class="Warning Hidden"&gt;[% Translate("Az érték megváltoztatása kézi módosításokat fog igényelni a rendszeren.") | html %]&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;label class="Mandatory" for="Label"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; [% Translate("Címke") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="Label" class="W50pc [% Data.LabelServerError | html %] Validate_Required" type="text" maxlength="200" value="[% Data.Label | html %]" name="Label"/&gt;
                                    &lt;div id="LabelError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate("Ez a mező kötelező.") | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="LabelServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate(Data.LabelServerErrorMessage) | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;[% Translate("Ez azokon a képernyőkön megjelenítendő név, ahol a mező aktív.") | html %]&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;label class="Mandatory" for="FieldOrder"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; [% Translate("Mezősorrend") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    [% Data.DynamicFieldOrderSrtg %]
                                    &lt;div id="FieldOrderError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate("Ez a mező kötelező, és csak számot tartalmazhat.") | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="FieldOrderServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;[% Translate(Data.FieldOrderServerErrorMessage) | html %]&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;[% Translate("Ez az a sorrend, amelyben ez a mező meg fog jelenni a képernyőkön, ahol aktív.") | html %]&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;
                            &lt;/fieldset&gt;
                        &lt;/div&gt;
                        &lt;div class="Size1of2"&gt;
                            &lt;fieldset class="TableLike"&gt;
                                &lt;label for="ValidID"&gt;[% Translate("Érvényesség") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    [% Data.ValidityStrg %]
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;div class="SpacingTop"&gt;&lt;/div&gt;
                                &lt;label for="FieldTypeName"&gt;[% Translate("Mezőtípus") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="FieldTypeName" readonly="readonly" class="W50pc" type="text" maxlength="200" value="[% Data.FieldTypeName | html %]" name="FieldTypeName"/&gt;
                                    &lt;div class="Clear"&gt;&lt;/div&gt;
                                &lt;/div&gt;

                                &lt;div class="SpacingTop"&gt;&lt;/div&gt;
                                &lt;label for="ObjectTypeName"&gt;[% Translate("Objektumtípus") | html %]:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="ObjectTypeName" readonly="readonly" class="W50pc" type="text" maxlength="200" value="[% Data.ObjectTypeName | html %]" name="ObjectTypeName"/&gt;
                                    &lt;div class="Clear"&gt;&lt;/div&gt;
                                &lt;/div&gt;
                            &lt;/fieldset&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            </pre><p>
        </p><p>
            Ez az első felületi elem tartalmazza a szokásos űrlapattribútumokat a
dinamikus mezőkhöz. A többi dinamikus mezővel való következetességért
javasolt a kód ezen részének változatlanul hagyása.
        </p><p>
            </p><pre class="programlisting">
            &lt;div class="WidgetSimple"&gt;
                &lt;div class="Header"&gt;
                    &lt;h2&gt;[% Translate(Data.FieldTypeName) | html %] [% Translate("Mezőbeállítások") | html %]&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class="Content"&gt;
                    &lt;fieldset class="TableLike"&gt;

                        &lt;label for="DefaultValue"&gt;[% Translate("Alapértelmezett érték") | html %]:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            &lt;input id="DefaultValue" class="W50pc" type="text" maxlength="200" value="[% Data.DefaultValue | html %]" name="DefaultValue"/&gt;
                            &lt;p class="FieldExplanation"&gt;[% Translate("Ez az alapértelmezett érték ehhez a mezőhöz.") | html %]&lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                        &lt;label for="ShowValue"&gt;[% Translate("Érték megjelenítése") | html %]:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            [% Data.ShowValueStrg %]
                            &lt;p class="FieldExplanation"&gt;
                                [% Translate("A mezőérték felfedéséhez a nem szerkesztői képernyőkön (például jegynagyítás képernyő)") | html %]
                            &lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                        &lt;label for="ValueMask"&gt;[% Translate("Rejtett értékmaszk") | html %]:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            &lt;input id="ValueMask" class="W50pc" type="text" maxlength="200" value="[% Data.ValueMask | html %]" name="ValueMask"/&gt;
                            &lt;p class="FieldExplanation"&gt;
                                [% Translate("Ez az alternatív érték annak megjelenítéséhez, ha az Érték megjelenítése „Nem” értékre van állítva (Alapértelmezett: **** ).") | html %]
                            &lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                    &lt;/fieldset&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            </pre><p>
        </p><p>
            A második felületi elem a dinamikus mezőre jellemző űrlapattribútumokkal
rendelkezik. Ez az a hely, ahol az új attribútumok beállíthatók, és
használhatnak JavaScript és AJAX technológiákat, hogy egyszerűbbé és
barátságosabbá tegyék a végfelhasználó számára.
        </p><p>
            </p><pre class="programlisting">
            &lt;fieldset class="TableLike"&gt;
                &lt;div class="Field SpacingTop"&gt;
                    &lt;button type="submit" class="Primary" value="[% Translate("Save") | html %]"&gt;[% Translate("Mentés") | html %]&lt;/button&gt;
                    [% Translate("vagy") | html %]
                    &lt;a href="[% Env("Baselink") %]Action=AdminDynamicField"&gt;[% Translate("Mégse") | html %]&lt;/a&gt;
                &lt;/div&gt;
                &lt;div class="Clear"&gt;&lt;/div&gt;
            &lt;/fieldset&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
[% WRAPPER JSOnDocumentComplete %]
&lt;script type="text/javascript"&gt;//&lt;![CDATA[
$('.ShowWarning').bind('change keyup', function (Event) {
    $('p.Warning').removeClass('Hidden');
});

Core.Agent.Admin.DynamicField.ValidationInit();
//]]&gt;&lt;/script&gt;
[% END %]
            </pre><p>
        </p><p>
            A fájl utolsó része tartalmazza a „Mentés” gombot és a „Mégse” hivatkozást,
valamint az egyéb szükséges JavaScript kódot.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-driver"></a>Dinamikus mező illesztőprogram példa</h6></div></div></div><p>
        Az illesztőprogram <span class="emphasis"><em>maga a</em></span> dinamikus mező. Számos olyan
függvényt tartalmaz, amelyet széles körben használnak az OTRS
keretrendszerben. Egy illesztőprogram örökölhet néhány függvényt az
alaposztályokból, például a <code class="literal">TextArea</code> illesztőprogram a
<code class="filename">Base.pm</code> és a <code class="filename">BaseText.pm</code> fájlokból
örökli a függvények legnagyobb részét, és csak azokat a függvényeket
valósítja meg, amelyek eltérő logikát vagy eredményeket igényelnek. A
jelölőnégyzet mező illesztőprogram csak a <code class="filename">Base.pm</code>
fájlból örököl, mivel az összes többi függvény nagyon eltérő bármely más
alap illesztőprogramtól.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
            Nézze meg a <code class="filename">/Kernel/System/DynmicField/Backend.pm</code> modul
Perl On-line Dokumentációját (POD) az összes attribútum listája és a
lehetséges visszatérési adatok megismeréséhez az egyes függvényeknél.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-driver-code"></a>Kódpélda:</h6></div></div></div><p>
            Ebben a szakaszban a jelszó dinamikus mező illesztőprogram van bemutatva és
elmagyarázva. Ez az illesztőprogram örököl néhány függvényt a
<code class="filename">Base.pm</code> és a <code class="filename">BaseText.pm</code>
fájlokból, és csak azokat a függvényeket valósítja meg, amelyek eltérő
eredményeket igényelnek.
         </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/DynamicField/Driver/Password.pm - Driver for DynamicField Password backend
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::DynamicField::Driver::Password;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);
use Kernel::System::DynamicFieldValue;

use base qw(Kernel::System::DynamicField::Driver::BaseText);

our @ObjectDependencies = (
    'Kernel::Config',
    'Kernel::System::DynamicFieldValue',
    'Kernel::System::Main',
);
            </pre><p>
        </p><p>
            Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva. Figyelje meg, hogy a <code class="literal">BaseText</code> osztályt
használják alaposztályként.
        </p><p>
            </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # új kivonat lefoglalása az objektumhoz
    my $Self = {};
    bless( $Self, $Type );

    # mezőviselkedések beállítása
    $Self-&gt;{Behaviors} = {
        'IsACLReducible'               =&gt; 0,
        'IsNotificationEventCondition' =&gt; 1,
        'IsSortable'                   =&gt; 0,
        'IsFiltrable'                  =&gt; 0,
        'IsStatsCondition'             =&gt; 1,
        'IsCustomerInterfaceCapable'   =&gt; 1,
    };

    # a dinamikus mező háttérprogram egyéni kiterjesztéseinek lekérése
    my $DynamicFieldDriverExtensions
        = $Kernel::OM-&gt;Get('Kernel::Config')-&gt;Get('DynamicFields::Extension::Driver::Password');

    EXTENSION:
    for my $ExtensionKey ( sort keys %{$DynamicFieldDriverExtensions} ) {

        # érvénytelen kiterjesztések kihagyása
        next EXTENSION if !IsHashRefWithData( $DynamicFieldDriverExtensions-&gt;{$ExtensionKey} );

        # egy kiterjesztés beállítás gyors elérésének létrehozása
        my $Extension = $DynamicFieldDriverExtensions-&gt;{$ExtensionKey};

        # annak ellenőrzése, hogy a kiterjesztésnek van-e új modulja
        if ( $Extension-&gt;{Module} ) {

            # annak ellenőrzése, hogy a modul betölthető-e
            if (
                !$Kernel::OM-&gt;Get('Kernel::System::Main')-&gt;RequireBaseClass( $Extension-&gt;{Module} )
                )
            {
                die "Nem lehet betölteni a dinamikus mezők háttérprogram modulját:"
                    . " $Extension-&gt;{Module}! $@";
            }
        }

        # annak ellenőrzése, hogy a kiterjesztés tartalmaz-e további viselkedéseket
        if ( IsHashRefWithData( $Extension-&gt;{Behaviors} ) ) {

            %{ $Self-&gt;{Behaviors} } = (
                %{ $Self-&gt;{Behaviors} },
                %{ $Extension-&gt;{Behaviors} }
            );
        }
    }

    return $Self;
}
            </pre><p>
        </p><p>
            A <code class="literal">new</code> konstruktor hozza létre az osztály új példányát. A
kódolási irányelvek szerint más osztályoknak azon objektumait kell a
<code class="literal">new</code> konstruktorban létrehozni, amelyek ebben a modulban
szükségesek.
        </p><p>
            Fontos a viselkedéseket helyesen meghatározni, mivel a mező lehet
használható vagy lehet nem használható bizonyos képernyőkön. Azokat a
függvényeket esetleg nem szükséges megvalósítani, amelyek olyan
viselkedésektől függenek, amelyek nem aktívak ennél a bizonyos mezőnél.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                Az illesztőprogramokat kizárólag a <code class="literal">BackendObject</code> hozza
létre, és nem közvetlenül bármely egyéb modulból.
            </p></div><p>
        </p><pre class="programlisting">
sub EditFieldRender {
    my ( $Self, %Param ) = @_;

    # beállítások átvétele a mezőbeállításokból
    my $FieldConfig = $Param{DynamicFieldConfig}-&gt;{Config};
    my $FieldName   = 'DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name};
    my $FieldLabel  = $Param{DynamicFieldConfig}-&gt;{Label};

    my $Value = '';

    # a mezőérték beállítása vagy alapértelmezett
    if ( $Param{UseDefaultValue} ) {
        $Value = ( defined $FieldConfig-&gt;{DefaultValue} ? $FieldConfig-&gt;{DefaultValue} : '' );
    }
    $Value = $Param{Value} if defined $Param{Value};

    # a dinamikus mező értékének kibontása a webkérésből
    my $FieldValue = $Self-&gt;EditFieldValueGet(
        %Param,
    );

    # értékek beállítása a paraméterobjektumból, ha létezik
    if ( defined $FieldValue ) {
        $Value = $FieldValue;
    }

    # osztály ellenőrzése és beállítása, ha szükséges
    my $FieldClass = 'DynamicFieldText W50pc';
    if ( defined $Param{Class} &amp;&amp; $Param{Class} ne '' ) {
        $FieldClass .= ' ' . $Param{Class};
    }

    # mező beállítása kötelezőként
    $FieldClass .= ' Validate_Required' if $Param{Mandatory};

    # hiba CSS osztály beállítása
    $FieldClass .= ' ServerError' if $Param{ServerError};

    my $HTMLString = &lt;&lt;"EOF";
&lt;input type="password" class="$FieldClass" id="$FieldName" name="$FieldName" title="$FieldLabel" value="$Value" /&gt;
EOF

    if ( $Param{Mandatory} ) {
        my $DivID = $FieldName . 'Error';

        # kliensoldali ellenőrzéshez
        $HTMLString .= &lt;&lt;"EOF";
    &lt;div id="$DivID" class="TooltipErrorMessage"&gt;
        &lt;p&gt;
            \$Text{"Ez a mező kötelező."}
        &lt;/p&gt;
    &lt;/div&gt;
EOF
    }

    if ( $Param{ServerError} ) {

        my $ErrorMessage = $Param{ErrorMessage} || 'Ez a mező kötelező.';
        my $DivID = $FieldName . 'ServerError';

        # kiszolgálóoldali ellenőrzéshez
        $HTMLString .= &lt;&lt;"EOF";
    &lt;div id="$DivID" class="TooltipErrorMessage"&gt;
        &lt;p&gt;
            \$Text{"$ErrorMessage"}
        &lt;/p&gt;
    &lt;/div&gt;
EOF
    }

    # az EditLabelRender meghívása a közös illesztőprogramon
    my $LabelString = $Self-&gt;EditLabelRender(
        %Param,
        DynamicFieldConfig =&gt; $Param{DynamicFieldConfig},
        Mandatory          =&gt; $Param{Mandatory} || '0',
        FieldName          =&gt; $FieldName,
    );

    my $Data = {
        Field =&gt; $HTMLString,
        Label =&gt; $LabelString,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            Ez a függvény felelős a mező és annak címkéje HTML ábrázolásának
létrehozásáért, és olyan szerkesztő képernyőkön használják, mint például az
<code class="literal">AgentTicketPhone</code>, <code class="literal">AgentTicketNote</code>,
stb.
        </p><p>
            </p><pre class="programlisting">
sub DisplayValueRender {
    my ( $Self, %Param ) = @_;

    # a HTMLOutput beállítása alapértelmezettként, ha nincs megadva
    if ( !defined $Param{HTMLOutput} ) {
        $Param{HTMLOutput} = 1;
    }

    my $Value;
    my $Title;

    # annak ellenőrzése, hogy a mező be van-e állítva a jelszó megjelenítéséhez vagy sem
    if (
        defined $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue}
        &amp;&amp; $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue} eq 'Yes'
        )
    {

        # a nyers Title és Value szövegek lekérése a mezőértékből
        $Value = defined $Param{Value} ? $Param{Value} : '';
        $Title = $Value;
    }
    else {

        # a maszk megjelenítése az érték helyett
        $Value = $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ValueMask} || '';
        $Title = 'A mező értéke rejtve van.'
    }

    # HTMLOutput átalakítások
    if ( $Param{HTMLOutput} ) {
        $Value = $Param{LayoutObject}-&gt;Ascii2Html(
            Text =&gt; $Value,
            Max =&gt; $Param{ValueMaxChars} || '',
        );

        $Title = $Param{LayoutObject}-&gt;Ascii2Html(
            Text =&gt; $Title,
            Max =&gt; $Param{TitleMaxChars} || '',
        );
    }
    else {
        if ( $Param{ValueMaxChars} &amp;&amp; length($Value) &gt; $Param{ValueMaxChars} ) {
            $Value = substr( $Value, 0, $Param{ValueMaxChars} ) . '...';
        }
        if ( $Param{TitleMaxChars} &amp;&amp; length($Title) &gt; $Param{TitleMaxChars} ) {
            $Title = substr( $Title, 0, $Param{TitleMaxChars} ) . '...';
        }
    }

    # visszatérési szerkezet létrehozása
    my $Data = {
        Value =&gt; $Value,
        Title =&gt; $Title,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            A <code class="code">DisplayValueRender()</code> függvény egyszerű szövegként adja vissza
a mező értékét és annak feliratát (mindkettő lefordítható). Ennél a bizonyos
példánál azt ellenőrizzük, hogy a jelszót meg kell-e mutatni, vagy egy
beállítási paraméter által előre meghatározott maszkot kell-e megjeleníteni
a dinamikus mezőben.
        </p><p>
            </p><pre class="programlisting">
sub ReadableValueRender {
    my ( $Self, %Param ) = @_;

    my $Value;
    my $Title;

    # annak ellenőrzése, hogy a mező be van-e állítva a jelszó megjelenítéséhez vagy sem
    if (
        defined $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue}
        &amp;&amp; $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue} eq 'Yes'
        )
    {

        # a nyers Title és Value szövegek lekérése a mezőértékből
        $Value = $Param{Value} // '';
        $Title = $Value;
    }
    else {

        # a maszk megjelenítése az érték helyett
        $Value = $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ValueMask} || '';
        $Title = 'A mező értéke rejtve van.'
    }

    # szövegek levágása, ha szükséges
    if ( $Param{ValueMaxChars} &amp;&amp; length($Value) &gt; $Param{ValueMaxChars} ) {
        $Value = substr( $Value, 0, $Param{ValueMaxChars} ) . '...';
    }
    if ( $Param{TitleMaxChars} &amp;&amp; length($Title) &gt; $Param{TitleMaxChars} ) {
        $Title = substr( $Title, 0, $Param{TitleMaxChars} ) . '...';
    }

    # visszatérési szerkezet létrehozása
    my $Data = {
        Value =&gt; $Value,
        Title =&gt; $Title,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            Ez a függvény hasonló a <code class="code">DisplayValueRender()</code> függvényhez, de
olyan helyeken használják, ahol nincs <code class="literal">LayoutObject</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-driver-other-functions"></a>Egyéb függvények:</h6></div></div></div><p>
            A következők olyan egyéb függvények, amelyek talán szükségesek lehetnek, ha
egy új dinamikus mező nem örököl más osztályokból. Ezen függvények teljes
kódjának megtekintéséhez nézzen bele közvetlenül a
<code class="filename">Kernel/System/DynamicField/Driver/Base.pm</code> és a
<code class="filename">Kernel/System/DynamicField/Driver/BaseText.pm</code> fájlokba.
        </p><p>
            </p><pre class="programlisting">
sub ValueGet { ... }
            </pre><p>
        </p><p>
            Ez a függvény lekéri az értéket a mezőből egy adott objektumnál. Ebben az
esetben az első szövegértéket adjuk vissza, mivel a mező egyszerre csak egy
szövegértéket tárol.
        </p><p>
            </p><pre class="programlisting">
sub ValueSet { ... }
            </pre><p>
        </p><p>
            A <code class="code">ValueSet()</code> függvényt egy dinamikus mező érték tárolásához
használják. Ebben az esetben a mező csak egy szöveg típusú értéket
tárol. Más mezők tárolhatnak egynél több értéket is a
<code class="literal">ValueText</code>, a <code class="literal">ValueDateTime</code> vagy a
<code class="literal">ValueInt</code> formátumnál.
        </p><p>
            </p><pre class="programlisting">
sub ValueDelete { ... }
            </pre><p>
        </p><p>
            Ezt a függvényt egy mező értékének törléséhez használják, amely egy bizonyos
objektumazonosítóhoz van csatolva. Például ha egy objektum példánynak
törlésére készülnek, akkor nincs oka a mezőérték tárolásának az adatbázisban
annál a bizonyos objektumpéldánynál.
        </p><p>
            </p><pre class="programlisting">
sub AllValuesDelete { ... }
            </pre><p>
        </p><p>
            Az <code class="code">AllValuesDelete()</code> függvényt az összes érték törléséhez
használják egy bizonyos dinamikus mezőből. Ez a függvény nagyon hasznos,
amikor egy dinamikus mező törlésre fog kerülni.
        </p><p>
            </p><pre class="programlisting">
sub ValueValidate { ... }
            </pre><p>
        </p><p>
            A <code class="code">ValueValidate()</code> függvényt annak ellenőrzéséhez használják,
hogy az érték megegyezik-e a típusának.
        </p><p>
            </p><pre class="programlisting">
sub SearchSQLGet { ... }
            </pre><p>
        </p><p>
            Ezt a függvényt a <code class="literal">TicketSearch</code> alapmodul használja egy
jegy kereséséhez szükséges belső lekérdezés felépítéséhez, ezt a mezőt
alapul véve keresési paraméterként.
        </p><p>
            </p><pre class="programlisting">
sub SearchSQLOrderFieldGet { ... }
            </pre><p>
        </p><p>
            A <code class="literal">SearchSQLOrderFieldGet</code> szintén egy segítő a
<code class="literal">TicketSearch</code> modulhoz. A
<code class="literal">$Param{TableAlias}</code> paramétert meg kell tartani, és a
<code class="literal">value_text</code> lecserélhető a <code class="literal">value_date</code>
vagy a <code class="literal">value_int</code> paraméterrel a mezőtől függően.
        </p><p>
            </p><pre class="programlisting">
sub EditFieldValueGet { ... }
            </pre><p>
        </p><p>
            Az <code class="code">EditFieldValueGet()</code> egy olyan függvény, amelyet az OTRS
szerkesztő képernyőin használnak, és a célja a mező értékének lekérése vagy
egy sablonból (mint például az általános ügyintéző profilból), vagy egy
webkérésből. Ez a függvény megkapja a webkérést a
<code class="literal">$Param{ParamObject}</code> paraméterben, amely az
előtétprogram-modul vagy a képernyő <code class="literal">ParamObject</code>
objektumának egy másolata.
        </p><p>
            Két visszatérési formátum létezik ennél a függvénynél. A normál, amely
egyszerűen a nyers érték, vagy egy szerkezet, amely a mezőnév =&gt;
mezőérték páros. Például egy dátum dinamikus mező normális esetben a dátumot
szövegként adja vissza, és ha egy szerkezetet kell visszaadnia, akkor a
kivonatban egy párost ad vissza a dátum minden egyes részéhez.
        </p><p>
            Ha az eredménynek egy szerkezetnek kell lennie, akkor normális esetben ezt
arra használják, hogy az értékét egy sablonban tárolja, mint például egy
általános ügyintéző profilban. Például egy dátummező számos HTML összetevőt
használ a mező felépítéséhez, mint például a „használt” jelölőnégyzetet és
kiválasztókat az évhez, hónaphoz, naphoz, stb.
        </p><p>
            </p><pre class="programlisting">
sub EditFieldValueValidate { ... }
            </pre><p>
        </p><p>
            Ennek a függvénynek biztosítania kell legalább egy metódust az
ellenőrzéshez, ha a mező üres, és hibát kell visszaadnia, ha a mező üres és
kötelező, de végrehajthat további ellenőrzéseket is a másfajta mezőknél,
mint például ha a kiválasztott lehetőség érvényes, vagy ha egy dátumnak csak
a múltban kell lennie, stb. Egy egyéni hibaüzenetet is biztosíthat.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldRender { ... }
            </pre><p>
        </p><p>
            Ezt a függvényt a jegykeresés párbeszédablak használja, és hasonló a
<code class="code">EditFieldRander()</code> függvényhez, de normális esetben egy keresési
képernyőn kisebb változtatásokat kell elvégezni az összes mezőnél. Például
ebben az esetben egy HTML szöveges beviteli mező használunk egy
jelszóbeviteli mező helyett. Más mezőkben (például legördülő mező)
többválasztósként jelenik meg azért, hogy egyszerre több érték keresését
tegye lehetővé a felhasználónak.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldValueGet { ... }
            </pre><p>
        </p><p>
            Nagyon hasonló az <code class="code">EditFieldValueGet()</code> függvényhez, de eltérő
név előtagot használ a keresési párbeszédablak képernyőhöz átírva.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldParameterBuild { ... }
            </pre><p>
        </p><p>
            A <code class="code">SearchFieldParameterBuild()</code> függvényt is a jegykeresés
párbeszédablak használja a helyes operátor és érték beállításához, hogy
elvégezze a keresést ezen a mezőn. Azt is visszaadja, hogy az értéket hogyan
kell megjeleníteni a használt keresési attribútumokban a találatok oldalon.
        </p><p>
            </p><pre class="programlisting">
sub StatsFieldParameterBuild { ... }
            </pre><p>
        </p><p>
            Ezt a függvényt a statisztikák moduljai használják. Tartalmazza a mező
meghatározást a statisztikák formátumában. A rögzített értékekkel rendelkező
mezőknél tartalmazza az összes lehetséges értéket is, és ha azok
lefordíthatók, akkor nézze meg a <code class="literal">BaseSelect</code>
illesztőprogram kódját példaként arra, hogy azokat hogyan kell
megvalósítani.
        </p><p>
            </p><pre class="programlisting">
sub StatsSearchFieldParameterBuild { ... }
            </pre><p>
        </p><p>
            A <code class="code">StatsSearchFieldParameterBuild()</code> nagyon hasonló a
<code class="code">SearchFieldParameterBuild()</code> függvényhez. A különbség az, hogy a
<code class="code">SearchFieldParameterBuild()</code> a keresési profilból kapja meg az
értéket, és ez pedig közvetlenül a paramétereiből kapja meg az értéket.
        </p><p>
            Ezt a függvényt a statisztikák modul használja.
        </p><p>
            </p><pre class="programlisting">
sub TemplateValueTypeGet { ... }
            </pre><p>
        </p><p>
            A <code class="code">TemplateValueTypeGet()</code> függvényt annak megismeréséhez
használják, hogy a dinamikus mező értékei hogyan vannak eltárolva egy olyan
profilnál, amelyet le kell kérni (SCALAR vagy ARRAY formában), és
meghatározza a mező helyes nevét is a profilban.
        </p><p>
            </p><pre class="programlisting">
sub RandomValueSet { ... }
            </pre><p>
        </p><p>
            Ezt a függvényt az <code class="filename">otrs.FillDB.pl</code> parancsfájl
használja, hogy feltöltse az adatbázist néhány teszt és véletlenszerű
adattal. A függvény által beszúrt érték nem igazán fontos. Az egyetlen
megkötés az, hogy az értéknek kompatibilisnek kell lennie a mezőérték
típusával.
        </p><p>
            </p><pre class="programlisting">
sub ObjectMatch { ... }
            </pre><p>
        </p><p>
            Az értesítési modulok használják. Ez a függvény 1-et ad vissza, ha a mező
jelen van a <code class="literal">$Param{ObjectAttributes}</code> paraméterben, és ha
megegyezik a megadott értékkel.
        </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-extend"></a>Egy dinamikus mező funkcionalitás kiterjesztés létrehozása</h4></div></div></div><p>
        Ezen folyamat bemutatásához a <span class="emphasis"><em>Foo</em></span> függvénynél egy új
dinamikus mező funkcionalitás kiterjesztés lesz hozzáadva a háttérprogram
objektumhoz, valamint a szövegmező illesztőprogramba.
    </p><p>
        A kiterjesztés létrehozásához három fájlt fogunk létrehozni: egy
beállítófájlt (XML) a modulok regisztrálásához, egy háttérprogram
kiterjesztést (Perl) az új függvény meghatározásához, és egy szövegmező
illesztőprogram kiterjesztést (Perl), amely megvalósítja az új függvényt a
szövegmezőknél.
    </p><p>
        Fájlszerkezet:
    </p><pre class="programlisting">
$HOME (például /opt/otrs/)
|
...
|--/Kernel/
|   |--/Config/
|   |   |--/Files/
|   |   |   |DynamicFieldFooExtension.xml
...
|   |--/System/
|   |   |--/DynamicField/
|   |   |   FooExtensionBackend.pm
|   |   |   |--/Driver/
|   |   |   |   |FooExtensionText.pm
...
        </pre><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extension-full-example-files"></a>Dinamikus mező Foo kiterjesztés fájlok</h5></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-config"></a>Dinamikus mező kiterjesztés beállítófájl példa</h6></div></div></div><p>
        A beállítófájlokat használják a kiterjesztések regisztrálásához a
háttérprogramnál és az illesztőprogramoknál, valamint az egyes
illesztőprogramok új viselkedéseihez.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
            Ha egy illesztőprogramot kiterjesztenek egy új függvénnyel, akkor a
háttérprogramnak is szüksége lesz egy kiterjesztésre ahhoz a függvényhez.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-config-code"></a>Kódpélda:</h6></div></div></div><p>
            Ebben a szakaszban a <code class="literal">Foo</code> kiterjesztéshez egy beállítófájl
van megjelenítve és elmagyarázva.
        </p><p>
            </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;otrs_config version="1.0" init="Application"&gt;
            </pre><p>
        </p><p>
            Ez a normál fejléc egy beállítófájlhoz.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="DynamicFields::Extension::Backend###100-Foo" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Dynamic Fields Extension.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldFooExtension&lt;/Group&gt;
        &lt;SubGroup&gt;DynamicFields::Extension::Registration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::DynamicField::FooExtensionBackend&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            Ez a beállítás regisztrálja a kiterjeszt a <code class="literal">Backend</code>
objektumban. A modul alaposztályként lesz betöltve a
<code class="literal">Backend</code> objektumból.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="DynamicFields::Extension::Driver::Text###100-Foo" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Dynamic Fields Extension.&lt;/Description&gt;
        &lt;Group&gt;DynamicFieldFooExtension&lt;/Group&gt;
        &lt;SubGroup&gt;DynamicFields::Extension::Registration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::DynamicField::Driver::FooExtensionText&lt;/Item&gt;
                &lt;Item Key="Behaviors"&gt;
                    &lt;Hash&gt;
                        &lt;Item Key="Foo"&gt;1&lt;/Item&gt;
                    &lt;/Hash&gt;
                &lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            Ez egy kiterjesztés regisztrációja a <code class="literal">Text</code> dinamikus mező
illesztőprogramban. A modul alaposztályként lesz betöltve az
illesztőprogramban. Figyeljen arra is, hogy új viselkedések is
megadhatók. Ezek a kiterjesztett viselkedések lesznek hozzáadva azokhoz a
viselkedésekhez, amelyekkel az illesztőprogram eredetileg rendelkezik, ebből
adódóan a <code class="code">HasBehavior()</code> hívásával azt ellenőrizve, hogy ezeknél
az új viselkedéseknél teljesen átlátszó legyen.
        </p><p>
            </p><pre class="programlisting">
&lt;/otrs_config&gt;
            </pre><p>
        </p><p>
            Egy beállítófájl szabványos lezárása.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-backend"></a>Dinamikus mező háttérprogram kiterjesztés példa</h6></div></div></div><p>
        A háttérprogram kiterjesztések átláthatóan lesznek betöltve magába a
háttérprogramba egy alaposztályként. A háttérprogramból az összes
meghatározott objektum és tulajdonság elérhető lesz a kiterjesztésben.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
            A háttérprogram kiterjesztésben meghatározott összes új függvényt meg kell
valósítani egy illesztőprogram kiterjesztésben.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-backend-code"></a>Kódpélda:</h6></div></div></div><p>
            Ebben a szakaszban a háttérprogramhoz készített <code class="literal">Foo</code>
kiterjesztés van megjelenítve és elmagyarázva. A kiterjesztés csak a
<code class="code">Foo()</code> függvényt határozza meg.
         </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/DynamicField/FooExtensionBackend.pm - Extension for DynamicField backend
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::DynamicField::FooExtensionBackend;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);

=head1 NAME

Kernel::System::DynamicField::FooExtensionBackend

=head1 SYNOPSIS

DynamicFields Extension for Backend

=head1 PUBLIC INTERFACE

=over 4

=cut
            </pre><p>
        </p><p>
            Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva.
        </p><p>
            </p><pre class="programlisting">
=item Foo()

Tesztelő függvény: 1-et ad vissza, ha a függvény elérhető egy dinamikus mező illesztőprogramnál.

    my $Success = $BackendObject-&gt;Foo(
        DynamicFieldConfig   =&gt; $DynamicFieldConfig,      # a dinamikus mező teljes beállítása
    );

Returns:
    $Success = 1;       # vagy undef

=cut

sub Foo {
    my ( $Self, %Param ) = @_;

    # a szükséges dolgok ellenőrzése
    for my $Needed (qw(DynamicFieldConfig)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Szükséges: $Needed!",
            );

            return;
        }
    }

    # a DynamicFieldConfig ellenőrzése (általánosan)
    if ( !IsHashRefWithData( $Param{DynamicFieldConfig} ) ) {
        $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; "A mező beállítása érvénytelen",
        );

        return;
    }

    # a DynamicFieldConfig ellenőrzése (belsőleg)
    for my $Needed (qw(ID FieldType ObjectType)) {
        if ( !$Param{DynamicFieldConfig}-&gt;{$Needed} ) {
            $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "$Needed szükséges ebben: DynamicFieldConfig!",
            );

            return;
        }
    }

    # a dinamikus mezőre jellemző háttérprogram beállítása
    my $DynamicFieldBackend = 'DynamicField' . $Param{DynamicFieldConfig}-&gt;{FieldType} . 'Object';

    if ( !$Self-&gt;{$DynamicFieldBackend} ) {
        $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; "A háttérprogram érvénytelen: $Param{DynamicFieldConfig}-&gt;{FieldType}!",
        );

        return;
    }

    # annak ellenőrzése, hogy a függvény elérhető-e
    return if !$Self-&gt;{$DynamicFieldBackend}-&gt;can('Foo');

    # a HasBehavior meghívása az adott háttérprogramnál
    return $Self-&gt;{$DynamicFieldBackend}-&gt;Foo(%Param);
}
            </pre><p>
        </p><p>
            A <code class="code">Foo()</code> függvényt kizárólag tesztelési célokra
használják. Először leellenőrzi a dinamikus mező beállításait, majd azt
ellenőrzi, hogy a dinamikus mező illesztőprogram (típus) létezik-e, és
betöltésre került-e. Annak megakadályozásához, hogy egy olyan
illesztőprogramnál történjen függvényhívás, ahol nincs meghatározva, először
azt ellenőrzi, hogy az illesztőprogram képes-e végrehajtani a függvényt,
majd végrehajtja a függvényt az illesztőprogramban az összes paramétert
átadva.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
                Lehetséges annak a lépésnek a kihagyása is, amely azt próbálja, hogy az
illesztőprogram képes-e végrehajtani a függvényt. Ennek elvégzéséhez
szükséges egy mechanizmus megvalósítása az előtétprogram modulban egy
különleges viselkedés megköveteléséhez a dinamikus mezőnél, és csak azután
hívja meg a függvényt a háttérprogram objektumban.
            </p></div></div></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-driver"></a>Dinamikus mező illesztőprogram kiterjesztés példa</h6></div></div></div><p>
        Az illesztőprogram kiterjesztések átláthatóan lesznek betöltve magába az
illesztőprogramba egy alaposztályként. Az illesztőprogramból az összes
meghatározott objektum és tulajdonság elérhető lesz a kiterjesztésben.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Megjegyzés</h3><p>
            Az illesztőprogram kiterjesztésben megvalósított összes új függvényt meg
kell határozni egy háttérprogram kiterjesztésben, mivel minden függvény a
háttérprogram objektumból kerül meghívásra.
        </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-extend-field-driver-code"></a>Kódpélda:</h6></div></div></div><p>
            Ebben a szakaszban a szövegmező illesztőprogramhoz készített
<code class="literal">Foo</code> kiterjesztés van megjelenítve és elmagyarázva. A
kiterjesztés csak a <code class="code">Foo()</code> függvényt valósítja meg.
         </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/DynamicField/Driver/FooExtensionText.pm - Extension for DynamicField Text Driver
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::DynamicField::Driver::FooExtensionText;

use strict;
use warnings;

=head1 NAME

Kernel::System::DynamicField::Driver::FooExtensionText

=head1 SYNOPSIS

DynamicFields Text Driver Extension

=head1 PUBLIC INTERFACE

This module extends the public interface of L&lt;Kernel::System::DynamicField::Backend&gt;.
Please look there for a detailed reference of the functions.

=over 4

=cut
            </pre><p>
        </p><p>
            Ez egy gyakori fejléc, amely megtalálható a szokásos OTRS modulokban. Az
osztály/csomag neve a <code class="literal">package</code> kulcsszón keresztül van
deklarálva.
        </p><p>
            </p><pre class="programlisting">
sub Foo {
    my ( $Self, %Param ) = @_;
    return 1;
}
            </pre><p>
        </p><p>
            A <code class="code">Foo()</code> függvénynek nincs különleges logikája. Csak tesztelésre
van, és mindig 1-et ad vissza.
        </p></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="email-handling-modules"></a>E-mail kezelés</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ticket-postmaster-module"></a>Jegy levelezési modul</h4></div></div></div><p>
        A levelezési modulokat a levelezési folyamat során használják. Kétféle
levelezési modul létezik: <code class="literal">PostMasterPre</code> (egy e-mail
feldolgozása után használják) és <code class="literal">PostMasterPost</code> (azután
használják, amikor egy e-mail feldolgozásra került, és az adatbázisban van).
    </p><p>
        Ha saját levelezési szűrőket szeretne létrehozni, akkor egyszerűen hozza
létre a saját modulját. Ezek a modulok a
<code class="filename">Kernel/System/PostMaster/Filter/*.pm</code> fájlokban
találhatók. Az alapértelmezett modulokért nézze meg az adminisztrátori
kézikönyvet. Mindössze két függvényre van szüksége: <code class="code">new()</code> és
<code class="code">Run()</code>.
    </p><p>
        A következőkben egy példaszerű modul található az e-mailek egyeztetéséhez és
az X-OTRS fejlécek beállításához (további információkért nézze meg a
<code class="filename">doc/X-OTRS-Headers.txt</code> fájlt).
    </p><p>
        <code class="filename">Kernel/Config/Files/MyModule.xml</code>:
    </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="PostMaster::PreFilterModule###1-Example" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Példamodul a bejövő üzenetek szűréséhez és manipulálásához.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Core::PostMaster&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::PostMaster::Filter::Example&lt;/Item&gt;
            &lt;Item Key="Match"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="From"&gt;noreply@&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
            &lt;Item Key="Set"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="X-OTRS-Ignore"&gt;yes&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
    </p><p>
        És a tényleges szűrőkód a
<code class="filename">Kernel/System/PostMaster/Filter/Example.pm</code> fájlban:
    </p><p>
        </p><pre class="programlisting">
# --
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (GPL). If you
# did not receive this file, see https://www.gnu.org/licenses/gpl-3.0.txt.
# --

package Kernel::System::PostMaster::Filter::Example;

use strict;
use warnings;

our @ObjectDependencies = (
    'Kernel::System::Log',
);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless ($Self, $Type);

    $Self-&gt;{Debug} = $Param{Debug} || 0;

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;
    # get config options
    my %Config = ();
    my %Match = ();
    my %Set = ();
    if ($Param{JobConfig} &amp;&amp; ref($Param{JobConfig}) eq 'HASH') {
        %Config = %{$Param{JobConfig}};
        if ($Config{Match}) {
            %Match = %{$Config{Match}};
        }
        if ($Config{Set}) {
            %Set = %{$Config{Set}};
        }
        }
        # match 'Match =&gt; ???' stuff
        my $Matched = '';
        my $MatchedNot = 0;
        for (sort keys %Match) {
        if ($Param{GetParam}-&gt;{$_} &amp;&amp; $Param{GetParam}-&gt;{$_} =~ /$Match{$_}/i) {
            $Matched = $1 || '1';
            if ($Self-&gt;{Debug} &gt; 1) {
                $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched!",
                );
            }
        }
        else {
            $MatchedNot = 1;
            if ($Self-&gt;{Debug} &gt; 1) {
                $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched NOT!",
                );
            }
        }
        }
        # should I ignore the incoming mail?
        if ($Matched &amp;&amp; !$MatchedNot) {
        for (keys %Set) {
            if ($Set{$_} =~ /\[\*\*\*\]/i) {
                $Set{$_} = $Matched;
            }
            $Param{GetParam}-&gt;{$_} = $Set{$_};
            $Kernel::OM-&gt;Get('Kernel::System::Log')-&gt;Log(
                Priority =&gt; 'notice',
                Message =&gt; "Set param '$_' to '$Set{$_}' (Message-ID: $Param{GetParam}-&gt;{'Message-ID'}) ",
            );
        }
    }

    return 1;
}

1;
        </pre><p>
    </p><p>
        A következő kép az e-mail feldolgozási folyamatát mutatja be.
    </p><p>
        </p><div class="figure"><a name="id-1.4.3.10.2.10.1"></a><p class="title"><b>3.4. ábra - E-mail feldolgozási folyamat</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/email-processing.png" alt="E-mail feldolgozási folyamat"></div></div></div></div><p><br class="figure-break">
    </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Vissza</a> </td><td width="20%" align="center"><a accesskey="u" href="how-to-extend-otrs.html">Fel</a></td><td width="40%" align="right"> <a accesskey="n" href="how-to-publish-extensions.html">Előre</a></td></tr><tr><td width="40%" align="left" valign="top">3. fejezet - Hogyan bővíthető az OTRS </td><td width="20%" align="center"><a accesskey="h" href="index.html">Főoldal</a></td><td width="40%" align="right" valign="top"> 4. fejezet - Hogyan tehetők közzé az OTRS kiterjesztések</td></tr></table></div></body></html>
