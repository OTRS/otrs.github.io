<html><head>
<!-- otrs.github.io -->
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="../../../../../documentation.css">
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../documentation.js"></script>
<!-- otrs.github.io -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>How to Extend it</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="OTRS 3.0 - Developer Manual"><link rel="up" href="hacking.html" title="Chapter 2. Hacking OTRS"><link rel="prev" href="hacking.html" title="Chapter 2. Hacking OTRS"><link rel="next" href="how-to-publish.html" title="How to Publish your OTRS Extensions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">How to Extend it</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="hacking.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Hacking OTRS</th><td width="20%" align="right"> <a accesskey="n" href="how-to-publish.html">Next</a></td></tr></table><hr></div><div class="section" title="How to Extend it"><div class="titlepage"><div><div><h2 class="title"><a name="how-to-extend"></a>How to Extend it</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="how-to-extend.html#idp10975696">Module Format</a></span></dt><dd><dl><dt><span class="section"><a href="how-to-extend.html#core-modules">Core Modules</a></span></dt><dd><dl><dt><span class="section"><a href="how-to-extend.html#agent-auth-module">Agent Authentication Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#auth-sync-module">Authentication Synchonisation Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#customer-auth-module">Customer Authentication Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#customer-user-preferences-module">Customer User Preferences Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#log-module">Log Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#outputfilter">Output Filter</a></span></dt><dt><span class="section"><a href="how-to-extend.html#queue-preferences-module">Queue Preferences Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#service-preferences-module">Service Preferences Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#sla-preferences-module">SLA Preferences Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#module-stats">Stats Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#module-virtualfs">Virtual Filesystem</a></span></dt><dt><span class="section"><a href="how-to-extend.html#ticketnumber-generator">Ticket Number Generator Modules</a></span></dt></dl></dd><dt><span class="section"><a href="how-to-extend.html#frontend-modules">Frontend Modules</a></span></dt><dd><dl><dt><span class="section"><a href="how-to-extend.html#module-dashboard">Dashboard Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#notify-module">Notification Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#ticket-menu-module">Ticket Menu Module</a></span></dt></dl></dd><dt><span class="section"><a href="how-to-extend.html#old-module-description">Old Module Descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="how-to-extend.html#module-navigation">Navigation Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#old-frontend-modules">Frontend Modules</a></span></dt><dt><span class="section"><a href="how-to-extend.html#module-core">Core Modules</a></span></dt><dt><span class="section"><a href="how-to-extend.html#module-customer-user">Customer User Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#module-customer-navigation">Customer Navigation Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#ticket-modules">Ticket Modules</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="how-to-extend.html#idp17352640">Object Basics</a></span></dt><dd><dl><dt><span class="section"><a href="how-to-extend.html#object-options">Object Options</a></span></dt><dt><span class="section"><a href="how-to-extend.html#search-options">Search Options</a></span></dt><dt><span class="section"><a href="how-to-extend.html#config-naming">Config Naming</a></span></dt><dt><span class="section"><a href="how-to-extend.html#config-file">Config File</a></span></dt><dt><span class="section"><a href="how-to-extend.html#navbar-setting">NavBar Settings</a></span></dt><dt><span class="section"><a href="how-to-extend.html#screen-flow">Screen flow</a></span></dt></dl></dd><dt><span class="section"><a href="how-to-extend.html#idp6465744">Writing an OTRS module for a new object</a></span></dt><dd><dl><dt><span class="section"><a href="how-to-extend.html#what-we-want-to-write">What we want to write</a></span></dt><dt><span class="section"><a href="how-to-extend.html#default-config-file">Default Config File</a></span></dt><dt><span class="section"><a href="how-to-extend.html#writing-frontend-module">Frontend Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#writing-core-module">Core Module</a></span></dt><dt><span class="section"><a href="how-to-extend.html#dtl-template-file">dtl Template File</a></span></dt><dt><span class="section"><a href="how-to-extend.html#language-file">Language File</a></span></dt><dt><span class="section"><a href="how-to-extend.html#summery">Summary</a></span></dt></dl></dd></dl></div><div class="section" title="Module Format"><div class="titlepage"><div><div><h3 class="title"><a name="idp10975696"></a>Module Format</h3></div></div></div><div class="section" title="Core Modules"><div class="titlepage"><div><div><h4 class="title"><a name="core-modules"></a>Core Modules</h4></div></div></div><div class="section" title="Agent Authentication Module"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module"></a>Agent Authentication Module</h5></div></div></div><p>
        There are several agent authentication modules (DB, LDAP and HTTPBasicAuth)
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The agent authentication modules are located under
        Kernel/System/Auth/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a simple agent auth module. Save it under Kernel/System/Auth/Simple.pm.
        You just need 3 functions: new(), GetOption() and Auth(). Return the uid, then the
        authentication is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="agent-auth-module-code"></a>Code Example</h6></div></div></div><p>
            The interface class is called Kernel::System::Auth. The example agent authentication
            may be called Kernel::System::Auth::CustomAuth. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/CustomAuth.pm - provides the CustomAuth authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# ID: CustomAuth.pm,v 1.1 2010/05/10 15:30:34 fk Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Auth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Host$Param{Count}.";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Password$Param{Count}.";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authenticate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a radius object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="agent-auth-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom agent authenticate module.
            This can be done using the perl configuration below.
            It is not recommended to use the xml configuration because you can lock
            you out via the sysconfig.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthModule'} = 'Kernel::System::Auth::CustomAuth';
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h6 class="title"><a name="agent-auth-module-use_cases"></a>Use Case Example</h6></div></div></div><p>
            Useful authentification implementation could be a soap backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="agent-auth-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>Radius</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Authentication Synchonisation Module"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module"></a>Authentication Synchonisation Module</h5></div></div></div><p>
        There is a LDAP authentication synchonisation module
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The authentication synchonisation modules are located under
        Kernel/System/Auth/Sync/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of an authentication synchonisation module.
        Save it under Kernel/System/Auth/Sync/CustomAuthSync.pm.
        You just need 2 functions: new() and Sync(). Return 1, then the
        synchonisation is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="auth-sync-module-code"></a>Code Example</h6></div></div></div><p>
            The interface class is called Kernel::System::Auth. The example agent authentication
            may be called Kernel::System::Auth::Sync::CustomAuthSync. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/Sync/CustomAuthSync.pm - provides the CustomAuthSync
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# Id: CustomAuthSync.pm,v 1.9 2010/03/25 14:42:45 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Auth::Sync::CustomAuthSync;

use strict;
use warnings;
use Net::LDAP;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject UserObject GroupObject EncodeObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

...

    return $Self;
}

sub Sync {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(User)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }
...
    return 1;
}

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="auth-sync-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom synconisation authenticate module.
            This can be done using the perl configuration below.
            It is not recommended to use the xml configuration because you can lock
            you out via the sysconfig.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthSyncModule'} = 'Kernel::System::Auth::Sync::LDAP';
        </pre><p>
        </p></div><div class="section" title="Use Case Examples"><div class="titlepage"><div><div><h6 class="title"><a name="auth-sync-module-use_cases"></a>Use Case Examples</h6></div></div></div><p>
            Useful synchonisation implementation could be a soap or radius backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="auth-sync-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>LDAP</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="auth-sync-module-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
        Please note that the synchonisation was part of the authentification class Kernel::System::Auth before framework 2.4.
        </p></div></div><div class="section" title="Customer Authentication Module"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module"></a>Customer Authentication Module</h5></div></div></div><p>
        There are several customer authentication modules (DB, LDAP and HTTPBasicAuth)
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The customer authentication modules are located under
        Kernel/System/CustomerAuth/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a simple customer auth module. Save it under Kernel/System/CustomerAuth/Simple.pm.
        You just need 3 functions: new(), GetOption() and Auth(). Return the uid, then the
        authentication is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="customer-auth-module-code"></a>Code Example</h6></div></div></div><p>
            The interface class is called Kernel::System::CustomerAuth. The example customer authentication
            may be called Kernel::System::CustomerAuth::CustomAuth. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerAuth/CustomAuth.pm - provides the custom Authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# Id: CustomAuth.pm,v 1.11 2009/09/22 15:16:05 mb Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::CustomerAuth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Host$Param{Count} in Kernel/Config.pm";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Password$Param{Count} in Kernel/Config.pm";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authentificate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a custom object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthSecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="customer-auth-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom customer authenticate module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="AuthModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to authenticate customers.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Modul zum Authentifizieren der Customer.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::CustomerAuthAuth&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/CustomerAuth/*.pm" SelectedID="Kernel::System::CustomerAuth::CustomAuth"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h6 class="title"><a name="customer-auth-module-use_cases"></a>Use Case Example</h6></div></div></div><p>
            Useful authentification implementation could be a soap backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="customer-auth-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>Radius</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Customer User Preferences Module"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module"></a>Customer User Preferences Module</h5></div></div></div><p>
        There is a DB customer-user preferences module which come with the OTRS framework.
        It is also possible to develop your own customer-user preferences modules.
        The customer-user preferences modules are located under
        Kernel/System/CustomerUser/Preferences/*.pm. For more information about their configuration see the admin manual.
        There is an example of a customer-user preferences module below.
        Save it under Kernel/System/CustomerUser/Preferences/Custom.pm.
        You just need 4 functions: new(), SearchPreferences(), SetPreferences() and GetPreferences().
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="customer-user-preferences-module-code"></a>Code Example</h6></div></div></div><p>
            The interface class is called Kernel::System::CustomerUser. The example customer-user preferences
            may be called Kernel::System::CustomerUser::Preferences::Custom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerUser/Preferences/Custom.pm - some customer user functions
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# Id: Custom.pm,v 1.20 2009/10/07 20:41:50 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::CustomerUser::Preferences::Custom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable} = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{Table}
        || 'customer_preferences';
    $Self-&gt;{PreferencesTableKey}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableKey}
        || 'preferences_key';
    $Self-&gt;{PreferencesTableValue}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableValue}
        || 'preferences_value';
    $Self-&gt;{PreferencesTableUserID}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableUserID}
        || 'user_id';

    return $Self;
}

sub SetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my $Key    = $Param{Key}    || return;
    my $Value = defined( $Param{Value} ) ? $Param{Value} : '';

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . " $Self-&gt;{PreferencesTableUserID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$UserID, \$Key ],
    );

    $Value .= 'Custom';

    # insert new data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableUserID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$UserID, \$Key, \$Value ],
    );

    return 1;
}

sub GetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my %Data;

    # get preferences

    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableUserID} = ?",
        Bind =&gt; [ \$UserID ],
    );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

sub SearchPreferences {
    my ( $Self, %Param ) = @_;

    my %UserID;
    my $Key   = $Param{Key}   || '';
    my $Value = $Param{Value} || '';

    # get preferences
    my $SQL = "SELECT $Self-&gt;{PreferencesTableUserID}, $Self-&gt;{PreferencesTableValue} "
        . " FROM "
        . " $Self-&gt;{PreferencesTable} "
        . " WHERE "
        . " $Self-&gt;{PreferencesTableKey} = '"
        . $Self-&gt;{DBObject}-&gt;Quote($Key) . "'" . " AND "
        . " LOWER($Self-&gt;{PreferencesTableValue}) LIKE LOWER('"
        . $Self-&gt;{DBObject}-&gt;Quote( $Value, 'Like' ) . "')";

    return if !$Self-&gt;{DBObject}-&gt;Prepare( SQL =&gt; $SQL );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $UserID{ $Row[0] } = $Row[1];
    }

    # return data
    return %UserID;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="customer-user-preferences-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom customer-user preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="CustomerPreferences" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the customer preference table.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Parameter für die Tabelle mit den Einstellungen für die Customer.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Customer::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::CustomerUser::Preferences::Custom&lt;/Item&gt;
            &lt;Item  Key="Params"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="Table"&gt;customer_preferences&lt;/Item&gt;
                    &lt;Item Key="TableKey"&gt;preferences_key&lt;/Item&gt;
                    &lt;Item Key="TableValue"&gt;preferences_value&lt;/Item&gt;
                    &lt;Item Key="TableUserID"&gt;user_id&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h6 class="title"><a name="customer-user-preferences-module-use_cases"></a>Use Case Example</h6></div></div></div><p>
            Useful preferences implementation could be a soap or ldap backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="customer-user-preferences-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Log Module"><div class="titlepage"><div><div><h5 class="title"><a name="log-module"></a>Log Module</h5></div></div></div><p>
There is a gobal log interface for OTRS that provides the possibility to create own log backends.
    </p><p>
Writing an own logging backend is as easy as reimplementing the Kernel::System::Log::Log() method.
    </p><div class="section" title="Code example: Kernel::System::Log::CustomFile"><div class="titlepage"><div><div><h6 class="title"><a name="log-module-code"></a>Code example: Kernel::System::Log::CustomFile</h6></div></div></div><p>
            In this small example, we'll write a little file logging backend which works similar to
            Kernel::System::Log::File, but prepends a string to each logging entry.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Log/CustomFile.pm - file log backend
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# $Id: log.xml,v 1.1 2010-08-13 08:59:28 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Log::CustomFile;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

umask "002";

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for (qw(ConfigObject EncodeObject)) {
        if ( $Param{$_} ) {
            $Self-&gt;{$_} = $Param{$_};
        }
        else {
            die "Got no $_!";
        }
    }

    # get logfile location
    $Self-&gt;{LogFile} = '/var/log/CustomFile.log';

    # set custom prefix
    $Self-&gt;{CustomPrefix} = 'CustomFileExample';

    # Fixed bug# 2265 - For IIS we need to create a own error log file.
    # Bind stderr to log file, because iis do print stderr to web page.
    if ( $ENV{SERVER_SOFTWARE} &amp;&amp; $ENV{SERVER_SOFTWARE} =~ /^microsoft\-iis/i ) {
        if ( !open STDERR, '&gt;&gt;', $Self-&gt;{LogFile} . '.error' ) {
            print STDERR "ERROR: Can't write $Self-&gt;{LogFile}.error: $!";
        }
    }

    return $Self;
}

sub Log {
    my ( $Self, %Param ) = @_;

    my $FH;

    # open logfile
    if ( !open $FH, '&gt;&gt;', $Self-&gt;{LogFile} ) {

        # print error screen
        print STDERR "\n";
        print STDERR " &gt;&gt; Can't write $Self-&gt;{LogFile}: $! &lt;&lt;\n";
        print STDERR "\n";
        return;
    }

    # write log file
    $Self-&gt;{EncodeObject}-&gt;SetIO($FH);
    print $FH '[' . localtime() . ']';
    if ( lc $Param{Priority} eq 'debug' ) {
        print $FH "[Debug][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'info' ) {
        print $FH "[Info][$Param{Module}]  $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'notice' ) {
        print $FH "[Notice][$Param{Module}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'error' ) {
        print $FH "[Error][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    else {

        # print error messages to STDERR
        print STDERR
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";

        # and of course to logfile
        print $FH
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";
    }

    # close file handle
    close $FH;
    return 1;
}

1;
        </pre><p>
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="log-module-configuration"></a>Configuration example</h6></div></div></div><p>
            To activate our custom logging module, the administrator can either set the existing
            configuration item "LogModule" manually to "Kernel::System::Log::CustomFile". To realize
            this automatically, you can provide an XML configuration file which overrides the default
            setting.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="LogModule" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Set Kernel::System::Log::CustomFile as default logging backend.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Core::Log&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/Log/*.pm" SelectedID="Kernel::System::Log::CustomFile"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use case examples"><div class="titlepage"><div><div><h6 class="title"><a name="log-module-use_cases"></a>Use case examples</h6></div></div></div><p>
Useful logging backends could be logging to a web service or to encrypted files.
        </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="log-module-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
Please note that Kernel::System::Log has other methods than Log() which cannot be reimplemented,
for example code for working with shared memory segments and log data caching.
        </p></div></div><div class="section" title="Output Filter"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter"></a>Output Filter</h5></div></div></div><p>
        Output filters allow to modify HTML on the fly. It is best practice to use output filters
        instead of modifying <code class="filename">.dtl</code> files directly.
        There are three good reasons for that.
        When the same adaption has to be applied to several frontend modules
        then the adaption only has to be implemented once.
        The second advantage is that when OTRS is upgraded
        there is a chance that the filter doesn't have to be updated, when the relevant pattern has not changed.
        When two extensions modify the same file there is a conflict during the installation of the second package.
        This conflict can be resolved by using two output filters that modify the same frontend module.
    </p><p>
        There are four different kinds of output filters. They are active at different stages of the
        generation of HTML content.
    </p><div class="section" title="FilterElementPre"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter_filterelement_pre"></a>FilterElementPre</h6></div></div></div><p>
            The content of a template can be changed by the filter before any processing by the Layout module takes place.
            This kind of filter should be used in most cases.
            Processing instructions like $Text{"..."}, $QData{"..."} can be inserted
            into the template content and they will be honored by the subsequent DTL processing.
        </p></div><div class="section" title="FilterElementPost"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter_filterelement_post"></a>FilterElementPost</h6></div></div></div><p>
            The content of a template can be changed after variable substitution and translation.
            The kind of filter should only be used when the filter needs access to translated strings
            or to substituted variables.
        </p></div><div class="section" title="FilterContent"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter_filtercontent"></a>FilterContent</h6></div></div></div><p>
            This kind of filter allows to process the complete HTML output for the request
            right before it is sent to the browser.
            This can be used for global transformations.
            But in real live there is rarely a need to use this kind of filter.
        </p></div><div class="section" title="FilterText"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter_filtertest"></a>FilterText</h6></div></div></div><p>
            This kind of output filter is a plugin for the method
            Kernel::Output::HTML::Layout::Ascii2HTML()
            and is only active when the parameter LinkFeature is set to 1.
            Thus the FilterText output filters are currently only active for the display of
            the body of plain text articles.
            Plain text articles are generated by incoming non-HTML mails
            and when OTRS is configured to not use the rich text feature in the frontend.
        </p></div><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-code"></a>Code example</h6></div></div></div><p>
            See package TemplateModule.
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-configuration"></a>Configuration example</h6></div></div></div><p>
            See package TemplateModule.
        </p></div><div class="section" title="Use Cases"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecases"></a>Use Cases</h6></div></div></div><div class="section" title="Show additional ticket attributes in AgentTicketZoom."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-10"></a>Show additional ticket attributes in AgentTicketZoom.</h6></div></div></div><p>
                All ticket attributes are passed to the AgentTicketZoom template.
                Therefore it suffices to insert e.g. the instruction $QData{"Title"} into the content.
                This can be achieved with a FilterElementPre output filter.
            </p></div><div class="section" title="Add an additional CSS file."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-20"></a>Add an additional CSS file.</h6></div></div></div><p>
                An additional CSS file can be added to all agent frontends with an FilterElementPre filter
                that only modifies <code class="filename">Header.dtl</code>.
                Therefore it suffices to insert e.g. the instruction $QData{"Title"} into the content.
                This can be achieved with a FilterElementPre output filter.
            </p></div><div class="section" title="Show the service selection as a multi level menu."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-30"></a>Show the service selection as a multi level menu.</h6></div></div></div><p>
                Use a FilterElementPost for this feature.
                The list of selectable services can be parsed from the processed template
                output. The multi level selection can be constructed from the service list and
                inserted into the template content. A FilterElementPost output filter must be used for that.
            </p></div><div class="section" title="Create links within plain text article bodies."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-40"></a>Create links within plain text article bodies.</h6></div></div></div><p>
                A biotech company uses gene names like IPI00217472 in plain text articles.
                A FilterText output filter can be used to create links to a sequence database,
                e.g. http://srs.ebi.ac.uk/srsbin/cgi-bin/wgetz?-e+[IPI-acc:IPI00217472]+-vn+2,
                for the gene names.
            </p></div><div class="section" title="Prohibit active content"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-50"></a>Prohibit active content</h6></div></div></div><p>
                There is firewall rule that disallows all active content. In order to avoid rejection by the firewall
                the HTML tag &lt;applet&gt; can be filtered with an FilterContent output filter.
            </p></div></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
            Every ElementPre and ElementPost output filter is constructed and run
            for every Template that is needed for the current request.
            Thus low performance of the output filter or a large number of filters can
            severely degrade performance.
            When that becomes an issue, the construction of
            needed objects can be done in the Run-method after the checks.
            Thus the expensive code is run only in the relevant cases.
        </p></div><div class="section" title="Best Practices"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-bestpractice"></a>Best Practices</h6></div></div></div><p>
            In order to increase flexibility the list of affected templates should be
            configurable in SysConfig.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-releases"></a>Release Availability</h6></div></div></div><p>
            The four kinds of output filters are available in OTRS 2.4.
        </p></div></div><div class="section" title="Queue Preferences Module"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module"></a>Queue Preferences Module</h5></div></div></div><p>
        There is a DB queue preferences module which come with the OTRS framework.
        It is also possible to develop your own queue preferences modules.
        The queue preferences modules are located under
        Kernel/System/Queue/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a queue preferences module.
        Save it under Kernel/System/Queue/PreferencesCustom.pm.
        You just need 3 functions: new(), QueuePreferencesSet() and QueuePreferencesGet(). Return 1, then the
        synchonisation is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="queue-preferences-module-code"></a>Code Example</h6></div></div></div><p>
            The interface class is called Kernel::System::Queue. The example queue preferences
            may be called Kernel::System::Queue::PreferencesCustom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Queue/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# Id: PreferencesCustom.pm,v 1.5 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Queue::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}        = 'queue_preferences';
    $Self-&gt;{PreferencesTableKey}     = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}   = 'preferences_value';
    $Self-&gt;{PreferencesTableQueueID} = 'queue_id';

    return $Self;
}

sub QueuePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableQueueID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key} ],
    );

    $Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableQueueID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub QueuePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if queue preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('QueuePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableQueueID} = ?",
        Bind =&gt; [ \$Param{QueueID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="queue-preferences-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom queue preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Queue::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default queue preferences module.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Standard Queue Preferences Module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Queue::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Queue::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Examples"><div class="titlepage"><div><div><h6 class="title"><a name="queue-preferences-module-use_cases"></a>Use Case Examples</h6></div></div></div><p>
            Useful preferences implementation could be a soap or radius backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="queue-preferences-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Service Preferences Module"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module"></a>Service Preferences Module</h5></div></div></div><p>
        There is a DB service preferences module which come with the OTRS framework.
        It is also possible to develop your own service preferences modules.
        The service preferences modules are located under
        Kernel/System/Service/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a service preferences module.
        Save it under Kernel/System/Service/PreferencesCustom.pm.
        You just need 3 functions: new(), ServicePreferencesSet() and ServicePreferencesGet(). Return 1, then the
        synchonisation is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="service-preferences-module-code"></a>Code Example</h6></div></div></div><p>
            The interface class is called Kernel::System::Service. The example service preferences
            may be called Kernel::System::Service::PreferencesCustom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Service/PreferencesCustom - some user functions
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# Id: PreferencesCustom.pm,v 1.2 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Service::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}          = 'service_preferences';
    $Self-&gt;{PreferencesTableKey}       = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}     = 'preferences_value';
    $Self-&gt;{PreferencesTableServiceID} = 'service_id';

    return $Self;
}

sub ServicePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableServiceID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableServiceID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub ServicePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if service preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('ServicePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableServiceID} = ?",
        Bind =&gt; [ \$Param{ServiceID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="service-preferences-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom service preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Service::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default service preferences module.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Standard Service Preferences Module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Service::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Service::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h6 class="title"><a name="service-preferences-module-use_cases"></a>Use Case Example</h6></div></div></div><p>
            Useful preferences implementation could be a soap or radius backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="service-preferences-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="SLA Preferences Module"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module"></a>SLA Preferences Module</h5></div></div></div><p>
        There is a DB sla preferences module which come with the OTRS framework.
        It is also possible to develop your own sla preferences modules.
        The sla preferences modules are located under
        Kernel/System/SLA/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a sla preferences module.
        Save it under Kernel/System/SLA/PreferencesCustom.pm.
        You just need 3 functions: new(), SLAPreferencesSet() and SLAPreferencesGet(). Return 1, then the
        synchonisation is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="sla-preferences-module-code"></a>Code Example</h6></div></div></div><p>
            The interface class is called Kernel::System::SLA. The example sla preferences
            may be called Kernel::System::SLA::PreferencesCustom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/SLA/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# Id: PreferencesCustom.pm,v 1.2 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::SLA::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}      = 'sla_preferences';
    $Self-&gt;{PreferencesTableKey}   = 'preferences_key';
    $Self-&gt;{PreferencesTableValue} = 'preferences_value';
    $Self-&gt;{PreferencesTableSLAID} = 'sla_id';

    return $Self;
}

sub SLAPreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableSLAID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableSLAID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub SLAPreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if service preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('SLAPreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableSLAID} = ?",
        Bind =&gt; [ \$Param{SLAID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="sla-preferences-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom sla preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="SLA::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default sla preferences module.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Standard SLA Preferences Module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::SLA::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::SLA::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h6 class="title"><a name="sla-preferences-module-use_cases"></a>Use Case Example</h6></div></div></div><p>
            Useful preferences implementation could be a soap or radius backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="sla-preferences-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Stats Module"><div class="titlepage"><div><div><h5 class="title"><a name="module-stats"></a>Stats Module</h5></div></div></div><p>
There are two different types of internal stats modules - dynamic and static. This section describes how such stats modules can be developed.
    </p><div class="section" title="Dynamic Stats"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic"></a>Dynamic Stats</h6></div></div></div><p>
In contrast to static stats modules, dynamic statistics can be configured via the OTRS web interface. In this section a simple statistic module is developed. Each dynamic stats module has to implement these subroutines
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>GetObjectName</p></li><li class="listitem"><p>GetObjectAttributes</p></li><li class="listitem"><p>ExportWrapper</p></li><li class="listitem"><p>ImportWrapper</p></li></ul></div><p>
        </p><p>
Furthermore the module has to implement either GetStatElement or GetStatTable. And if the header line of the result table should be changed, a sub called GetHeaderLine has to be developed.
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-subroutines"></a>Code example</h6></div></div></div><p>
In this section a sample stats module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];
                </pre><p>
            </p><p>
This is common boilerplate that can be found in common OTRS modules. The class/package name is declared via the package keyword. Then the needed modules are 'use'd.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # created needed objects
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
new is the constructor for this statistic module. It creates a new instance of the class. According to the coding guidelines objects of other classes that are needed in this module have to be created in "new". In lines 27 to 29 the object of the stats module is created. Lines 31 to 37 check if objects that are needed in this code - either for creating other objects or in this module - are passed. After that the other objects are created.
            </p><p>
                </p><pre class="programlisting">
sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Sample Statistics';
}
                </pre><p>
            </p><p>
GetObjectName returns a Name for the Statistics module. This is the label that is shown in the drop down in the configuration as well as in the list of existing statistics (column "object").
            </p><p>
                </p><pre class="programlisting">
sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # get state list
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # get queue list
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # get current time to fix bug#3830
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'State',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Create Time',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}
                </pre><p>
            </p><p>
In this sample stats module, we want to provide three attributes the user can chose from: A list of queues, a list of states an a time drop down. To get the values shown in the drop down, some operations are needed. In this case call StateList and GetAllQueues.
            </p><p>
Then the list of attributes is created. Each attribute is defined via a hashreference. You can use these keys:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Name</p><p>the label in the web interface</p></li><li class="listitem"><p>UseAsXvalue</p><p>Can this attribute be used on the x-axis</p></li><li class="listitem"><p>UseAsValueSeries</p><p>Can this attribute be used on the y-axis</p></li><li class="listitem"><p>UseAsRestriction</p><p>Can this attribute be used for restrictions.</p></li><li class="listitem"><p>Element</p><p>the HTML fieldname</p></li><li class="listitem"><p>Block</p><p>the block name in the template file (e.g. &lt;OTRS_HOME&gt;/Kernel/Output/HTML/Standard/AgentStatsEditXaxis.dtl)</p></li><li class="listitem"><p>Values</p><p>the values shown in the attribute</p></li></ul></div><p>
            </p><p>
Hint: If you install this sample an you configured a statistic with some queues - lets say 'queue A' and 'queue B' - then these queues are the only ones that are shown to the user when he starts the statistic. Sometimes a dynamic drop down or multiselect field is needed. In this case, you can set "SelectedValues" in the definition of the attribute:
            </p><p>
                </p><pre class="programlisting">
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
            SelectedValues   =&gt; [ @SelectedQueues ],
        },
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # search tickets
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}
                </pre><p>
            </p><p>
GetStatElement gets called for each cell in the result table. So it should be a numeric value. In this sample it does a simple ticket search. The hash %Param contains information about the "current" x-value and the y-value as well as any restrictions. So, for a cell that should count the created tickets for queue 'Misc' with state 'open' the passed parameter hash looks something like this:
            </p><p>
                </p><pre class="programlisting">
    'CreatedQueueIDs' =&gt; [
        '4'
    ],
    'StateIDs' =&gt; [
        '2'
    ]
                </pre><p>
            </p><p>
If the "per cell" calculation should be avoided, GetStatTable is an alternative. GetStatTable returns a list of rows, hence an array of arrayreferences. This leads to the same result as using GetStatElement
            </p><p>
                </p><pre class="programlisting">
sub GetStatTable {
    my ( $Self, %Param ) = @_;

    my @StatData;

    for my $StateName ( keys %{ $Param{TableStructure} } ) {
        my @Row;
        for my $Params ( @{ $Param{TableStructure}-&gt;{$StateName} } ) {
            my $Tickets = $Self-&gt;{TicketObject}-&gt;TicketSearch(
                UserID     =&gt; 1,
                Result     =&gt; 'COUNT',
                Permission =&gt; 'ro',
                Limit      =&gt; 100_000_000,
                %{$Params},
            );

            push @Row, $Tickets;
        }

        push @StatData, [ $StateName, @Row ];
    }

    return @StatData;
}
                </pre><p>
            </p><p>
GetStatTable gets all information about the stats query that is needed. The passed parameters contains information about the attributes (Restrictions, attributes that are used for x/y-axis) and the table structure. The table structure is a hash reference where the keys are the values of the y-axis and their values are hashreferences with the parameters used for GetStatElement subroutines.
            </p><p>
                </p><pre class="programlisting">
    'Restrictions' =&gt; {},
    'TableStructure' =&gt; {
        'closed successful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '2'
                ]
            },
        ],
        'closed unsuccessful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '3'
                ]
            },
        ],
    },
    'ValueSeries' =&gt; [
        {
            'Block' =&gt; 'MultiSelectField',
            'Element' =&gt; 'StateIDs',
            'Name' =&gt; 'State',
            'SelectedValues' =&gt; [
                '5',
                '3',
                '2',
                '1',
                '4'
            ],
            'Translation' =&gt; 1,
            'Values' =&gt; {
                '1' =&gt; 'new',
                '10' =&gt; 'closed with workaround',
                '2' =&gt; 'closed successful',
                '3' =&gt; 'closed unsuccessful',
                '4' =&gt; 'open',
                '5' =&gt; 'removed',
                '6' =&gt; 'pending reminder',
                '7' =&gt; 'pending auto close+',
                '8' =&gt; 'pending auto close-',
                '9' =&gt; 'merged'
            }
        }
    ],
    'XValue' =&gt; {
        'Block' =&gt; 'MultiSelectField',
        'Element' =&gt; 'CreatedQueueIDs',
        'Name' =&gt; 'Created in Queue',
        'SelectedValues' =&gt; [
            '3',
            '4',
            '1',
            '2'
        ],
        'Translation' =&gt; 0,
        'Values' =&gt; {
            '1' =&gt; 'Postmaster',
            '2' =&gt; 'Raw',
            '3' =&gt; 'Junk',
            '4' =&gt; 'Misc'
        }
    }
                </pre><p>
            </p><p>
Sometimes the headers of the table have to be changed. In that case, a subroutine called GetHeaderLine has to be implemented. That subroutine has to return an arrayreference with the column headers as elements. It gets information about the x-values passed.
            </p><p>
                </p><pre class="programlisting">
sub GetHeaderLine {
    my ( $Self, %Param ) = @_;

    my @HeaderLine = ('');
    for my $SelectedXValue ( @{ $Param{XValue}-&gt;{SelectedValues} } ) {
        push @HeaderLine, $Param{XValue}-&gt;{Values}-&gt;{$SelectedXValue};
    }

    return \@HeaderLine;
}
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap ids to used spelling
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}
                </pre><p>
            </p><p>
Configured statistics can be exported into XML format. But as queues with the same queue names can have different IDs on different OTRS instances it would be quite painful to export the IDs (the statistics would calculate the wrong numbers then). So an export wrapper should be written to use the names instead of ids. This should be done for each "dimension" of the stats module (x-axis, y-axis and restrictions).
            </p><p>
ImportWrapper works the other way around - it converts the name to the ID in the instance the configuration is imported to.
            </p><p>
This is a sample export:
            </p><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;otrs_stats&gt;
&lt;Cache&gt;0&lt;/Cache&gt;
&lt;Description&gt;Sample stats module&lt;/Description&gt;
&lt;File&gt;&lt;/File&gt;
&lt;Format&gt;CSV&lt;/Format&gt;
&lt;Format&gt;Print&lt;/Format&gt;
&lt;Object&gt;DeveloperManualSample&lt;/Object&gt;
&lt;ObjectModule&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/ObjectModule&gt;
&lt;ObjectName&gt;Sample Statistics&lt;/ObjectName&gt;
&lt;Permission&gt;stats&lt;/Permission&gt;
&lt;StatType&gt;dynamic&lt;/StatType&gt;
&lt;SumCol&gt;0&lt;/SumCol&gt;
&lt;SumRow&gt;0&lt;/SumRow&gt;
&lt;Title&gt;Sample 1&lt;/Title&gt;
&lt;UseAsValueSeries Element="StateIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;removed&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed unsuccessful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed successful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;new&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;open&lt;/SelectedValues&gt;
&lt;/UseAsValueSeries&gt;
&lt;UseAsXvalue Element="CreatedQueueIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;Junk&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Misc&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Postmaster&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Raw&lt;/SelectedValues&gt;
&lt;/UseAsXvalue&gt;
&lt;Valid&gt;1&lt;/Valid&gt;
&lt;/otrs_stats&gt;
                </pre><p>
            </p><p>
Now, that all subroutines are explained, this is the complete sample stats module.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # created needed objects
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}

sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Sample Statistics';
}

sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # get state list
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # get queue list
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # get current time to fix bug#3830
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'State',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Create Time',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}

sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # search tickets
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}

sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap ids to used spelling
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}

sub ImportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap used spelling to ids
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    if ( $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} ) ) {
                        $ID-&gt;{Content}
                            = $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} );
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find the queue $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;

                    my %State = $Self-&gt;{StateObject}-&gt;StateGet(
                        Name  =&gt; $ID-&gt;{Content},
                        Cache =&gt; 1,
                    );
                    if ( $State{ID} ) {
                        $ID-&gt;{Content} = $State{ID};
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find state $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
        }
    }
    return \%Param;
}

1;
                </pre><p>
            </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-configuration"></a>Configuration example</h6></div></div></div><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;otrs_config version="1.0" init="Config"&gt;
    &lt;ConfigItem Name="Stats::DynamicObjectRegistration###DynamicStatsTemplate" Required="0" Valid="1"&gt;
        &lt;Description Lang="en"&gt;Here you can decide if the common stats module may generate stats about the number of default tickets a requester created.&lt;/Description&gt;
        &lt;Group&gt;Framework&lt;/Group&gt;
        &lt;SubGroup&gt;Core::Stats&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
&lt;/otrs_config&gt;
                </pre><p>
            </p></div><div class="section" title="Use case examples"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-use_cases"></a>Use case examples</h6></div></div></div><p>
Use cases.
            </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
If you have a lot of cells in the result table and the GetStatElement is quite complex, the request can take a long time.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-releases"></a>Release Availability</h6></div></div></div><p>
Dynamic stat modules are available since OTRS 2.0.
            </p></div></div><div class="section" title="Static Stats"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static"></a>Static Stats</h6></div></div></div><p>
The subsequent paragraphs describe the static stats. Static stats are very easy to create as these modules have to implement only three subroutines.
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>Param</p></li><li class="listitem"><p>Run</p></li></ul></div><p>
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-subroutines"></a>Code example</h6></div></div></div><p>
The following paragraphs describe the subroutines needed in a static stats.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # check all needed objects
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed";
    }

    # create needed objects
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
new creates a new instance of the static stats class. First it creates a new object and then it checks for the needed objects.
            </p><p>
                </p><pre class="programlisting">
sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}
                </pre><p>
            </p><p>
The Param method provides the list of all parameters/attributes that can be selected to create a static stat. It gets some parameters passed: The values for the stats attributes provided in a request, the format of the stats and the name of the object (name of the module).
            </p><p>
The parameters/attributes have to be hashreferences with these key-value-pairs.
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Frontent</p><p>the label in the web interface</p></li><li class="listitem"><p>Name</p><p>the HTML fieldname</p></li><li class="listitem"><p>Data</p><p>the values shown in the attribute</p></li></ul></div><p>
            </p><p>
Other parameter for the BuildSelection method of the LayoutObject can be used, as it is done with "Size" and "Multiple" in this sample module.
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );
            return;
        }
    }

    # set report title
    my $Title = 'Tickets per Queue';

    # table headlines
    my @HeadData = (
        'Ticket Number',
        'Queue',
        'Type',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}
                </pre><p>
            </p><p>
The Run method actually generates the table data for the stats. It gets the attributes for this stats passed. In this sample it in %Param a key 'TypeIDs' and a key 'QueueIDs' exist (see attributes in Param method) and their values are arrayreferences. The returned data consists of three parts: Two arrayreferences and an array. In the first arrayreference the title for the statistic is stored, the second arrayreference contains the headlines for the columns in the table. And then the data for the table body follow.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Static/StaticStatsTemplate.pm
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Stats::Static::StaticStatsTemplate;

use strict;
use warnings;

use Kernel::System::Type;
use Kernel::System::Ticket;
use Kernel::System::Queue;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

=head1 NAME

StaticStatsTemplate.pm - the module that creates the stats about tickets in a queue

=head1 SYNOPSIS

All functions

=head1 PUBLIC INTERFACE

=over 4

=cut

=item new()

create an object

    use Kernel::Config;
    use Kernel::System::Encode;
    use Kernel::System::Log;
    use Kernel::System::Main;
    use Kernel::System::Time;
    use Kernel::System::DB;
    use Kernel::System::Stats::Static::StaticStatsTemplate;

    my $ConfigObject = Kernel::Config-&gt;new();
    my $EncodeObject = Kernel::System::Encode-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $LogObject    = Kernel::System::Log-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $MainObject = Kernel::System::Main-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $TimeObject = Kernel::System::Time-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $DBObject = Kernel::System::DB-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
    );
    my $StatsObject = Kernel::System::Stats::Static::StaticStatsTemplate-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
        TimeObject   =&gt; $TimeObject,
        DBObject     =&gt; $DBObject,
        EncodeObject =&gt; $EncodeObject,
    );

=cut

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # check all needed objects
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed";
    }

    # create needed objects
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}

=item Param()

Get all parameters a user can specify.

    my @Params = $StatsObject-&gt;Param();

=cut

sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}

=item Run()

generate the statistic.

    my $StatsInfo = $StatsObject-&gt;Run(
        TypeIDs  =&gt; [
            1, 2, 4
        ],
        QueueIDs =&gt; [
            3, 4, 6
        ],
    );

=cut

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );
            return;
        }
    }

    # set report title
    my $Title = 'Tickets per Queue';

    # table headlines
    my @HeadData = (
        'Ticket Number',
        'Queue',
        'Type',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}

1;

=back

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (http://otrs.org/).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see http://www.gnu.org/licenses/agpl.txt.

=head1 VERSION

$Revision: 1.1 $ $Date: 2010-08-13 08:59:28 $

=cut
                </pre><p>
            </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-configuration"></a>Configuration example</h6></div></div></div><p>
There is no configuration needed. Right after installation, the module is available to create a statistic for this module.
            </p></div><div class="section" title="Use case examples"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-use_cases"></a>Use case examples</h6></div></div></div><p>
Use cases.
            </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
Caveats and Warnings for static stats.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-releases"></a>Release Availability</h6></div></div></div><p>
Static stat modules are available since OTRS 1.3.
            </p></div><div class="section" title="Using old static stats"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-using-old-stats"></a>Using old static stats</h6></div></div></div><p>
Standard OTRS versions 1.3 and 2.0 already facilitated the generation of stats.
Various stats for OTRS versions 1.3 and 2.0 which have been specially
developed to meet customers' requirements can be used in more recent versions too.
            </p><p>
The files must merely be moved from the
<code class="filename">Kernel/System/Stats/</code> path to
<code class="filename">Kernel/System/Stats/Static/</code>. Additionally
the package name of the respective script must be amended by
"::Static".
            </p><p>
The following example shows how the first path is amended.
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::AccountedTime;
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::Static::AccountedTime;
                </pre><p>
            </p></div></div></div><div class="section" title="Virtual Filesystem"><div class="titlepage"><div><div><h5 class="title"><a name="module-virtualfs"></a>Virtual Filesystem</h5></div></div></div><p>
The virtual filesystem is a layer to save files in a transparent way. This layer hides the logic how and where to save a file. In the subsequent paragraphs it is described how to write a new backend for the virtual filesystem. Currently two backends exist: DB and FS. The DB backend saves all files in the database and the FS backend saves the files in the "normal" filesystem.
    </p><p>
The backend developed in this chapter uses a PDF file as a filesystem.
    </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="module-virtualfs-code"></a>Code example</h6></div></div></div><p>
            </p><pre class="programlisting">

            </pre><p>
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="module-virtualfs-configuration"></a>Configuration example</h6></div></div></div><p>
            </p><pre class="programlisting">

            </pre><p>
        </p></div><div class="section" title="Use case examples"><div class="titlepage"><div><div><h6 class="title"><a name="module-virtualfs-use_cases"></a>Use case examples</h6></div></div></div><p>
List of technical and subject-specific use cases.
        </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="module-virtualfs-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
A warning for the use of the DB backend. If you save all files in the database, the database can become quite big. This can impact database backups and recovery time.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="module-virtualfs-releases"></a>Release Availability</h6></div></div></div><p>
List of known releases.
        </p></div></div><div class="section" title="Ticket Number Generator Modules"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator"></a>Ticket Number Generator Modules</h5></div></div></div><p>
        Ticket number generators are used to create distinct identifiers aka TicketNumber for
        new tickets.
        Any method of creating a string of numbers is possible, you should use common sense about
        the length of the resulting string (guideline: 5-10).
        When creating a ticket number, make sure the result is prefixed by the SysConfig-Variable
        SystemID in order to enable the detection of ticket numbers on inbound email responses.
        A ticket number generator module needs the two functions TicketCreateNumber() and
        GetTNByString().
        The method TicketCreateNumber() is called without parameters and returns the new ticket
        number.
        The method GetTNByString() is called with the param String which contains the string to be
        parsed for a ticket number and returns the ticket number if found.
    </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-code"></a>Code example</h6></div></div></div><p>
            See Kernel/System/Ticket/Number/UserRandom.pm in the package TemplateModule.
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-configuration"></a>Configuration example</h6></div></div></div><p>
            See Kernel/Config/Files/TicketNumberGenerator.xml in the package TemplateModule.
        </p></div><div class="section" title="Use Cases"><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-usecases"></a>Use Cases</h6></div></div></div><div class="section" title="Ticket numbers should follow a specific scheme."><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-usecase-10"></a>Ticket numbers should follow a specific scheme.</h6></div></div></div><p>
                You will need to create a new ticket number generator if the default modules don't
                provide the ticket number scheme you'd like to use.
            </p></div></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
            You should stick to the code of GetTNByString() as used in existing ticket number
            generators to prevent problems with ticket number parsing.
            Also the routine to detect a loop in TicketCreateNumber() should be kept intact to
            prevent duplicate ticket numbers.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-releases"></a>Release Availability</h6></div></div></div><p>
            Ticket number generators have been available in OTRS since OTRS 1.1.
        </p></div></div></div><div class="section" title="Frontend Modules"><div class="titlepage"><div><div><h4 class="title"><a name="frontend-modules"></a>Frontend Modules</h4></div></div></div><div class="section" title="Dashboard Module"><div class="titlepage"><div><div><h5 class="title"><a name="module-dashboard"></a>Dashboard Module</h5></div></div></div><p>
Dashboard module to display statistics in the form of a line graph.
        </p><p>
            </p><div class="screenshot"><div><img src="screenshots/dashboard.png"></div></div><p>
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/DashboardTicketStatsGeneric.pm - message of the day
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# $Id: dashboard.xml,v 1.1 2010-08-13 08:59:28 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::DashboardTicketStatsGeneric;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # get needed objects
    for (
        qw(Config Name ConfigObject LogObject DBObject LayoutObject ParamObject TicketObject UserID)
        )
    {
        die "Got no $_!" if !$Self-&gt;{$_};
    }

    return $Self;
}

sub Preferences {
    my ( $Self, %Param ) = @_;

    return;
}

sub Config {
    my ( $Self, %Param ) = @_;

    my $Key = $Self-&gt;{LayoutObject}-&gt;{UserLanguage} . '-' . $Self-&gt;{Name};
    return (
        %{ $Self-&gt;{Config} },
        CacheKey =&gt; 'TicketStats' . '-' . $Self-&gt;{UserID} . '-' . $Key,
    );

}

sub Run {
    my ( $Self, %Param ) = @_;

    my %Axis = (
        '7Day' =&gt; {
            0 =&gt; { Day =&gt; 'Sun', Created =&gt; 0, Closed =&gt; 0, },
            1 =&gt; { Day =&gt; 'Mon', Created =&gt; 0, Closed =&gt; 0, },
            2 =&gt; { Day =&gt; 'Tue', Created =&gt; 0, Closed =&gt; 0, },
            3 =&gt; { Day =&gt; 'Wed', Created =&gt; 0, Closed =&gt; 0, },
            4 =&gt; { Day =&gt; 'Thu', Created =&gt; 0, Closed =&gt; 0, },
            5 =&gt; { Day =&gt; 'Fri', Created =&gt; 0, Closed =&gt; 0, },
            6 =&gt; { Day =&gt; 'Sat', Created =&gt; 0, Closed =&gt; 0, },
        },
    );

    my @Data;
    my $Max = 1;
    for my $Key ( 0 .. 6 ) {

        my $TimeNow = $Self-&gt;{TimeObject}-&gt;SystemTime();
        if ($Key) {
            $TimeNow = $TimeNow - ( 60 * 60 * 24 * $Key );
        }
        my ( $Sec, $Min, $Hour, $Day, $Month, $Year, $WeekDay )
            = $Self-&gt;{TimeObject}-&gt;SystemTime2Date(
            SystemTime =&gt; $TimeNow,
            );

        $Data[$Key]-&gt;{Day} = $Self-&gt;{LayoutObject}-&gt;{LanguageObject}-&gt;Get(
            $Axis{'7Day'}-&gt;{$WeekDay}-&gt;{Day}
        );

        my $CountCreated = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCreateTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCreateTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Created} = $CountCreated;
        if ( $CountCreated &gt; $Max ) {
            $Max = $CountCreated;
        }

        my $CountClosed = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCloseTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCloseTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Closed} = $CountClosed;
        if ( $CountClosed &gt; $Max ) {
            $Max = $CountClosed;
        }
    }

    @Data = reverse @Data;
    my $Source = $Self-&gt;{LayoutObject}-&gt;JSON(
        Data =&gt; \@Data,
    );

    my $Content = $Self-&gt;{LayoutObject}-&gt;Output(
        TemplateFile =&gt; 'AgentDashboardTicketStats',
        Data         =&gt; {
            %{ $Self-&gt;{Config} },
            Key    =&gt; int rand 99999,
            Max    =&gt; $Max,
            Source =&gt; $Source,
        },
    );

    return $Content;
}

1;
        </pre><p>
        </p><p>
To use this module add the following to the <code class="filename">Kernel/Config.pm</code>
and restart your webserver (if you use mod_perl).
        </p><pre class="programlisting">
&lt;ConfigItem Name="DashboardBackend###0250-TicketStats" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the dashboard backend. "Group" are used to restriced access to the plugin (e. g. Group: admin;group1;group2;). "Default" means if the plugin is enabled per default or if the user needs to enable it manually. "CacheTTL" means the cache time in minutes for the plugin.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Parameter f�r das Dashboard Backend. "Group" ist verwendet um den Zugriff auf das Plugin einzuschr�nken (z. B. Group: admin;group1;group2;). ""Default" bedeutet ob das Plugin per default aktiviert ist oder ob dies der Anwender manuell machen muss. "CacheTTL" ist die Cache-Zeit in Minuten nach der das Plugin erneut aufgerufen wird.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Dashboard&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::DashboardTicketStatsGeneric&lt;/Item&gt;
            &lt;Item Key="Title"&gt;7 Day Stats&lt;/Item&gt;
            &lt;Item Key="Created"&gt;1&lt;/Item&gt;
            &lt;Item Key="Closed"&gt;1&lt;/Item&gt;
            &lt;Item Key="Permission"&gt;rw&lt;/Item&gt;
            &lt;Item Key="Block"&gt;ContentSmall&lt;/Item&gt;
            &lt;Item Key="Group"&gt;&lt;/Item&gt;
            &lt;Item Key="Default"&gt;1&lt;/Item&gt;
            &lt;Item Key="CacheTTL"&gt;45&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="dashboard-module-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
An excessive number of days or individual lines may lead to performance degradation.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="dashboard-module-releases"></a>Release Availability</h6></div></div></div><p>
from 2.4.0
            </p></div></div><div class="section" title="Notification Module"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module"></a>Notification Module</h5></div></div></div><p>
        Notification modules are used to display a notification below the
        main navigation. You can write and register your own notification
        module.
        There are currently 5 ticket menues in the OTRS framework.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>AgentOnline</p></li><li class="listitem"><p>AgentTicketEscalation</p></li><li class="listitem"><p>CharsetCheck</p></li><li class="listitem"><p>CustomerOnline</p></li><li class="listitem"><p>UIDCheck</p></li></ul></div><p>
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="notify-module-code"></a>Code Example</h6></div></div></div><p>
            The notification modules are located under
            Kernel/Output/HTML/TicketNotification*.pm.
            There is an example of a notify module below.
            Save it under Kernel/Output/HTML/TicketNotificationCustom.pm.
            You just need 2 functions: new() and Run().
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/NotificationCustom.pm
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# $Id: notify.xml,v 1.1 2010-08-13 08:59:28 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::NotificationCustom;

use strict;
use warnings;

use Kernel::System::Custom;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject TimeObject UserID)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }
    $Self-&gt;{CustomObject} = Kernel::System::Custom-&gt;new(%Param);
    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # get session info
    my %CustomParam      = ();
    my @Customs    = $Self-&gt;{CustomObject}-&gt;GetAllCustomIDs();
    my $IdleMinutes = $Param{Config}-&gt;{IdleMinutes} || 60 * 2;
    for (@Customs) {
        my %Data = $Self-&gt;{CustomObject}-&gt;GetCustomIDData( CustomID =&gt; $_, );
        if (
            $Self-&gt;{UserID} ne $Data{UserID}
            &amp;&amp; $Data{UserType} eq 'User'
            &amp;&amp; $Data{UserLastRequest}
            &amp;&amp; $Data{UserLastRequest} + ( $IdleMinutes * 60 ) &gt; $Self-&gt;{TimeObject}-&gt;SystemTime()
            &amp;&amp; $Data{UserFirstname}
            &amp;&amp; $Data{UserLastname}
            )
        {
            $CustomParam{ $Data{UserID} } = "$Data{UserFirstname} $Data{UserLastname}";
            if ( $Param{Config}-&gt;{ShowEmail} ) {
                $CustomParam{ $Data{UserID} } .= " ($Data{UserEmail})";
            }
        }
    }
    for ( sort { $CustomParam{$a} cmp $CustomParam{$b} } keys %CustomParam ) {
        if ( $Param{Message} ) {
            $Param{Message} .= ', ';
        }
        $Param{Message} .= "$CustomParam{$_}";
    }
    if ( $Param{Message} ) {
        return $Self-&gt;{LayoutObject}-&gt;Notify( Info =&gt; 'Custom Message: %s", "' . $Param{Message} );
    }
    else {
        return '';
    }
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="notify-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom notification module.
            This can be done using the xml configuration below. There may
            be additional parameters in the config hash for your notification
            module.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Frontend::NotifyModule###3-Custom" Required="0" Valid="0"&gt;
    &lt;Description Lang="en"&gt;Module to show custom message in the agent interface.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Mit diesem Modul können eigene Meldungenen innerhalb des Agent-Interfaces angezeigt werden.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::ModuleNotify&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::NotificationCustom&lt;/Item&gt;
            &lt;Item Key="Key1"&gt;1&lt;/Item&gt;
            &lt;Item Key="Key2"&gt;2&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h6 class="title"><a name="notify-module-use_cases"></a>Use Case Example</h6></div></div></div><p>
            Useful ticket menu implementation could be a link to a external
            tool if parameters (e.g. FreeTextField) have been set.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="notify-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>NotificationAgentOnline</td><td>2.0</td></tr><tr><td>NotificationAgentTicketEscalation</td><td>2.0</td></tr><tr><td>NotificationCharsetCheck</td><td>1.2</td></tr><tr><td>NotificationCustomerOnline</td><td>2.0</td></tr><tr><td>NotificationUIDCheck</td><td>1.2</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Ticket Menu Module"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module"></a>Ticket Menu Module</h5></div></div></div><p>
        Ticket menu modules are used to display an addtional link in the
        menu above a ticket. You can write and register your own ticket
        menu module.
        There are 4 ticket menues (Generic, Lock, Responsible and
        TicketWatcher) which come with the OTRS framework. For
        more information please have a look at the OTRS admin manual.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-menu-module-code"></a>Code Example</h6></div></div></div><p>
            The ticket menu modules are located under
            Kernel/Output/HTML/TicketMenu*.pm.
            There is an example of a ticket-menu module below.
            Save it under Kernel/Output/HTML/TicketMenuCustom.pm.
            You just need 2 functions: new() and Run().
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/TicketMenuCustom.pm
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# Id: TicketMenuCustom.pm,v 1.17 2010/04/12 21:34:06 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::TicketMenuCustom;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject UserID TicketObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{Ticket} ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; 'Need Ticket!'
        );
        return;
    }

    # check if frontend module registered, if not, do not show action
    if ( $Param{Config}-&gt;{Action} ) {
        my $Module = $Self-&gt;{ConfigObject}-&gt;Get('Frontend::Module')-&gt;{ $Param{Config}-&gt;{Action} };
        return if !$Module;
    }

    # check permission
    my $AccessOk = $Self-&gt;{TicketObject}-&gt;Permission(
        Type     =&gt; 'rw',
        TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
        UserID   =&gt; $Self-&gt;{UserID},
        LogNo    =&gt; 1,
    );
    return if !$AccessOk;

    # check permission
    if ( $Self-&gt;{TicketObject}-&gt;CustomIsTicketCustom( TicketID =&gt; $Param{Ticket}-&gt;{TicketID} ) ) {
        my $AccessOk = $Self-&gt;{TicketObject}-&gt;OwnerCheck(
            TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
            OwnerID  =&gt; $Self-&gt;{UserID},
        );
        return if !$AccessOk;
    }

    # check acl
    return
        if defined $Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} }
            &amp;&amp; !$Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} };

    # if ticket is customized
    if ( $Param{Ticket}-&gt;{Custom} eq 'lock' ) {

        # if it is locked for somebody else
        return if $Param{Ticket}-&gt;{OwnerID} ne $Self-&gt;{UserID};

        # show custom action
        return {
            %{ $Param{Config} },
            %{ $Param{Ticket} },
            %Param,
            Name        =&gt; 'Custom',
            Description =&gt; 'Custom to give it back to the queue!',
            Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
        };
    }

    # if ticket is customized
    return {
        %{ $Param{Config} },
        %{ $Param{Ticket} },
        %Param,
        Name        =&gt; 'Custom',
        Description =&gt; 'Custom it to work on it!',
        Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
    };
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-menu-module-configuration"></a>Configuration Example</h6></div></div></div><p>
            There is the need to activate your custom ticket menu module.
            This can be done using the xml configuration below. There may
            be additional parameters in the config hash for your ticket menu
            module.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Ticket::Frontend::MenuModule###110-Custom" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to show custom link in menu.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Mit diesem Modul wird der Custom-Link in der Linkleiste der Ticketansicht angezeigt.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Ticket::MenuModule&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::TicketMenuCustom&lt;/Item&gt;
            &lt;Item Key="Name"&gt;Custom&lt;/Item&gt;
            &lt;Item Key="Action"&gt;AgentTicketCustom&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-menu-module-use_cases"></a>Use Case Example</h6></div></div></div><p>
            Useful ticket menu implementation could be a link to a external
            tool if parameters (e.g. FreeTextField) have been set.
        </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-menu-module-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
                The ticket menu directs to an URL that can be handled.
                If you want to handle that request via the OTRS framework,
                you have to write your own frontend module.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-menu-module-releases"></a>Release Availability</h6></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>TicketMenuGeneric</td><td>2.0</td></tr><tr><td>TicketMenuLock</td><td>2.0</td></tr><tr><td>TicketMenuResponsible</td><td>2.1</td></tr><tr><td>TicketMenuTicketWatcher</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section" title="Old Module Descriptions"><div class="titlepage"><div><div><h4 class="title"><a name="old-module-description"></a>Old Module Descriptions</h4></div></div></div><p>Please remove these old sections if newer ones were created.</p><div class="section" title="Navigation Module"><div class="titlepage"><div><div><h5 class="title"><a name="module-navigation"></a>Navigation Module</h5></div></div></div><p>
In this module layer you can create dynamic navigation bar items with
dynamic content (Name and Description). Navigation Module are located under Kernel/Output/HTML/NavBar*.pm.
        </p><p>
Format:
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/NavBarABC.pm - shows a navbar item dynamicaly
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: module-format.xml,v 1.2 2010-12-01 13:22:15 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::NavBarABC;

use strict;
use warnings;

# --
sub new {
    my ( $Type, %Param ) = @_;
    [...]
    return $Self;
}
# --
sub Run {
    my ( $Self, %Param ) = @_;
    my %Return = ();
    $Return{'0999989'} = {
        Block       =&gt; 'ItemPersonal',
        Description =&gt; 'Some Desctipton',
        Name        =&gt; 'Text',
        Image       =&gt; 'new-message.png',
        Link        =&gt; 'Action=AgentMailbox&amp;amp;Subaction=New',
        AccessKey   =&gt; 'j',
    };
    return %Return;
}
# --
1;
        </pre><p>
        </p><p>
To use this module add the following code to the Kernel/Config.pm and restart
your webserver (if you use mod_perl).
        </p><pre class="programlisting">
[Kernel/Config.pm]
# agent interface notification module
$Self-&gt;{'Frontend::NavBarModule'}-&gt;{'99-ABC'} = {
    Module =&gt; 'Kernel::Output::HTML::NavBarABC',
};
        </pre><p>
        </p></div><div class="section" title="Frontend Modules"><div class="titlepage"><div><div><h5 class="title"><a name="old-frontend-modules"></a>Frontend Modules</h5></div></div></div><p>
Frontend Modules are located under  "$OTRS_HOME/Kernel/Modules/*.pm". There
are two public functions in there - new() and run() - which are accessed from the
Frontend Handle (e. g. index.pl). "new()" is used to create a frontend
module object. The Frontend Handle provides the used frontend module with the basic framework object.
These are, for example: ParamObject (to get formular params), DBObject
(to use existing database connects), LayoutObject (to use templates and other
html layout functions), ConfigObject (to access config settings), LogObject
(to use the framework log system), UserObject (to get the user functions from
the current user), GroupObject (to get the group functions), MainObject (to get main functions
like 'Require') and EncodeObject (for the charset encoding).
        </p><p>
For more information on core modules see
<a class="ulink" href="http://dev.otrs.org/" target="_top">http://dev.otrs.org/</a>
        </p><p>
Format:
        </p><pre class="programlisting">
# --
# Kernel/Modules/AgentTest.pm - message of the day
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: module-format.xml,v 1.2 2010-12-01 13:22:15 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Modules::AgentTest;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

# --
sub new {
    my ( $Type, %Param ) = @_;
    [...]
    return $Self;
}
# --
sub Run {
    my ( $Self, %Param ) = @_;
    [...]
    # ---------------------------------------------------------- #
    # add a new object (Note: dtl text 'New')
    # ---------------------------------------------------------- #
    if ($Self-&gt;{Subaction} eq 'Add') {
        my $Output   = '';
        my %Frontend = ();
        [...]
        # add add block
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'Add',
            Data =&gt; {%Param, %Frontend},
        );
        # build output
        $Output .= $Self-&gt;{LayoutObject}-&gt;Header(Area =&gt; 'Agent', Title =&gt; "Test");
        $Output .= $Self-&gt;{LayoutObject}-&gt;NavigationBar();
        $Output .= $Self-&gt;{LayoutObject}-&gt;Output(
            Data =&gt; {%Param, %Frontend},
            TemplateFile =&gt; 'AgentTest',
        );
        $Output .= $Self-&gt;{LayoutObject}-&gt;Footer();
        return $Output;
    }
    # ---------------------------------------------------------- #
    # show overview screen
    # ---------------------------------------------------------- #
    elsif ($Self-&gt;{Subaction} eq 'Overview') {
        # add overview block
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'Overview',
            Data =&gt; {%Param, %Frontend},
        );
        # build output
        $Output .= $Self-&gt;{LayoutObject}-&gt;Header(Area =&gt; 'Agent', Title =&gt; "Test");
        $Output .= $Self-&gt;{LayoutObject}-&gt;NavigationBar();
        $Output .= $Self-&gt;{LayoutObject}-&gt;Output(
            Data =&gt; {%Param, %Frontend},
            TemplateFile =&gt; 'AgentTest',
        );
        $Output .= $Self-&gt;{LayoutObject}-&gt;Footer();
        return $Output;
    }
    # ---------------------------------------------------------- #
    # show error screen
    # ---------------------------------------------------------- #
    return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(Message =&gt; "Invalid Subaction process!");
}
# --
1;
        </pre><p>
        </p><p>
You also need a module registration for frontend modules. Define read
only groups with the "GroupRo" and read/write groups with the 'Group' param (see
table below for details). You can define navigation bar icons via the
"NavBar'"param, too (see table below for details).
        </p><pre class="programlisting">
[Kernel/Config.pm]
$Self-&gt;{'Frontend::Module'}-&gt;{'AgentTest'} = {
    Group =&gt; ['admin'],
    GroupRo =&gt; ['test', 'admin'],
    Description =&gt; 'A test Module',
    NavBarName =&gt; 'Ticket',
    NavBar =&gt; [
        {
            Description =&gt; 'Test Module',
            Name =&gt; 'Test',
            Image =&gt; 'stats.png',
            Link =&gt; 'Action=AgentTest',
            NavBar =&gt; 'Ticket',
            Prio =&gt; 85,
        },
    ],
};
        </pre><p>
        </p><p>
You can access this frontend module via http (browse) with the Action
param = Module or over the navigation bar.
        </p><p>
            <a class="ulink" href="" target="_top">http://localhost/otrs/index.pl?Action=AgentTest</a>
        </p><p>
Description of Frontend::Module options:
        </p><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody><tr><td>Group</td><td>An ARRAY reference of rw groups of this module.</td></tr><tr><td>GroupRo</td><td>An ARRAY reference of ro groups of this module.</td></tr><tr><td>Description</td><td>Module description, just for internal use - not shown in the user interface.</td></tr><tr><td>NavBarName</td><td>NavBar context name of this module.</td></tr></tbody></table></div><p>
        </p><p>
Description of NavBar (icon points) options:
        </p><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody><tr><td>Description</td><td>The description of the icon which is shown in the navbar after the curser is pointed on it.</td></tr><tr><td>Name</td><td>The icon name shown in the navbar.</td></tr><tr><td>Image</td><td>The icon image shown in the navbar.</td></tr><tr><td>Link</td><td>The link behind the icon in the navbar.</td></tr><tr><td>NavBar</td><td>Only shown this icon in this NavBar context.</td></tr><tr><td>Prio</td><td>Sort prio of the icon in the navbar.</td></tr></tbody></table></div><p>
        </p></div><div class="section" title="Core Modules"><div class="titlepage"><div><div><h5 class="title"><a name="module-core"></a>Core Modules</h5></div></div></div><p>
Core modules are located under $OTRS_HOME/Kernel/System/*. This layer is for
the logical work. The modules are used to handle system routines like "lock ticket"
and "create ticket". These modules  always need pod (Perl Documentation).
        </p><p>
A few common core modules are: Log (Kernel::System::Log); Ticket
(Kernel::System::Ticket), Auth (Kernel::System::Auth), User (Kernel::System::User),
Email (Kernel::System::Email).
        </p><p>
For more information on the core modules see
<a class="ulink" href="http://dev.otrs.org/" target="_top">http://dev.otrs.org</a>
        </p><p>
Format:
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Backend.pm - a core module
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: module-format.xml,v 1.2 2010-12-01 13:22:15 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Backend;

use strict;
use warnings;

=head1 NAME

Kernel::System::Log - global log interface

=head1 SYNOPSIS

All log functions.

=head1 PUBLIC INTERFACE

=over 4

=item new()

create a backend object

use Kernel::Config;
use Kernel::System::Backend;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

my $ConfigObject = Kernel::Config-&gt;new();
my $BackendObject    = Kernel::System::Backend-&gt;new(ConfigObject =&gt; $ConfigObject);

=cut

sub new {
    my ( $Type, %Param ) = @_;
    [...]
    return $Self;
}

=item SomeMethodeA()

some info about the methode

$BackendObject-&gt;SomeMethodeA(ParamA =&gt; 'error', ParamB =&gt; "Need something!");

=cut

sub SomeMethodeA{
    my ( $Self, %Param ) = @_;
    [...]
    return 1;
}
1;

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (http://otrs.org/).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see http://www.gnu.org/licenses/agpl.txt.

=head1 VERSION

$Revision: 1.2 $ $Date: 2010-12-01 13:22:15 $

=cut
        </pre><p>
        </p></div><div class="section" title="Customer User Module"><div class="titlepage"><div><div><h5 class="title"><a name="module-customer-user"></a>Customer User Module</h5></div></div></div><p>
This module layer can be used as a bridge between your customer source
system and OTRS. Thus it is possible to use your customer data directly for
your data ware house (read only and read/write).
        </p><p>
Format:
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerUser/ABC.pm - a customer data backend
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: module-format.xml,v 1.2 2010-12-01 13:22:15 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::CustomerUser::ABD;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

# --
sub new {
    my ( $Type, %Param ) = @_;
    [...]
    return $Self;
}
# --
sub CustomerName {
    [...]
    return $Name;
}
# --
sub CustomerSearch {
    [...]
    return %Result;
}
# --
sub CustomerUserList {
    [...]
    return %List;
}
# --
sub CustomerIDs {
    [...]
    return @CustomerIDs;
}
# --
sub CustomerUserDataGet {
    [...]
    return %Data;
}
# --
sub CustomerUserAdd {
    [...]
    return 1
}
# --
sub CustomerUserUpdate {
    [...]
    return 1;
}
# --
sub SetPassword {
    [...]
    return 1;
}
1;
        </pre><p>
        </p><p>
To use this module, see the admin manual.
        </p></div><div class="section" title="Customer Navigation Module"><div class="titlepage"><div><div><h5 class="title"><a name="module-customer-navigation"></a>Customer Navigation Module</h5></div></div></div><p>
In this module layer you can create dynamic navigation bar items with
dynamic content (Name and Description).
        </p><p>
The format is the same as in the Navigation Module.
        </p><p>
Just the config setting key is different. To use this module, add the following
to the Kernel/Config.pm and restart your webserver (if you use mod_perl).
        </p><p>
        </p><pre class="programlisting">
[Kernel/Config.pm]
# customer notifiacation module
$Self-&gt;{'CustomerFrontend::NavBarModule'}-&gt;{'99-ABC'} = {
    Module =&gt; 'Kernel::Output::HTML::NavBarABC',
};
        </pre><p>
        </p></div><div class="section" title="Ticket Modules"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-modules"></a>Ticket Modules</h5></div></div></div><div class="section" title="Ticket Number Module"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-number-module"></a>Ticket Number Module</h6></div></div></div><p>
If you want to create your own ticket number format, just create your own ticket
number module. These modules are located under "Kernel/System/Ticket/Number/*.pm".
For default modules see the admin manual. You just need 2 functions:
CreateTicketNr() and GetTNByString():
            </p><p>
Format:
            </p><p>
            </p><pre class="programlisting">
# --
# Ticket/Number/Simple.pm - a ticket number auto increment generator
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: module-format.xml,v 1.2 2010-12-01 13:22:15 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Ticket::Number::Simple;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

sub CreateTicketNr {
    my $Self = shift;
    my $JumpCounter = shift || 0;
    # get needed config options
    [...]
    return $Tn;
}
# --
sub GetTNByString {
    my $Self = shift;
    my $String = shift || return;
    [...]
    return $Tn;
}
1;
            </pre><p>
            </p></div><div class="section" title="Ticket PostMaster Module"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-postmaster-module"></a>Ticket PostMaster Module</h6></div></div></div><p>
PostMaster modules are used during the PostMaster process.
There are two kinds of PostMaster modules. PostMasterPre (used after parsing an email)
and PostMasterPost (used after an email is processed and in the database) modules.
            </p><p>
If you want to create your own postmaster filter, just create your own module.
These modules are located under "Kernel/System/PostMaster/Filter/*.pm".
For default modules see the admin manual. You just need two functions:
new() and Run():
            </p><p>
The following is an examplary module to match emails and set X-OTRS-Headers
(see doc/X-OTRS-Headers.txt for more info).
            </p><p>
Kernel/Config.pm:
            </p><p>
            </p><pre class="programlisting">
# Job Name: 1-Match
# (block/ignore all spam email with From: noreply@)
$Self-&gt;{'PostMaster::PreFilterModule'}-&gt;{'1-Example'} = {
    Module =&gt; 'Kernel::System::PostMaster::Filter::Example',
    Match =&gt; {
        From =&gt; 'noreply@',
    },
    Set =&gt; {
        'X-OTRS-Ignore' =&gt; 'yes',
    },
};
            </pre><p>
            </p><p>
Format:
            </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/PostMaster/Filter/Example.pm - a postmaster filter
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: module-format.xml,v 1.2 2010-12-01 13:22:15 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::PostMaster::Filter::Example;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless ($Self, $Type);

    $Self-&gt;{Debug} = $Param{Debug} || 0;

    # get needed objects
    for (qw(ConfigObject EncodeObject LogObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;
    # get config options
    my %Config = ();
    my %Match = ();
    my %Set = ();
    if ($Param{JobConfig} &amp;amp;&amp;amp; ref($Param{JobConfig}) eq 'HASH') {
        %Config = %{$Param{JobConfig}};
        if ($Config{Match}) {
            %Match = %{$Config{Match}};
        }
        if ($Config{Set}) {
            %Set = %{$Config{Set}};
        }
    }
    # match 'Match =&gt; ???' stuff
    my $Matched = '';
    my $MatchedNot = 0;
    for (sort keys %Match) {
        if ($Param{GetParam}-&gt;{$_} &amp;amp;&amp;amp; $Param{GetParam}-&gt;{$_} =~ /$Match{$_}/i) {
            $Matched = $1 || '1';
            if ($Self-&gt;{Debug} &gt; 1) {
                $Self-&gt;{LogObject}-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched!",
                );
            }
        }
        else {
            $MatchedNot = 1;
            if ($Self-&gt;{Debug} &gt; 1) {
                $Self-&gt;{LogObject}-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched NOT!",
                );
            }
        }
    }
    # should I ignore the incoming mail?
    if ($Matched &amp;amp;&amp;amp; !$MatchedNot) {
        for (keys %Set) {
            if ($Set{$_} =~ /\[\*\*\*\]/i) {
                $Set{$_} = $Matched;
            }
            $Param{GetParam}-&gt;{$_} = $Set{$_};
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'notice',
                Message =&gt; "Set param '$_' to '$Set{$_}' (Message-ID: $Param{GetParam}-&gt;{'Message-ID'}) ",
            );
        }
    }

    return 1;
}

1;
            </pre><p>
            </p><p>
The following image shows you the email processing flow.
            </p><div class="screenshot"><div><img src="screenshots/email-processing.png"></div></div><p>
            </p></div><div class="section" title="Ticket Menu Module"><div class="titlepage"><div><div><h6 class="title"><a name="ticket-module-menu"></a>Ticket Menu Module</h6></div></div></div><p>
To add links in the ticket menu, just use ticket menu modules.
            </p><p>
If you want to create your own ticket menu link, just create your own module.
These modules are located under "Kernel/Output/HTML/TicketMenu*.pm".
For default modules see the admin manual. You just need two functions:
new() and Run():
            </p><p>
The following example shows you how to show a lock or a unlock ticket link.
            </p><p>
Kernel/Config.pm:
            </p><p>
            </p><pre class="programlisting">
# for ticket zoom menu
$Self-&gt;{'Ticket::Frontend::MenuModule'}-&gt;{'100-Lock'} =  {
    Action =&gt; 'AgentTicketLock',
    Module =&gt; 'Kernel::Output::HTML::TicketMenuLock',
    Name   =&gt; 'Lock'
};

# for ticket preview menu
$Self-&gt;{'Ticket::Frontend::PreMenuModule'}-&gt;{'100-Lock'} =  {
    Action =&gt; 'AgentTicketLock',
    Module =&gt; 'Kernel::Output::HTML::TicketMenuLock',
    Name   =&gt; 'Lock'
};
            </pre><p>
            </p><p>
Format:
            </p><p>
            </p><pre class="programlisting">
# --
# Kernel/Output/HTML/TicketMenuLock.pm
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: module-format.xml,v 1.2 2010-12-01 13:22:15 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::TicketMenuLock;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

# --
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless ($Self, $Type);

    # get needed objects
    for (qw(ConfigObject LogObject DBObject LayoutObject UserID TicketObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    return $Self;
}
# --
sub Run {
    my ( $Self, %Param ) = @_;
    # check needed stuff
    if (!$Param{Ticket}) {
        $Self-&gt;{LogObject}-&gt;Log(Priority =&gt; 'error', Message =&gt; 'Need Ticket!');
        return;
    }

    # check permission
    if ($Self-&gt;{TicketObject}-&gt;LockIsTicketLocked(TicketID =&gt; $Param{TicketID})) {
        my $AccessOk = $Self-&gt;{TicketObject}-&gt;OwnerCheck(
            TicketID =&gt; $Param{TicketID},
            OwnerID =&gt; $Self-&gt;{UserID},
        );
        if (!$AccessOk) {
            return $Param{Counter};
        }
    }

    $Self-&gt;{LayoutObject}-&gt;Block(
        Name =&gt; 'Menu',
        Data =&gt; { },
    );
    if ($Param{Counter}) {
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'MenuItemSplit',
            Data =&gt; {  },
        );
    }
    if ($Param{Ticket}-&gt;{Lock} eq 'lock') {
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'MenuItem',
            Data =&gt; {
                %{$Param{Config}},
                %{$Param{Ticket}},
                %Param,
                Name =&gt; 'Unlock',
                Description =&gt; 'Unlock to give it back to the queue!',
                Link =&gt; 'Action=AgentTicketLock&amp;amp;Subaction=Unlock&amp;amp;TicketID=$QData{"TicketID"}',
            },
        );
    }
    else {
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'MenuItem',
            Data =&gt; {
                %{$Param{Config}},
                %Param,
                Name =&gt; 'Lock',
                Description =&gt; 'Lock it to work on it!',
                Link =&gt; 'Action=AgentTicketLock&amp;amp;Subaction=Lock&amp;amp;TicketID=$QData{"TicketID"}',
            },
        );
    }
    $Param{Counter}++;
    return $Param{Counter};
}
# --
1;
            </pre><p>
            </p></div><div class="section" title="Ticket Event Module"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent"></a>Ticket Event Module</h6></div></div></div><p>
        Ticket event modules are running right after a ticket action takes place.
        Per convention these modules are located in the directory "Kernel/System/Ticket/Event".
        An ticket event module needs only the two functions new() and Run().
        The method Run() receives at least the parameters Event, UserID, and TicketID.
        For the events TicketFreeTextUpdate and TicketFreeTimeUpdate, the parameter Counter is also passed
        to the Run() method, in order to identify which free field was updated.
        The article related handler functions also receives the ArticleID as parameter.
    </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-code"></a>Code example</h6></div></div></div><p>
            See Kernel/System/Ticket/Event/EventModulePostTemplate.pm in the package TemplateModule.
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-configuration"></a>Configuration example</h6></div></div></div><p>
            See Kernel/Config/Files/EventModulePostTemplate.xml in the package TemplateModule.
        </p></div><div class="section" title="Use Cases"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecases"></a>Use Cases</h6></div></div></div><div class="section" title="A ticket should be unlocked after a move action."><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-10"></a>A ticket should be unlocked after a move action.</h6></div></div></div><p>
                This standard feature has been implemented with the ticket event module
                Kernel::System::Ticket::Event::ForceUnlock.
                When this feature is not wanted, then it can be turned off by
                unsetting the SysConfig entry Ticket::EventModulePost###910-ForceUnlockOnMove.
            </p></div><div class="section" title="Perform extra cleanup action when a ticket is deleted."><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-20"></a>Perform extra cleanup action when a ticket is deleted.</h6></div></div></div><p>
                A customized OTRS might hold non-standard data in additional database tables.
                When a ticket is deleteted then this additional data needs to be deleted.
                This functionality can be achieved with a ticket event module listening to 'TicketDelete' events.
            </p></div><div class="section" title="New tickets should be twittered."><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-30"></a>New tickets should be twittered.</h6></div></div></div><p>
                A ticket event module listening to 'TicketCreate' can send out tweets.
            </p></div></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
            No caveats are known.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-releases"></a>Release Availability</h6></div></div></div><p>
Ticket events have been available in OTRS since OTRS 2.0.
        </p><p>
Ticket Events for OTRS 2.0:
TicketCreate, TicketDelete, TicketTitleUpdate, TicketUnlockTimeoutUpdate,
TicketEscalationStartUpdate, MoveTicket,
SetCustomerData, TicketFreeTextSet, TicketFreeTimeSet,
TicketPendingTimeSet, LockSet,
StateSet, OwnerSet,
TicketResponsibleUpdate, PrioritySet, HistoryAdd,
HistoryDelete, TicketAccountTime, TicketMerge, ArticleCreate,
ArticleFreeTextSet, ArticleUpdate, ArticleSend,
ArticleBounce, SendAgentNotification,
SendCustomerNotification, SendAutoResponse, ArticleFlagSet;
        </p><p>
Ticket Events for OTRS 2.1 and higher:
TicketCreate, TicketDelete, TicketTitleUpdate, TicketUnlockTimeoutUpdate,
TicketEscalationStartUpdate, TicketQueueUpdate (MoveTicket),
TicketCustomerUpdate (SetCustomerData), TicketFreeTextUpdate
(TicketFreeTextSet), TicketFreeTimeUpdate (TicketFreeTimeSet),
TicketPendingTimeUpdate (TicketPendingTimeSet), TicketLockUpdate (LockSet),
TicketStateUpdate (StateSet), TicketOwnerUpdate (OwnerSet),
TicketResponsibleUpdate, TicketPriorityUpdate (PrioritySet),
TicketSubscribe, TicketUnsubscribe, HistoryAdd,
HistoryDelete, TicketAccountTime, TicketMerge, ArticleCreate,
ArticleFreeTextUpdate (ArticleFreeTextSet), ArticleUpdate, ArticleSend,
ArticleBounce, ArticleAgentNotification (SendAgentNotification),
ArticleCustomerNotification (SendCustomerNotification), ArticleAutoResponse
(SendAutoResponse), ArticleFlagSet, ArticleFlagDelete;
        </p><p>
Ticket Events for OTRS 2.4:
TicketCreate, TicketDelete, TicketTitleUpdate, TicketUnlockTimeoutUpdate,
TicketQueueUpdate(MoveTicket), TicketTypeUpdate, TicketServiceUpdate,
TicketSLAUpdate, TicketCustomerUpdate (SetCustomerData), TicketFreeTextUpdate, TicketFreeTimeUpdate,
TicketPendingTimeUpdate (TicketPendingTimeSet), TicketLockUpdate (LockSet),
TicketStateUpdate (StateSet), TicketOwnerUpdate (OwnerSet),
TicketResponsibleUpdate, TicketPriorityUpdate (PrioritySet),
HistoryAdd, HistoryDelete,
TicketAccountTime, TicketMerge, ArticleCreate, ArticleFreeTextUpdate (ArticleFreeTextSet),
ArticleUpdate, ArticleSend, ArticleBounce, ArticleAgentNotification (SendAgentNotification),
ArticleCustomerNotification (SendCustomerNotification),
ArticleAutoResponse(SendAutoResponse), ArticleFlagSet, ArticleFlagDelete;
        </p></div></div><div class="section" title="More Modules"><div class="titlepage"><div><div><h6 class="title"><a name="more-modules"></a>More Modules</h6></div></div></div><p>
The Agent Ticket Permission Modules (Kernel/System/Ticket/Permission/) contain functions to verify
an agent's authorisation to access a ticket.
            </p><p>
The Customer Ticket Permission Modules (Kernel/System/Ticket/CustomerPermission/) contain functions
to verify a customer's authorisation to access a ticket.
            </p><p>
The Article Module (Kernel/System/Ticket/Article.pm) facilitates the readout and generating of ticket articles.
            </p><p>
More modules and their descriptions are listed under <a class="ulink" href="http://dev.otrs.org/" target="_top">http://dev.otrs.org/</a>
            </p></div></div></div></div><div class="section" title="Object Basics"><div class="titlepage"><div><div><h3 class="title"><a name="idp17352640"></a>Object Basics</h3></div></div></div><p>
This chapter describes the basics of a new object (e. g. a ticket, faq, calendar, ...)
and how the environment should look like.
    </p><div class="section" title="Object Options"><div class="titlepage"><div><div><h4 class="title"><a name="object-options"></a>Object Options</h4></div></div></div><p>
An object (e.g. a ticket, faq, calendar, ...) should  at least have the following options
(named after their function) in the application and in the database.
        </p><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Application</th><th>database naming</th></tr></thead><tbody><tr><td>ObjectID</td><td>object_id</td></tr><tr><td>Number</td><td>number</td></tr><tr><td>Title</td><td>title</td></tr><tr><td>...</td><td>...</td></tr><tr><td>StateID</td><td>state_id</td></tr><tr><td>WordAndWord</td><td>word_and_word</td></tr><tr><td>...</td><td>...</td></tr><tr><td>Created</td><td>created</td></tr><tr><td>CreatedBy</td><td>created_by</td></tr><tr><td>Changed</td><td>changed</td></tr><tr><td>ChangedBy</td><td>changed_by</td></tr></tbody></table></div><p>
        </p></div><div class="section" title="Search Options"><div class="titlepage"><div><div><h4 class="title"><a name="search-options"></a>Search Options</h4></div></div></div><p>
A search over free text fields should support:
        </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>a normal search "thomas" (always)</p></li><li class="listitem"><p>an and condition like "thomas+raith" (if possible)</p></li><li class="listitem"><p>an or condition like "thomas||raith" (if possible)</p></li></ul></div><p>
        </p></div><div class="section" title="Config Naming"><div class="titlepage"><div><div><h4 class="title"><a name="config-naming"></a>Config Naming</h4></div></div></div><p>
Config naming should be with a leading prefix, the object name like this:
        </p><p>
        </p><pre class="programlisting">
$Self-&gt;{"Object::Option"} = 1234;
        </pre><p>
        </p><p>
Config-Hashes should be named with the same name as in the .dtl. For example:
        </p><p>
        </p><pre class="programlisting">
$Self-&gt;{"Object::CategoryList"} -&gt; $Data{"CategoryList"}
        </pre><p>
        </p><p>
The config order should be global setting followed by detail settings.
        </p></div><div class="section" title="Config File"><div class="titlepage"><div><div><h4 class="title"><a name="config-file"></a>Config File</h4></div></div></div><p>
An object should have a unique config file which should be located under
$OTRS_HOME/Kernel/Config/Files/*.pm. For example:
        </p><p>
        </p><pre class="programlisting">
# module reg and nav bar
$Self-&gt;{'Frontend::Module'}-&gt;{'AgentFileManager'} = {
    Description =&gt; 'Web File Manager',
    NavBarName =&gt; 'FileManager',
    NavBar =&gt; [
    {
        Description =&gt; 'A web file manager',
        Name =&gt; 'File-Manager',
        Image =&gt; 'filemanager.png',
        Link =&gt; 'Action=AgentFileManager',
        NavBar =&gt; 'FileManager',
        Prio =&gt; 5000,
        AccessKey =&gt; 'f',
    },
    ],
};

# browse/download root directory
$Self-&gt;{"FileManager::Root"} = '/home/';

# trash directory
$Self-&gt;{"FileManager::Trash"} = "/home/Trash/";
        </pre><p>
        </p><p>
Description of the Config Preferences:
        </p><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Element</th><th>description</th></tr></thead><tbody><tr><td>NavBarName</td><td>module name</td></tr><tr><td>Group/GroupRo</td><td>group access authorization</td></tr><tr><td>Name</td><td>name of the link button</td></tr><tr><td>Image</td><td>image for the link button</td></tr><tr><td>Link</td><td>URI</td></tr><tr><td>NavBar</td><td>module name (correlation)</td></tr><tr><td>Prio</td><td>prio in the button list</td></tr><tr><td>AccessKey</td><td>short key (key + ALT) for quick access over the keyboard. </td></tr></tbody></table></div><p>
        </p></div><div class="section" title="NavBar Settings"><div class="titlepage"><div><div><h4 class="title"><a name="navbar-setting"></a>NavBar Settings</h4></div></div></div><p>
A NavBar item should look like the following example:
        </p><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NavBarPoint</th><th>Prio</th><th>AccessKey</th><th>Image</th></tr></thead><tbody><tr><td>Overview</td><td>100</td><td>o</td><td>overview.png</td></tr><tr><td>New</td><td>200</td><td>n</td><td>new.png</td></tr><tr><td>Search</td><td>300</td><td>s</td><td>search.png</td></tr><tr><td>Delete</td><td>400</td><td>d</td><td>delete.png</td></tr><tr><td>Import</td><td>500</td><td>-</td><td>import.png</td></tr><tr><td>Setting</td><td>900</td><td>-</td><td>module_setting.png</td></tr></tbody></table></div><p>
        </p><p>
Menu functions - generic, used by any application module
        </p><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NavBarPoint</th><th>Prio</th><th>AccessKey</th><th>Image</th></tr></thead><tbody><tr><td>Logout</td><td>10</td><td>l</td><td>logout.png</td></tr><tr><td>Preferences</td><td>0</td><td>p</td><td>preferences.png</td></tr><tr><td>New Messages</td><td>999989</td><td>m</td><td>new-messages.png</td></tr><tr><td>Locked Tickets</td><td>9999999</td><td>k</td><td>personal.png</td></tr></tbody></table></div><p>
        </p><p>
Menu functions - global, always used
        </p><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NavBarPoint</th><th>Prio</th><th>AccessKey</th><th>Image</th></tr></thead><tbody><tr><td>Ticket</td><td>200</td><td>t</td><td>ticket.png</td></tr><tr><td>Incident (SIRIOS-Project)</td><td>2000</td><td>i</td><td>incident.png</td></tr><tr><td>Advisory (SIRIOS-Project)</td><td>2100</td><td>d</td><td>advisory.png</td></tr><tr><td>ShortAdvisory (SIRIOS-BSI-specific)</td><td>2150</td><td>z</td><td>advisory_short.png</td></tr><tr><td>VirusWarning (SIRIOS-BSI-specific)</td><td>2300</td><td>x</td><td>viruswarning.png</td></tr><tr><td>FreeTextMessage (SIRIOS-BSI-specific)</td><td>2400</td><td>y</td><td>freetextmessage.png</td></tr><tr><td>Vulnerability (SIRIOS-Project)</td><td>2500</td><td>v</td><td>vulnerability.png</td></tr><tr><td>Artefact (SIRIOS-Project)</td><td>2600</td><td>r</td><td>artefactdb.png</td></tr><tr><td>WebWatcher (SIRIOS-Project)</td><td>2700</td><td>z</td><td>webwatcher.png</td></tr><tr><td>IDMEFConsole (SIRIOS-Project)</td><td>2800</td><td>-</td><td>idmef_console.png</td></tr><tr><td>WID-Authoring (WID-Project)</td><td>2900</td><td>-</td><td>wid_authoring.png</td></tr><tr><td>WID-Portal-Admin-User (WID-Project)</td><td>2910</td><td>-</td><td>wid_portal_admin_user.png</td></tr><tr><td>WID-Portal-Admin-Group (WID-Project)</td><td>2920</td><td>-</td><td>wid_portal_admin_group.png</td></tr><tr><td>ITSMService (OTRS::ITSM)</td><td>3100</td><td>-</td><td>itsm_service.png</td></tr><tr><td>ITSMConfigItem (OTRS::ITSM)</td><td>3200</td><td>-</td><td>itsm_configitem.png</td></tr><tr><td>ITSMLocation (OTRS::ITSM)</td><td>3300</td><td>-</td><td>itsm_location.png</td></tr><tr><td>TimeAccounting</td><td>6000</td><td>-</td><td>time_accounting.png</td></tr><tr><td>ContentManager</td><td>7050</td><td>-</td><td>contentmanager.png</td></tr><tr><td>Calendar</td><td>8000</td><td>c</td><td>calendar.png</td></tr><tr><td>FileManager</td><td>8100</td><td>f</td><td>filemanager.png</td></tr><tr><td>WebMail</td><td>8200</td><td>w</td><td>webmail.png</td></tr><tr><td>FAQ</td><td>8300</td><td>q</td><td>help.png</td></tr><tr><td>Call</td><td>8400</td><td>-</td><td>call.png</td></tr><tr><td>Stats</td><td>8500</td><td>-</td><td>stats.png</td></tr><tr><td>CustomerDB</td><td>9000</td><td>-</td><td>folder_yellow.png</td></tr><tr><td>CustomerCompanyDB</td><td>9100</td><td>-</td><td>folder_yellow.png</td></tr><tr><td>Admin</td><td>10000</td><td>a</td><td>admin.png</td></tr></tbody></table></div><p>
        </p><p>
Table 3: Menu Applications -default application modules
        </p><p>
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
AccessKey "g" is also reserved for the submission of forms.
            </p></div><p>
        </p></div><div class="section" title="Screen flow"><div class="titlepage"><div><div><h4 class="title"><a name="screen-flow"></a>Screen flow</h4></div></div></div><p>
An object module should have the following process flow:
        </p><p>
            </p><div class="screenshot"><div><img src="screenshots/screen-flow.png"></div></div><p>
        </p></div></div><div class="section" title="Writing an OTRS module for a new object"><div class="titlepage"><div><div><h3 class="title"><a name="idp6465744"></a>Writing an OTRS module for a new object</h3></div></div></div><p>
In this chapter, the writing of a new OTRS module is illustrated on the basis of a simple small programme.
Necessary prerequisite is an OTRS development environment as specified in the chapter of the same name.
    </p><div class="section" title="What we want to write"><div class="titlepage"><div><div><h4 class="title"><a name="what-we-want-to-write"></a>What we want to write</h4></div></div></div><p>
We want to write a little OTRS module that displays the text 'Hello World' when called up.
First of all we must build the directory /Hello World for the module in the developer directory.
In this directory, all directories existent in OTRS can be created.
Each module should at least contain the following directories:
        </p><p>Kernel/</p><p>Kernel/System/</p><p>Kernel/Modules/</p><p>Kernel/Output/HTML/Standard/</p><p>Kernel/Config/</p><p>Kernel/Config/Files/</p><p>Kernel/Language/</p></div><div class="section" title="Default Config File"><div class="titlepage"><div><div><h4 class="title"><a name="default-config-file"></a>Default Config File</h4></div></div></div><p>
The creation of a module registration facilitates the display of the new module in OTRS.
Therefore we create a file '/Kernel/System/Config/Files/HelloWorld.xml'.
In this file, we create a new config element.
The impact of the various settings is described in the chapter 'Config Mechanism'.
        </p><p>
        </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;otrs_config version="1.0" init="Application"&gt;
        &lt;ConfigItem Name="Frontend::Module###AgentHelloWorld" Required="1" Valid="1"&gt;
        &lt;Description Lang="en"&gt;FrontendModuleRegistration for HelloWorld modul.&lt;/Description&gt;
        &lt;Description Lang="de"&gt;FrontendModulRegistration für das HelloWorld Modul.&lt;/Description&gt;
        &lt;Group&gt;HelloWorld&lt;/Group&gt;
        &lt;SubGroup&gt;AgentFrontendModuleRegistration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;FrontendModuleReg&gt;
                &lt;Title&gt;HelloWorld&lt;/Title&gt;
                &lt;Group&gt;users&lt;/Group&gt;
                &lt;Description&gt;HelloWorld&lt;/Description&gt;
                &lt;NavBarName&gt;HelloWorld&lt;/NavBarName&gt;
                &lt;NavBar&gt;
                    &lt;Description&gt;HelloWorld&lt;/Description&gt;
                    &lt;Name&gt;HelloWorld&lt;/Name&gt;
                    &lt;Image&gt;overview.png&lt;/Image&gt;
                    &lt;Link&gt;Action=AgentHelloWorld&lt;/Link&gt;
                    &lt;NavBar&gt;HelloWorld&lt;/NavBar&gt;
                    &lt;Type&gt;Menu&lt;/Type&gt;
                    &lt;Prio&gt;8400&lt;/Prio&gt;
                    &lt;Block&gt;ItemArea&lt;/Block&gt;
                &lt;/NavBar&gt;
            &lt;/FrontendModuleReg&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
&lt;/otrs_config&gt;
        </pre><p>
        </p></div><div class="section" title="Frontend Module"><div class="titlepage"><div><div><h4 class="title"><a name="writing-frontend-module"></a>Frontend Module</h4></div></div></div><p>
After creating the links and executing the Sysconfig, a new module with the name 'HelloWorld' is displayed.
When calling it up, an error message is displayed as OTRS cannot find the matching frontend module yet.
This is the next thing to be created. To do so, we create the following file:
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Modules/AgentHelloWorld.pm - frontend modul
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: writing-otrs-application.xml,v 1.1 2010-08-13 08:59:28 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Modules::AgentHelloWorld;

use strict;
use warnings;

use Kernel::System::HelloWorld;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless ($Self, $Type);

    # check needed objects
    for (qw(ParamObject DBObject TicketObject LayoutObject LogObject QueueObject ConfigObject EncodeObject MainObject)) {
        if ( !$Self-&gt;{$_} ) {
            $Self-&gt;{LayoutObject}-&gt;FatalError( Message =&gt; "Got no $_!" );
        }
    }

    # create needed objects
    $Self-&gt;{HelloWorldObject} = Kernel::System::HelloWorld-&gt;new(%Param);

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;
    my %Data = ();

    $Data{HelloWorldText} = $Self-&gt;{HelloWorldObject}-&gt;GetHelloWorldText();

    # build output
    my $Output = $Self-&gt;{LayoutObject}-&gt;Header(Title =&gt; "HelloWorld");
    $Output   .= $Self-&gt;{LayoutObject}-&gt;NavigationBar();
    $Output   .= $Self-&gt;{LayoutObject}-&gt;Output(
        Data =&gt; \%Data,
        TemplateFile =&gt; 'AgentHelloWorld',
    );
    $Output   .= $Self-&gt;{LayoutObject}-&gt;Footer();
    return $Output;
}

1;
        </pre><p>
        </p></div><div class="section" title="Core Module"><div class="titlepage"><div><div><h4 class="title"><a name="writing-core-module"></a>Core Module</h4></div></div></div><p>
Next, we create the file for the core module "/HelloWorld/Kernel/System/HelloWorld.pm" with the following content:
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/HelloWorld.pm - core modul
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: writing-otrs-application.xml,v 1.1 2010-08-13 08:59:28 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::HelloWorld;

use strict;
use warnings;

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless ($Self, $Type);

    return $Self;
}

sub GetHelloWorldText {
    my ( $Self, %Param ) = @_;

    return 'Hello World';
}

1;
        </pre><p>
        </p></div><div class="section" title="dtl Template File"><div class="titlepage"><div><div><h4 class="title"><a name="dtl-template-file"></a>dtl Template File</h4></div></div></div><p>
The last thing missing before the new module can run is the relevant template.
Thus, we create the following file:
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/Standard/AgentHelloWorld.dtl - overview
# Copyright (C) (year) (name of author) (email of author)
# --
# $Id: writing-otrs-application.xml,v 1.1 2010-08-13 08:59:28 mg Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --
&lt;!-- start form --&gt;
&lt;table border="0" width="100%" cellspacing="0" cellpadding="3"&gt;
    &lt;tr&gt;
        &lt;td class="mainhead"&gt;
            $Env{"Box0"}$Text{"Overview"}: $Text{"HelloWorld"}$Env{"Box1"}
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class="mainbody"&gt;
            &lt;br&gt;
            $Text{"$QData{"HelloWorldText"}"}!&lt;br&gt;
            &lt;br&gt;
            &lt;br&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;!-- end form --&gt;
        </pre><p>
        </p><p>
The module is working now and displays the text 'Hello World' when called up.
        </p></div><div class="section" title="Language File"><div class="titlepage"><div><div><h4 class="title"><a name="language-file"></a>Language File</h4></div></div></div><p>
If the text 'Hello World' is to be translated into German, a language file for this language must be created:
'/HelloWorld/Kernel/Language/de_AgentHelloWorld.pm'.
Example:
        </p><p>
        </p><pre class="programlisting">
package Kernel::Language::de_AgentHelloWorld;

use strict;
use warnings;

sub Data {
    my $Self = shift;

    $Self-&gt;{Translation}-&gt;{'Hello World'} = 'Hallo Welt';

    return 1;
}
1;
        </pre><p>
        </p></div><div class="section" title="Summary"><div class="titlepage"><div><div><h4 class="title"><a name="summery"></a>Summary</h4></div></div></div><p>
The example given above shows that it is not too difficult to write a new module for OTRS.
It is important, though, to make sure that the module and file name are unique and thus
do not interfere with the framework or other expansion modules.
When a module is finished, an OPM package must be generated from it (see chapter 'Package Building').
        </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="hacking.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="hacking.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="how-to-publish.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 2. Hacking OTRS </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> How to Publish your OTRS Extensions</td></tr></table></div></body></html>
