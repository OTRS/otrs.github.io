<html><head>
<!-- otrs.github.io -->
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="../../../../../documentation.css">
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../documentation.js"></script>
<!-- otrs.github.io -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Using the power of the OTRS module layers</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="OTRS 3.2 - Developer Manual"><link rel="up" href="how-to-extend-otrs.html" title="Chapter 3. How to Extend OTRS"><link rel="prev" href="how-to-extend-otrs.html" title="Chapter 3. How to Extend OTRS"><link rel="next" href="how-to-publish-extensions.html" title="Chapter 4. How to Publish Your OTRS Extensions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Using the power of the OTRS module layers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Prev</a> </td><th width="60%" align="center">Chapter 3. How to Extend OTRS</th><td width="20%" align="right"> <a accesskey="n" href="how-to-publish-extensions.html">Next</a></td></tr></table><hr></div><div class="section" title="Using the power of the OTRS module layers"><div class="titlepage"><div><div><h2 class="title"><a name="otrs-module-layers"></a>Using the power of the OTRS module layers</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="otrs-module-layers.html#authentication-user-management-modules">Authentication and user management</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module">Agent Authentication Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#agent-auth-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module">Authentication Synchronisation Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-use_cases">Use Case Examples</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-releases">Release Availability</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#auth-sync-module-caveats">Caveats and Warnings</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module">Customer Authentication Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-auth-module-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#preferences-modules">Preferences</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module">Customer User Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#customer-user-preferences-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module">Queue Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-use_cases">Use Case Examples</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#queue-preferences-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module">Service Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#service-preferences-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module">SLA Preferences Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#sla-preferences-module-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#core-modules">Other core functions</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#log-module">Log Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#log-module-code">Code example: Kernel::System::Log::CustomFile</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-use_cases">Use case examples</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#log-module-caveats">Caveats and Warnings</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#outputfilter">Output Filter</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filterelement_pre">FilterElementPre</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filterelement_post">FilterElementPost</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filtercontent">FilterContent</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter_filtertest">FilterText</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-code">Code example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-usecases">Use Cases</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-bestpractice">Best Practices</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#outputfilter-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#module-stats">Stats Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#module-stats-dynamic">Dynamic Stats</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#module-stats-static">Static Stats</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator">Ticket Number Generator Modules</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-code">Code example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-usecases">Use Cases</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketnumber-generator-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticketevent">Ticket Event Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-code">Code example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-configuration">Configuration example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-usecases">Use Cases</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticketevent-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#frontend-modules">Frontend Modules</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#module-dashboard">Dashboard Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dashboard-module-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dashboard-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#notify-module">Notification Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#notify-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#notify-module-releases">Release Availability</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module">Ticket Menu Module</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-code">Code Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-configuration">Configuration Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-use_cases">Use Case Example</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-caveats">Caveats and Warnings</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-menu-module-releases">Release Availability</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#genericinterface-modules">Generic Interface Modules</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#transport">Network Transport</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_transport">Transport backend</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#mapping">Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_mapping">Mapping backend</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#invoker">Invoker</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_invoker">Invoker backend</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#operation">Operation</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_operation">Operation backend</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#scheduler-taskhandler-modules">Scheduler Task Handler Modules</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#task-handler">Task Handler</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#adding_taskhandler">Task Handler backend</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamicfields-modules">Dynamic Fields</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-overview">Overview</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework">Dynamic Fields Framework</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-backends">Dynamic Field Backend Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-admin">Dynamic Fields Admin Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-core">Dynamic Fields Core Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-database">Dynamic Fields Database Tables</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-framework-configuration-files">Dynamic Fields Configuration Files</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-interaction">Dynamic Field Interaction With Frontend Modules</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend">How To Extend The Dynamic Fields</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-new-field">Create a New Dynamic Field Type (for ticket or article objects)</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-new-field-new-object">Create a New Dynamic Field Type (for other objects)</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-new-packages">Create a New package to use Dynamic Fields</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-backend-functionalities">Extend Backend and Delegates Functionalities</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-extend-other">Other Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-new-field">Creating A New Dynamic Field</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#dynamic-fields-new-field-files">Dynamic Field Password files</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="otrs-module-layers.html#old-module-description">Old Module Descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="otrs-module-layers.html#module-navigation">Navigation Module</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#module-customer-navigation">Customer Navigation Module</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-postmaster-module">Ticket PostMaster Module</a></span></dt><dt><span class="section"><a href="otrs-module-layers.html#ticket-module-menu">Ticket Menu Module</a></span></dt></dl></dd></dl></div><p>
        OTRS has a large number of so-called "module layers" which make it very easy to extend
        the system without patching existing code. One example is the number generation mechanism
        for tickets. It is a "module layer" with
        <a class="link" href="otrs-module-layers.html#ticketnumber-generator" title="Ticket Number Generator Modules">pluggable modules</a>, and you can add
        your own custom number generator modules if you wish to do so.
        Let's look at the different layers in detail!
    </p><div class="section" title="Authentication and user management"><div class="titlepage"><div><div><h3 class="title"><a name="authentication-user-management-modules"></a>Authentication and user management</h3></div></div></div><div class="section" title="Agent Authentication Module"><div class="titlepage"><div><div><h4 class="title"><a name="agent-auth-module"></a>Agent Authentication Module</h4></div></div></div><p>
        There are several agent authentication modules (DB, LDAP and HTTPBasicAuth)
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The agent authentication modules are located under
        Kernel/System/Auth/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a simple agent auth module. Save it under Kernel/System/Auth/Simple.pm.
        You just need 3 functions: new(), GetOption() and Auth(). Return the uid, then the
        authentication is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called Kernel::System::Auth. The example agent authentication
            may be called Kernel::System::Auth::CustomAuth. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/CustomAuth.pm - provides the CustomAuth authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# ID: CustomAuth.pm,v 1.1 2010/05/10 15:30:34 fk Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Auth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost} = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Host$Param{Count}.";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need AuthModule::CustomAuth::Password$Param{Count}.";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authenticate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a radius object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom agent authenticate module.
            This can be done using the perl configuration below.
            It is not recommended to use the xml configuration because you can lock
            you out via the sysconfig.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthModule'} = 'Kernel::System::Auth::CustomAuth';
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            A useful example of an authentication implementation could be a soap backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="agent-auth-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>Radius</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Authentication Synchronisation Module"><div class="titlepage"><div><div><h4 class="title"><a name="auth-sync-module"></a>Authentication Synchronisation Module</h4></div></div></div><p>
        There is a LDAP authentication synchronisation module
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The authentication synchronisation modules are located under
        Kernel/System/Auth/Sync/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of an authentication synchronisation module.
        Save it under Kernel/System/Auth/Sync/CustomAuthSync.pm.
        You just need 2 functions: new() and Sync(). Return 1, then the
        synchronisation is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called Kernel::System::Auth. The example agent authentication
            may be called Kernel::System::Auth::Sync::CustomAuthSync. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Auth/Sync/CustomAuthSync.pm - provides the CustomAuthSync
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# Id: CustomAuthSync.pm,v 1.9 2010/03/25 14:42:45 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Auth::Sync::CustomAuthSync;

use strict;
use warnings;
use Net::LDAP;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.3 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject UserObject GroupObject EncodeObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

...

    return $Self;
}

sub Sync {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(User)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }
...
    return 1;
}

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            You should activate your custom synchronisation module.
            This can be done using the perl configuration below.
            It is not recommended to use the xml configuration because this
            would allow you to lock yourself out via SysConfig.
        </p><p>
        </p><pre class="programlisting">
            $Self-&gt;{'AuthSyncModule'} = 'Kernel::System::Auth::Sync::LDAP';
        </pre><p>
        </p></div><div class="section" title="Use Case Examples"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-use_cases"></a>Use Case Examples</h5></div></div></div><p>
            Useful synchronisation implementation could be a soap or radius backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>LDAP</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h5 class="title"><a name="auth-sync-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
        Please note that the synchronisation was part of the authentication class Kernel::System::Auth before framework 2.4.
        </p></div></div><div class="section" title="Customer Authentication Module"><div class="titlepage"><div><div><h4 class="title"><a name="customer-auth-module"></a>Customer Authentication Module</h4></div></div></div><p>
        There are several customer authentication modules (DB, LDAP and HTTPBasicAuth)
        which come with the OTRS framework. It is also possible to develop your own
        authentication modules. The customer authentication modules are located under
        Kernel/System/CustomerAuth/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a simple customer auth module. Save it under Kernel/System/CustomerAuth/Simple.pm.
        You just need 3 functions: new(), GetOption() and Auth(). Return the uid, then the
        authentication is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called Kernel::System::CustomerAuth. The example customer authentication
            may be called Kernel::System::CustomerAuth::CustomAuth. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerAuth/CustomAuth.pm - provides the custom Authentication
# based on Martin Edenhofer's Kernel::System::Auth::DB
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# Id: CustomAuth.pm,v 1.11 2009/09/22 15:16:05 mb Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::CustomerAuth::CustomAuth;

use strict;
use warnings;

use Authen::CustomAuth;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(LogObject ConfigObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "No $_!";
    }

    # Debug 0=off 1=on
    $Self-&gt;{Debug} = 0;

    # get config
    $Self-&gt;{Die}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Die' . $Param{Count} );

    # get user table
    $Self-&gt;{CustomAuthHost}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Host' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Host$Param{Count} in Kernel/Config.pm";
    $Self-&gt;{CustomAuthSecret}
        = $Self-&gt;{ConfigObject}-&gt;Get( 'Customer::AuthModule::CustomAuth::Password' . $Param{Count} )
        || die "Need Customer::AuthModule::CustomAuth::Password$Param{Count} in Kernel/Config.pm";

    return $Self;
}

sub GetOption {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{What} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need What!" );
        return;
    }

    # module options
    my %Option = ( PreAuth =&gt; 0, );

    # return option
    return $Option{ $Param{What} };
}

sub Auth {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{User} ) {
        $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need User!" );
        return;
    }

    # get params
    my $User       = $Param{User}      || '';
    my $Pw         = $Param{Pw}        || '';
    my $RemoteAddr = $ENV{REMOTE_ADDR} || 'Got no REMOTE_ADDR env!';
    my $UserID     = '';
    my $GetPw      = '';

    # just in case for debug!
    if ( $Self-&gt;{Debug} &gt; 0 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: '$User' tried to authentificate with Pw: '$Pw' ($RemoteAddr)",
        );
    }

    # just a note
    if ( !$User ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "No User given!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # just a note
    if ( !$Pw ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication without Pw!!! (REMOTE_ADDR: $RemoteAddr)",
        );
        return;
    }

    # Create a custom object
    my $CustomAuth = Authen::CustomAuth-&gt;new(
        Host   =&gt; $Self-&gt;{CustomAuthHost},
        Secret =&gt; $Self-&gt;{CustomAuthSecret},
    );
    if ( !$CustomAuth ) {
        if ( $Self-&gt;{Die} ) {
            die "Can't connect to $Self-&gt;{CustomAuthHost}: $@";
        }
        else {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Can't connect to $Self-&gt;{CustomAuthHost}: $@",
            );
            return;
        }
    }
    my $AuthResult = $CustomAuth-&gt;check_pwd( $User, $Pw );

    # login note
    if ( defined($AuthResult) &amp;&amp; $AuthResult == 1 ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication ok (REMOTE_ADDR: $RemoteAddr).",
        );
        return $User;
    }

    # just a note
    else {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'notice',
            Message  =&gt; "User: $User Authentication with wrong Pw!!! (REMOTE_ADDR: $RemoteAddr)"
        );
        return;
    }
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom customer authenticate module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="AuthModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to authenticate customers.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Modul zum Authentifizieren der Customer.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::CustomerAuthAuth&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/CustomerAuth/*.pm" SelectedID="Kernel::System::CustomerAuth::CustomAuth"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful authentification implementation could be a soap backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="customer-auth-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>1.0</td></tr><tr><td>HTTPBasicAuth</td><td>1.2</td></tr><tr><td>LDAP</td><td>1.0</td></tr><tr><td>Radius</td><td>1.3</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section" title="Preferences"><div class="titlepage"><div><div><h3 class="title"><a name="preferences-modules"></a>Preferences</h3></div></div></div><div class="section" title="Customer User Preferences Module"><div class="titlepage"><div><div><h4 class="title"><a name="customer-user-preferences-module"></a>Customer User Preferences Module</h4></div></div></div><p>
        There is a DB customer-user preferences module which come with the OTRS framework.
        It is also possible to develop your own customer-user preferences modules.
        The customer-user preferences modules are located under
        Kernel/System/CustomerUser/Preferences/*.pm. For more information about their configuration see the admin manual.
        There is an example of a customer-user preferences module below.
        Save it under Kernel/System/CustomerUser/Preferences/Custom.pm.
        You just need 4 functions: new(), SearchPreferences(), SetPreferences() and GetPreferences().
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called Kernel::System::CustomerUser. The example customer-user preferences
            may be called Kernel::System::CustomerUser::Preferences::Custom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/CustomerUser/Preferences/Custom.pm - some customer user functions
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# Id: Custom.pm,v 1.20 2009/10/07 20:41:50 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::CustomerUser::Preferences::Custom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable} = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{Table}
        || 'customer_preferences';
    $Self-&gt;{PreferencesTableKey}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableKey}
        || 'preferences_key';
    $Self-&gt;{PreferencesTableValue}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableValue}
        || 'preferences_value';
    $Self-&gt;{PreferencesTableUserID}
        = $Self-&gt;{ConfigObject}-&gt;Get('CustomerPreferences')-&gt;{Params}-&gt;{TableUserID}
        || 'user_id';

    return $Self;
}

sub SetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my $Key    = $Param{Key}    || return;
    my $Value = defined( $Param{Value} ) ? $Param{Value} : '';

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . " $Self-&gt;{PreferencesTableUserID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$UserID, \$Key ],
    );

    $Value .= 'Custom';

    # insert new data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableUserID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$UserID, \$Key, \$Value ],
    );

    return 1;
}

sub GetPreferences {
    my ( $Self, %Param ) = @_;

    my $UserID = $Param{UserID} || return;
    my %Data;

    # get preferences

    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableUserID} = ?",
        Bind =&gt; [ \$UserID ],
    );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

sub SearchPreferences {
    my ( $Self, %Param ) = @_;

    my %UserID;
    my $Key   = $Param{Key}   || '';
    my $Value = $Param{Value} || '';

    # get preferences
    my $SQL = "SELECT $Self-&gt;{PreferencesTableUserID}, $Self-&gt;{PreferencesTableValue} "
        . " FROM "
        . " $Self-&gt;{PreferencesTable} "
        . " WHERE "
        . " $Self-&gt;{PreferencesTableKey} = '"
        . $Self-&gt;{DBObject}-&gt;Quote($Key) . "'" . " AND "
        . " LOWER($Self-&gt;{PreferencesTableValue}) LIKE LOWER('"
        . $Self-&gt;{DBObject}-&gt;Quote( $Value, 'Like' ) . "')";

    return if !$Self-&gt;{DBObject}-&gt;Prepare( SQL =&gt; $SQL );
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $UserID{ $Row[0] } = $Row[1];
    }

    # return data
    return %UserID;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom customer-user preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="CustomerPreferences" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the customer preference table.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Parameter für die Tabelle mit den Einstellungen für die Customer.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Customer::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::System::CustomerUser::Preferences::Custom&lt;/Item&gt;
            &lt;Item  Key="Params"&gt;
                &lt;Hash&gt;
                    &lt;Item Key="Table"&gt;customer_preferences&lt;/Item&gt;
                    &lt;Item Key="TableKey"&gt;preferences_key&lt;/Item&gt;
                    &lt;Item Key="TableValue"&gt;preferences_value&lt;/Item&gt;
                    &lt;Item Key="TableUserID"&gt;user_id&lt;/Item&gt;
                &lt;/Hash&gt;
            &lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful preferences implementation could be a soap or ldap backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="customer-user-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>DB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Queue Preferences Module"><div class="titlepage"><div><div><h4 class="title"><a name="queue-preferences-module"></a>Queue Preferences Module</h4></div></div></div><p>
        There is a DB queue preferences module which come with the OTRS framework.
        It is also possible to develop your own queue preferences modules.
        The queue preferences modules are located under
        Kernel/System/Queue/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a queue preferences module.
        Save it under Kernel/System/Queue/PreferencesCustom.pm.
        You just need 3 functions: new(), QueuePreferencesSet() and QueuePreferencesGet(). Return 1, then the
        synchronisation is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called Kernel::System::Queue. The example queue preferences
            may be called Kernel::System::Queue::PreferencesCustom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Queue/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# Id: PreferencesCustom.pm,v 1.5 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Queue::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}        = 'queue_preferences';
    $Self-&gt;{PreferencesTableKey}     = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}   = 'preferences_value';
    $Self-&gt;{PreferencesTableQueueID} = 'queue_id';

    return $Self;
}

sub QueuePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableQueueID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key} ],
    );

    $Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableQueueID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{QueueID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub QueuePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(QueueID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if queue preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('QueuePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableQueueID} = ?",
        Bind =&gt; [ \$Param{QueueID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom queue preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Queue::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default queue preferences module.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Standard Queue Preferences Module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Queue::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Queue::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Examples"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-use_cases"></a>Use Case Examples</h5></div></div></div><p>
            Useful preferences implementation could be a soap or radius backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="queue-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.3</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Service Preferences Module"><div class="titlepage"><div><div><h4 class="title"><a name="service-preferences-module"></a>Service Preferences Module</h4></div></div></div><p>
        There is a DB service preferences module which come with the OTRS framework.
        It is also possible to develop your own service preferences modules.
        The service preferences modules are located under
        Kernel/System/Service/*.pm. For more information about their configuration see the admin manual.
        Following, there is an example of a service preferences module.
        Save it under Kernel/System/Service/PreferencesCustom.pm.
        You just need 3 functions: new(), ServicePreferencesSet() and ServicePreferencesGet(). Return 1, then the
        synchronisation is ok.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called Kernel::System::Service. The example service preferences
            may be called Kernel::System::Service::PreferencesCustom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Service/PreferencesCustom - some user functions
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# Id: PreferencesCustom.pm,v 1.2 2009/02/16 11:47:34 tr Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Service::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}          = 'service_preferences';
    $Self-&gt;{PreferencesTableKey}       = 'preferences_key';
    $Self-&gt;{PreferencesTableValue}     = 'preferences_value';
    $Self-&gt;{PreferencesTableServiceID} = 'service_id';

    return $Self;
}

sub ServicePreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableServiceID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableServiceID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{ServiceID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub ServicePreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ServiceID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if service preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('ServicePreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableServiceID} = ?",
        Bind =&gt; [ \$Param{ServiceID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom service preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Service::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Default service preferences module.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Standard Service Preferences Module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Service::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::Service::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful preferences implementation could be a soap or radius backend.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="service-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="SLA Preferences Module"><div class="titlepage"><div><div><h4 class="title"><a name="sla-preferences-module"></a>SLA Preferences Module</h4></div></div></div><p>
        There is a DB SLA preferences module which come with the OTRS framework.
        It is also possible to develop your own SLA preferences modules.
        The SLA preferences modules are located under
        Kernel/System/SLA/*.pm. For more information about their configuration see the admin manual.
        Here we'll show an example of an SLA preferences module.
        Save it under Kernel/System/SLA/PreferencesCustom.pm.
        You just need 3 functions: new(), SLAPreferencesSet() and SLAPreferencesGet(). 
        Make sure the function returns 1.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-code"></a>Code Example</h5></div></div></div><p>
            The interface class is called Kernel::System::SLA. The example SLA preferences
            may be called Kernel::System::SLA::PreferencesCustom. You can find an example below.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/SLA/PreferencesCustom.pm - some user functions
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::SLA::PreferencesCustom;

use strict;
use warnings;

use vars qw(@ISA);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for (qw(DBObject ConfigObject LogObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    # preferences table data
    $Self-&gt;{PreferencesTable}      = 'sla_preferences';
    $Self-&gt;{PreferencesTableKey}   = 'preferences_key';
    $Self-&gt;{PreferencesTableValue} = 'preferences_value';
    $Self-&gt;{PreferencesTableSLAID} = 'sla_id';

    return $Self;
}

sub SLAPreferencesSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID Key Value)) {
        if ( !defined( $Param{$_} ) ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # delete old data
    return if !$Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "DELETE FROM $Self-&gt;{PreferencesTable} WHERE "
            . "$Self-&gt;{PreferencesTableSLAID} = ? AND $Self-&gt;{PreferencesTableKey} = ?",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key} ],
    );

$Self-&gt;{PreferencesTableValue} .= 'PreferencesCustom';

    # insert new data
    return $Self-&gt;{DBObject}-&gt;Do(
        SQL =&gt; "INSERT INTO $Self-&gt;{PreferencesTable} ($Self-&gt;{PreferencesTableSLAID}, "
            . " $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue}) "
            . " VALUES (?, ?, ?)",
        Bind =&gt; [ \$Param{SLAID}, \$Param{Key}, \$Param{Value} ],
    );
}

sub SLAPreferencesGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(SLAID)) {
        if ( !$Param{$_} ) {
            $Self-&gt;{LogObject}-&gt;Log( Priority =&gt; 'error', Message =&gt; "Need $_!" );
            return;
        }
    }

    # check if service preferences are available
    if ( !$Self-&gt;{ConfigObject}-&gt;Get('SLAPreferences') ) {
        return;
    }

    # get preferences
    return if !$Self-&gt;{DBObject}-&gt;Prepare(
        SQL =&gt; "SELECT $Self-&gt;{PreferencesTableKey}, $Self-&gt;{PreferencesTableValue} "
            . " FROM $Self-&gt;{PreferencesTable} WHERE $Self-&gt;{PreferencesTableSLAID} = ?",
        Bind =&gt; [ \$Param{SLAID} ],
    );
    my %Data;
    while ( my @Row = $Self-&gt;{DBObject}-&gt;FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # return data
    return %Data;
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            You need to register your custom SLA preferences module.
            This can be done using the xml configuration below.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="SLA::PreferencesModule" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Default SLA preferences module.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::SLA::Preferences&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;String Regex=""&gt;Kernel::System::SLA::PreferencesCustom&lt;/String&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful preferences implementation could be to store additional values on SLAs.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="sla-preferences-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>PreferencesDB</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section" title="Other core functions"><div class="titlepage"><div><div><h3 class="title"><a name="core-modules"></a>Other core functions</h3></div></div></div><div class="section" title="Log Module"><div class="titlepage"><div><div><h4 class="title"><a name="log-module"></a>Log Module</h4></div></div></div><p>
There is a gobal log interface for OTRS that provides the possibility to create own log backends.
    </p><p>
Writing an own logging backend is as easy as reimplementing the Kernel::System::Log::Log() method.
    </p><div class="section" title="Code example: Kernel::System::Log::CustomFile"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-code"></a>Code example: Kernel::System::Log::CustomFile</h5></div></div></div><p>
            In this small example, we'll write a little file logging backend which works similar to
            Kernel::System::Log::File, but prepends a string to each logging entry.
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/System/Log/CustomFile.pm - file log backend
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Log::CustomFile;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

umask "002";

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for (qw(ConfigObject EncodeObject)) {
        if ( $Param{$_} ) {
            $Self-&gt;{$_} = $Param{$_};
        }
        else {
            die "Got no $_!";
        }
    }

    # get logfile location
    $Self-&gt;{LogFile} = '/var/log/CustomFile.log';

    # set custom prefix
    $Self-&gt;{CustomPrefix} = 'CustomFileExample';

    # Fixed bug# 2265 - For IIS we need to create a own error log file.
    # Bind stderr to log file, because iis do print stderr to web page.
    if ( $ENV{SERVER_SOFTWARE} &amp;&amp; $ENV{SERVER_SOFTWARE} =~ /^microsoft\-iis/i ) {
        if ( !open STDERR, '&gt;&gt;', $Self-&gt;{LogFile} . '.error' ) {
            print STDERR "ERROR: Can't write $Self-&gt;{LogFile}.error: $!";
        }
    }

    return $Self;
}

sub Log {
    my ( $Self, %Param ) = @_;

    my $FH;

    # open logfile
    if ( !open $FH, '&gt;&gt;', $Self-&gt;{LogFile} ) {

        # print error screen
        print STDERR "\n";
        print STDERR " &gt;&gt; Can't write $Self-&gt;{LogFile}: $! &lt;&lt;\n";
        print STDERR "\n";
        return;
    }

    # write log file
    $Self-&gt;{EncodeObject}-&gt;SetIO($FH);
    print $FH '[' . localtime() . ']';
    if ( lc $Param{Priority} eq 'debug' ) {
        print $FH "[Debug][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'info' ) {
        print $FH "[Info][$Param{Module}]  $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'notice' ) {
        print $FH "[Notice][$Param{Module}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    elsif ( lc $Param{Priority} eq 'error' ) {
        print $FH "[Error][$Param{Module}][$Param{Line}] $Self-&gt;{CustomPrefix} $Param{Message}\n";
    }
    else {

        # print error messages to STDERR
        print STDERR
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";

        # and of course to logfile
        print $FH
            "[Error][$Param{Module}] $Self-&gt;{CustomPrefix} Priority: '$Param{Priority}' not defined! Message: $Param{Message}\n";
    }

    # close file handle
    close $FH;
    return 1;
}

1;
        </pre><p>
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-configuration"></a>Configuration example</h5></div></div></div><p>
            To activate our custom logging module, the administrator can either set the existing
            configuration item "LogModule" manually to "Kernel::System::Log::CustomFile". To realize
            this automatically, you can provide an XML configuration file which overrides the default
            setting.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="LogModule" Required="1" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;Set Kernel::System::Log::CustomFile as default logging backend.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Core::Log&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Option Location="Kernel/System/Log/*.pm" SelectedID="Kernel::System::Log::CustomFile"&gt;&lt;/Option&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use case examples"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-use_cases"></a>Use case examples</h5></div></div></div><p>
Useful logging backends could be logging to a web service or to encrypted files.
        </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h5 class="title"><a name="log-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
Please note that Kernel::System::Log has other methods than Log() which cannot be reimplemented,
for example code for working with shared memory segments and log data caching.
        </p></div></div><div class="section" title="Output Filter"><div class="titlepage"><div><div><h4 class="title"><a name="outputfilter"></a>Output Filter</h4></div></div></div><p>
        Output filters allow to modify HTML on the fly. It is best practice to use output filters
        instead of modifying <code class="filename">.dtl</code> files directly.
        There are three good reasons for that.
        When the same adaption has to be applied to several frontend modules
        then the adaption only has to be implemented once.
        The second advantage is that when OTRS is upgraded
        there is a chance that the filter doesn't have to be updated, when the relevant pattern has not changed.
        When two extensions modify the same file there is a conflict during the installation of the second package.
        This conflict can be resolved by using two output filters that modify the same frontend module.
    </p><p>
        There are four different kinds of output filters. They are active at different stages of the
        generation of HTML content.
    </p><div class="section" title="FilterElementPre"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filterelement_pre"></a>FilterElementPre</h5></div></div></div><p>
            The content of a template can be changed by the filter before any processing by the Layout module takes place.
            This kind of filter should be used in most cases.
            Processing instructions like $Text{"..."}, $QData{"..."} can be inserted
            into the template content and they will be honored by the subsequent DTL processing.
        </p></div><div class="section" title="FilterElementPost"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filterelement_post"></a>FilterElementPost</h5></div></div></div><p>
            The content of a template can be changed after variable substitution and translation.
            The kind of filter should only be used when the filter needs access to translated strings
            or to substituted variables.
        </p></div><div class="section" title="FilterContent"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filtercontent"></a>FilterContent</h5></div></div></div><p>
            This kind of filter allows to process the complete HTML output for the request
            right before it is sent to the browser.
            This can be used for global transformations.
            But in real life there is rarely a need to use this kind of filter.
        </p></div><div class="section" title="FilterText"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter_filtertest"></a>FilterText</h5></div></div></div><p>
            This kind of output filter is a plugin for the method
            Kernel::Output::HTML::Layout::Ascii2HTML()
            and is only active when the parameter LinkFeature is set to 1.
            Thus the FilterText output filters are currently only active for the display of
            the body of plain text articles.
            Plain text articles are generated by incoming non-HTML mails
            and when OTRS is configured to not use the rich text feature in the frontend.
        </p></div><div class="section" title="Code example"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-code"></a>Code example</h5></div></div></div><p>
            See package TemplateModule.
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-configuration"></a>Configuration example</h5></div></div></div><p>
            See package TemplateModule.
        </p></div><div class="section" title="Use Cases"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-usecases"></a>Use Cases</h5></div></div></div><div class="section" title="Show additional ticket attributes in AgentTicketZoom."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-10"></a>Show additional ticket attributes in AgentTicketZoom.</h6></div></div></div><p>
                All ticket attributes are passed to the AgentTicketZoom template.
                Therefore it suffices to insert e.g. the instruction $QData{"Title"} into the content.
                This can be achieved with a FilterElementPre output filter.
            </p></div><div class="section" title="Add an additional CSS file."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-20"></a>Add an additional CSS file.</h6></div></div></div><p>
                An additional CSS file can be added to all agent frontends with an FilterElementPre filter
                that only modifies <code class="filename">Header.dtl</code>.
                Therefore it suffices to insert e.g. the instruction $QData{"Title"} into the content.
                This can be achieved with a FilterElementPre output filter.
            </p></div><div class="section" title="Show the service selection as a multi level menu."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-30"></a>Show the service selection as a multi level menu.</h6></div></div></div><p>
                Use a FilterElementPost for this feature.
                The list of selectable services can be parsed from the processed template
                output. The multi level selection can be constructed from the service list and
                inserted into the template content. A FilterElementPost output filter must be used for that.
            </p></div><div class="section" title="Create links within plain text article bodies."><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-40"></a>Create links within plain text article bodies.</h6></div></div></div><p>
                A biotech company uses gene names like IPI00217472 in plain text articles.
                A FilterText output filter can be used to create links to a sequence database,
                e.g. http://srs.ebi.ac.uk/srsbin/cgi-bin/wgetz?-e+[IPI-acc:IPI00217472]+-vn+2,
                for the gene names.
            </p></div><div class="section" title="Prohibit active content"><div class="titlepage"><div><div><h6 class="title"><a name="outputfilter-usecase-50"></a>Prohibit active content</h6></div></div></div><p>
                There is firewall rule that disallows all active content. In order to avoid rejection by the firewall
                the HTML tag &lt;applet&gt; can be filtered with an FilterContent output filter.
            </p></div></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
            Every ElementPre and ElementPost output filter is constructed and run
            for every Template that is needed for the current request.
            Thus low performance of the output filter or a large number of filters can
            severely degrade performance.
            When that becomes an issue, the construction of
            needed objects can be done in the Run-method after the checks.
            Thus the expensive code is run only in the relevant cases.
        </p></div><div class="section" title="Best Practices"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-bestpractice"></a>Best Practices</h5></div></div></div><p>
            In order to increase flexibility the list of affected templates should be
            configurable in SysConfig.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="outputfilter-releases"></a>Release Availability</h5></div></div></div><p>
            The four kinds of output filters are available in OTRS 2.4.
        </p></div></div><div class="section" title="Stats Module"><div class="titlepage"><div><div><h4 class="title"><a name="module-stats"></a>Stats Module</h4></div></div></div><p>
There are two different types of internal stats modules - dynamic and static. This section describes how such stats modules can be developed.
    </p><div class="section" title="Dynamic Stats"><div class="titlepage"><div><div><h5 class="title"><a name="module-stats-dynamic"></a>Dynamic Stats</h5></div></div></div><p>
In contrast to static stats modules, dynamic statistics can be configured via the OTRS web interface. In this section a simple statistic module is developed. Each dynamic stats module has to implement these subroutines
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>GetObjectName</p></li><li class="listitem"><p>GetObjectAttributes</p></li><li class="listitem"><p>ExportWrapper</p></li><li class="listitem"><p>ImportWrapper</p></li></ul></div><p>
        </p><p>
Furthermore the module has to implement either GetStatElement or GetStatTable. And if the header line of the result table should be changed, a sub called GetHeaderLine has to be developed.
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-subroutines"></a>Code example</h6></div></div></div><p>
In this section a sample stats module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];
                </pre><p>
            </p><p>
This is common boilerplate that can be found in common OTRS modules. The class/package name is declared via the package keyword. Then the needed modules are 'use'd.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # created needed objects
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
new is the constructor for this statistic module. It creates a new instance of the class. According to the coding guidelines objects of other classes that are needed in this module have to be created in "new". In lines 27 to 29 the object of the stats module is created. Lines 31 to 37 check if objects that are needed in this code - either for creating other objects or in this module - are passed. After that the other objects are created.
            </p><p>
                </p><pre class="programlisting">
sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Sample Statistics';
}
                </pre><p>
            </p><p>
GetObjectName returns a Name for the Statistics module. This is the label that is shown in the drop down in the configuration as well as in the list of existing statistics (column "object").
            </p><p>
                </p><pre class="programlisting">
sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # get state list
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # get queue list
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # get current time to fix bug#3830
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'State',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Create Time',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}
                </pre><p>
            </p><p>
In this sample stats module, we want to provide three attributes the user can chose from: A list of queues, a list of states an a time drop down. To get the values shown in the drop down, some operations are needed. In this case call StateList and GetAllQueues.
            </p><p>
Then the list of attributes is created. Each attribute is defined via a hashreference. You can use these keys:
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Name</p><p>the label in the web interface</p></li><li class="listitem"><p>UseAsXvalue</p><p>Can this attribute be used on the x-axis</p></li><li class="listitem"><p>UseAsValueSeries</p><p>Can this attribute be used on the y-axis</p></li><li class="listitem"><p>UseAsRestriction</p><p>Can this attribute be used for restrictions.</p></li><li class="listitem"><p>Element</p><p>the HTML fieldname</p></li><li class="listitem"><p>Block</p><p>the block name in the template file (e.g. &lt;OTRS_HOME&gt;/Kernel/Output/HTML/Standard/AgentStatsEditXaxis.dtl)</p></li><li class="listitem"><p>Values</p><p>the values shown in the attribute</p></li></ul></div><p>
            </p><p>
Hint: If you install this sample an you configured a statistic with some queues - lets say 'queue A' and 'queue B' - then these queues are the only ones that are shown to the user when he starts the statistic. Sometimes a dynamic drop down or multiselect field is needed. In this case, you can set "SelectedValues" in the definition of the attribute:
            </p><p>
                </p><pre class="programlisting">
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
            SelectedValues   =&gt; [ @SelectedQueues ],
        },
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # search tickets
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}
                </pre><p>
            </p><p>
GetStatElement gets called for each cell in the result table. So it should be a numeric value. In this sample it does a simple ticket search. The hash %Param contains information about the "current" x-value and the y-value as well as any restrictions. So, for a cell that should count the created tickets for queue 'Misc' with state 'open' the passed parameter hash looks something like this:
            </p><p>
                </p><pre class="programlisting">
    'CreatedQueueIDs' =&gt; [
        '4'
    ],
    'StateIDs' =&gt; [
        '2'
    ]
                </pre><p>
            </p><p>
If the "per cell" calculation should be avoided, GetStatTable is an alternative. GetStatTable returns a list of rows, hence an array of arrayreferences. This leads to the same result as using GetStatElement
            </p><p>
                </p><pre class="programlisting">
sub GetStatTable {
    my ( $Self, %Param ) = @_;

    my @StatData;

    for my $StateName ( keys %{ $Param{TableStructure} } ) {
        my @Row;
        for my $Params ( @{ $Param{TableStructure}-&gt;{$StateName} } ) {
            my $Tickets = $Self-&gt;{TicketObject}-&gt;TicketSearch(
                UserID     =&gt; 1,
                Result     =&gt; 'COUNT',
                Permission =&gt; 'ro',
                Limit      =&gt; 100_000_000,
                %{$Params},
            );

            push @Row, $Tickets;
        }

        push @StatData, [ $StateName, @Row ];
    }

    return @StatData;
}
                </pre><p>
            </p><p>
GetStatTable gets all information about the stats query that is needed. The passed parameters contains information about the attributes (Restrictions, attributes that are used for x/y-axis) and the table structure. The table structure is a hash reference where the keys are the values of the y-axis and their values are hashreferences with the parameters used for GetStatElement subroutines.
            </p><p>
                </p><pre class="programlisting">
    'Restrictions' =&gt; {},
    'TableStructure' =&gt; {
        'closed successful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '2'
                ]
            },
        ],
        'closed unsuccessful' =&gt; [
            {
                'CreatedQueueIDs' =&gt; [
                    '3'
                ],
                'StateIDs' =&gt; [
                    '3'
                ]
            },
        ],
    },
    'ValueSeries' =&gt; [
        {
            'Block' =&gt; 'MultiSelectField',
            'Element' =&gt; 'StateIDs',
            'Name' =&gt; 'State',
            'SelectedValues' =&gt; [
                '5',
                '3',
                '2',
                '1',
                '4'
            ],
            'Translation' =&gt; 1,
            'Values' =&gt; {
                '1' =&gt; 'new',
                '10' =&gt; 'closed with workaround',
                '2' =&gt; 'closed successful',
                '3' =&gt; 'closed unsuccessful',
                '4' =&gt; 'open',
                '5' =&gt; 'removed',
                '6' =&gt; 'pending reminder',
                '7' =&gt; 'pending auto close+',
                '8' =&gt; 'pending auto close-',
                '9' =&gt; 'merged'
            }
        }
    ],
    'XValue' =&gt; {
        'Block' =&gt; 'MultiSelectField',
        'Element' =&gt; 'CreatedQueueIDs',
        'Name' =&gt; 'Created in Queue',
        'SelectedValues' =&gt; [
            '3',
            '4',
            '1',
            '2'
        ],
        'Translation' =&gt; 0,
        'Values' =&gt; {
            '1' =&gt; 'Postmaster',
            '2' =&gt; 'Raw',
            '3' =&gt; 'Junk',
            '4' =&gt; 'Misc'
        }
    }
                </pre><p>
            </p><p>
Sometimes the headers of the table have to be changed. In that case, a subroutine called GetHeaderLine has to be implemented. That subroutine has to return an arrayreference with the column headers as elements. It gets information about the x-values passed.
            </p><p>
                </p><pre class="programlisting">
sub GetHeaderLine {
    my ( $Self, %Param ) = @_;

    my @HeaderLine = ('');
    for my $SelectedXValue ( @{ $Param{XValue}-&gt;{SelectedValues} } ) {
        push @HeaderLine, $Param{XValue}-&gt;{Values}-&gt;{$SelectedXValue};
    }

    return \@HeaderLine;
}
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap ids to used spelling
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}
                </pre><p>
            </p><p>
Configured statistics can be exported into XML format. But as queues with the same queue names can have different IDs on different OTRS instances it would be quite painful to export the IDs (the statistics would calculate the wrong numbers then). So an export wrapper should be written to use the names instead of ids. This should be done for each "dimension" of the stats module (x-axis, y-axis and restrictions).
            </p><p>
ImportWrapper works the other way around - it converts the name to the ID in the instance the configuration is imported to.
            </p><p>
This is a sample export:
            </p><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;otrs_stats&gt;
&lt;Cache&gt;0&lt;/Cache&gt;
&lt;Description&gt;Sample stats module&lt;/Description&gt;
&lt;File&gt;&lt;/File&gt;
&lt;Format&gt;CSV&lt;/Format&gt;
&lt;Format&gt;Print&lt;/Format&gt;
&lt;Object&gt;DeveloperManualSample&lt;/Object&gt;
&lt;ObjectModule&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/ObjectModule&gt;
&lt;ObjectName&gt;Sample Statistics&lt;/ObjectName&gt;
&lt;Permission&gt;stats&lt;/Permission&gt;
&lt;StatType&gt;dynamic&lt;/StatType&gt;
&lt;SumCol&gt;0&lt;/SumCol&gt;
&lt;SumRow&gt;0&lt;/SumRow&gt;
&lt;Title&gt;Sample 1&lt;/Title&gt;
&lt;UseAsValueSeries Element="StateIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;removed&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed unsuccessful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;closed successful&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;new&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;open&lt;/SelectedValues&gt;
&lt;/UseAsValueSeries&gt;
&lt;UseAsXvalue Element="CreatedQueueIDs" Fixed="1"&gt;
&lt;SelectedValues&gt;Junk&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Misc&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Postmaster&lt;/SelectedValues&gt;
&lt;SelectedValues&gt;Raw&lt;/SelectedValues&gt;
&lt;/UseAsXvalue&gt;
&lt;Valid&gt;1&lt;/Valid&gt;
&lt;/otrs_stats&gt;
                </pre><p>
            </p><p>
Now, that all subroutines are explained, this is the complete sample stats module.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Dynamic/DynamicStatsTemplate.pm - all advice functions
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Stats::Dynamic::DynamicStatsTemplate;

use strict;
use warnings;

use Kernel::System::Queue;
use Kernel::System::State;
use Kernel::System::Ticket;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (
        qw(DBObject ConfigObject LogObject UserObject TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    # created needed objects
    $Self-&gt;{QueueObject}    = Kernel::System::Queue-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject}   = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{StateObject}    = Kernel::System::State-&gt;new( %{$Self} );

    return $Self;
}

sub GetObjectName {
    my ( $Self, %Param ) = @_;

    return 'Sample Statistics';
}

sub GetObjectAttributes {
    my ( $Self, %Param ) = @_;

    # get state list
    my %StateList = $Self-&gt;{StateObject}-&gt;StateList(
        UserID =&gt; 1,
    );

    # get queue list
    my %QueueList = $Self-&gt;{QueueObject}-&gt;GetAllQueues();

    # get current time to fix bug#3830
    my $TimeStamp = $Self-&gt;{TimeObject}-&gt;CurrentTimestamp();
    my ($Date) = split /\s+/, $TimeStamp;
    my $Today = sprintf "%s 23:59:59", $Date;

    my @ObjectAttributes = (
        {
            Name             =&gt; 'State',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'StateIDs',
            Block            =&gt; 'MultiSelectField',
            Values           =&gt; \%StateList,
        },
        {
            Name             =&gt; 'Created in Queue',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreatedQueueIDs',
            Block            =&gt; 'MultiSelectField',
            Translation      =&gt; 0,
            Values           =&gt; \%QueueList,
        },
        {
            Name             =&gt; 'Create Time',
            UseAsXvalue      =&gt; 1,
            UseAsValueSeries =&gt; 1,
            UseAsRestriction =&gt; 1,
            Element          =&gt; 'CreateTime',
            TimePeriodFormat =&gt; 'DateInputFormat',    # 'DateInputFormatLong',
            Block            =&gt; 'Time',
            TimeStop         =&gt; $Today,
            Values           =&gt; {
                TimeStart =&gt; 'TicketCreateTimeNewerDate',
                TimeStop  =&gt; 'TicketCreateTimeOlderDate',
            },
        },
    );

    return @ObjectAttributes;
}

sub GetStatElement {
    my ( $Self, %Param ) = @_;

    # search tickets
    return $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'COUNT',
        Permission =&gt; 'ro',
        Limit      =&gt; 100_000_000,
        %Param,
    );
}

sub ExportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap ids to used spelling
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $Self-&gt;{QueueObject}-&gt;QueueLookup( QueueID =&gt; $ID-&gt;{Content} );
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                my %StateList = $Self-&gt;{StateObject}-&gt;StateList( UserID =&gt; 1 );
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    $ID-&gt;{Content} = $StateList{ $ID-&gt;{Content} };
                }
            }
        }
    }
    return \%Param;
}

sub ImportWrapper {
    my ( $Self, %Param ) = @_;

    # wrap used spelling to ids
    for my $Use (qw(UseAsValueSeries UseAsRestriction UseAsXvalue)) {
        ELEMENT:
        for my $Element ( @{ $Param{$Use} } ) {
            next ELEMENT if !$Element || !$Element-&gt;{SelectedValues};
            my $ElementName = $Element-&gt;{Element};
            my $Values      = $Element-&gt;{SelectedValues};

            if ( $ElementName eq 'QueueIDs' || $ElementName eq 'CreatedQueueIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;
                    if ( $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} ) ) {
                        $ID-&gt;{Content}
                            = $Self-&gt;{QueueObject}-&gt;QueueLookup( Queue =&gt; $ID-&gt;{Content} );
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find the queue $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
            elsif ( $ElementName eq 'StateIDs' || $ElementName eq 'CreatedStateIDs' ) {
                ID:
                for my $ID ( @{$Values} ) {
                    next ID if !$ID;

                    my %State = $Self-&gt;{StateObject}-&gt;StateGet(
                        Name  =&gt; $ID-&gt;{Content},
                        Cache =&gt; 1,
                    );
                    if ( $State{ID} ) {
                        $ID-&gt;{Content} = $State{ID};
                    }
                    else {
                        $Self-&gt;{LogObject}-&gt;Log(
                            Priority =&gt; 'error',
                            Message  =&gt; "Import: Can' find state $ID-&gt;{Content}!"
                        );
                        $ID = undef;
                    }
                }
            }
        }
    }
    return \%Param;
}

1;
                </pre><p>
            </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-configuration"></a>Configuration example</h6></div></div></div><p>
                </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;otrs_config version="1.0" init="Config"&gt;
    &lt;ConfigItem Name="Stats::DynamicObjectRegistration###DynamicStatsTemplate" Required="0" Valid="1"&gt;
        &lt;Description Lang="en"&gt;Here you can decide if the common stats module may generate stats about the number of default tickets a requester created.&lt;/Description&gt;
        &lt;Group&gt;Framework&lt;/Group&gt;
        &lt;SubGroup&gt;Core::Stats&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="Module"&gt;Kernel::System::Stats::Dynamic::DynamicStatsTemplate&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
&lt;/otrs_config&gt;
                </pre><p>
            </p></div><div class="section" title="Use case examples"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-use_cases"></a>Use case examples</h6></div></div></div><p>
Use cases.
            </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
If you have a lot of cells in the result table and the GetStatElement is quite complex, the request can take a long time.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-dynamic-releases"></a>Release Availability</h6></div></div></div><p>
Dynamic stat modules are available since OTRS 2.0.
            </p></div></div><div class="section" title="Static Stats"><div class="titlepage"><div><div><h5 class="title"><a name="module-stats-static"></a>Static Stats</h5></div></div></div><p>
The subsequent paragraphs describe the static stats. Static stats are very easy to create as these modules have to implement only three subroutines.
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>Param</p></li><li class="listitem"><p>Run</p></li></ul></div><p>
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-subroutines"></a>Code example</h6></div></div></div><p>
The following paragraphs describe the subroutines needed in a static stats.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # check all needed objects
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed";
    }

    # create needed objects
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}
                </pre><p>
            </p><p>
new creates a new instance of the static stats class. First it creates a new object and then it checks for the needed objects.
            </p><p>
                </p><pre class="programlisting">
sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}
                </pre><p>
            </p><p>
The Param method provides the list of all parameters/attributes that can be selected to create a static stat. It gets some parameters passed: The values for the stats attributes provided in a request, the format of the stats and the name of the object (name of the module).
            </p><p>
The parameters/attributes have to be hashreferences with these key-value-pairs.
            </p><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Frontent</p><p>the label in the web interface</p></li><li class="listitem"><p>Name</p><p>the HTML fieldname</p></li><li class="listitem"><p>Data</p><p>the values shown in the attribute</p></li></ul></div><p>
            </p><p>
Other parameter for the BuildSelection method of the LayoutObject can be used, as it is done with "Size" and "Multiple" in this sample module.
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );
            return;
        }
    }

    # set report title
    my $Title = 'Tickets per Queue';

    # table headlines
    my @HeadData = (
        'Ticket Number',
        'Queue',
        'Type',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}
                </pre><p>
            </p><p>
The Run method actually generates the table data for the stats. It gets the attributes for this stats passed. In this sample it in %Param a key 'TypeIDs' and a key 'QueueIDs' exist (see attributes in Param method) and their values are arrayreferences. The returned data consists of three parts: Two arrayreferences and an array. In the first arrayreference the title for the statistic is stored, the second arrayreference contains the headlines for the columns in the table. And then the data for the table body follow.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/System/Stats/Static/StaticStatsTemplate.pm
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Stats::Static::StaticStatsTemplate;

use strict;
use warnings;

use Kernel::System::Type;
use Kernel::System::Ticket;
use Kernel::System::Queue;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

=head1 NAME

StaticStatsTemplate.pm - the module that creates the stats about tickets in a queue

=head1 SYNOPSIS

All functions

=head1 PUBLIC INTERFACE

=over 4

=cut

=item new()

create an object

    use Kernel::Config;
    use Kernel::System::Encode;
    use Kernel::System::Log;
    use Kernel::System::Main;
    use Kernel::System::Time;
    use Kernel::System::DB;
    use Kernel::System::Stats::Static::StaticStatsTemplate;

    my $ConfigObject = Kernel::Config-&gt;new();
    my $EncodeObject = Kernel::System::Encode-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $LogObject    = Kernel::System::Log-&gt;new(
        ConfigObject =&gt; $ConfigObject,
    );
    my $MainObject = Kernel::System::Main-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $TimeObject = Kernel::System::Time-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
    );
    my $DBObject = Kernel::System::DB-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
    );
    my $StatsObject = Kernel::System::Stats::Static::StaticStatsTemplate-&gt;new(
        ConfigObject =&gt; $ConfigObject,
        LogObject    =&gt; $LogObject,
        MainObject   =&gt; $MainObject,
        TimeObject   =&gt; $TimeObject,
        DBObject     =&gt; $DBObject,
        EncodeObject =&gt; $EncodeObject,
    );

=cut

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # check all needed objects
    for my $Needed (
        qw(DBObject ConfigObject LogObject
        TimeObject MainObject EncodeObject)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed";
    }

    # create needed objects
    $Self-&gt;{TypeObject}   = Kernel::System::Type-&gt;new( %{$Self} );
    $Self-&gt;{TicketObject} = Kernel::System::Ticket-&gt;new( %{$Self} );
    $Self-&gt;{QueueObject}  = Kernel::System::Queue-&gt;new( %{$Self} );

    return $Self;
}

=item Param()

Get all parameters a user can specify.

    my @Params = $StatsObject-&gt;Param();

=cut

sub Param {
    my $Self = shift;

    my %Queues = $Self-&gt;{QueueObject}-&gt;GetAllQueues();
    my %Types  = $Self-&gt;{TypeObject}-&gt;TypeList(
        Valid =&gt; 1,
    );

    my @Params = (
        {
            Frontend  =&gt; 'Type',
            Name      =&gt; 'TypeIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Types,
        },
        {
            Frontend  =&gt; 'Queue',
            Name      =&gt; 'QueueIDs',
            Multiple  =&gt; 1,
            Size      =&gt; 3,
            Data      =&gt; \%Queues,
        },
    );

    return @Params;
}

=item Run()

generate the statistic.

    my $StatsInfo = $StatsObject-&gt;Run(
        TypeIDs  =&gt; [
            1, 2, 4
        ],
        QueueIDs =&gt; [
            3, 4, 6
        ],
    );

=cut

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(TypeIDs QueueIDs)) {
        if ( !$Param{$Needed} ) {
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'error',
                Message  =&gt; "Need $Needed!",
            );
            return;
        }
    }

    # set report title
    my $Title = 'Tickets per Queue';

    # table headlines
    my @HeadData = (
        'Ticket Number',
        'Queue',
        'Type',
    );

    my @Data;
    my @TicketIDs = $Self-&gt;{TicketObject}-&gt;TicketSearch(
        UserID     =&gt; 1,
        Result     =&gt; 'ARRAY',
        Permission =&gt; 'ro',
        %Param,
    );

    for my $TicketID ( @TicketIDs ) {
        my %Ticket = $Self-&gt;{TicketObject}-&gt;TicketGet(
            UserID =&gt; 1,
            TicketID =&gt; $TicketID,
        );
        push @Data, [ $Ticket{TicketNumber}, $Ticket{Queue}, $Ticket{Type} ];
    }

    return ( [$Title], [@HeadData], @Data );
}

1;

=back

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (http://otrs.org/).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see http://www.gnu.org/licenses/agpl.txt.

=head1 VERSION

$Revision: 1.1 $ $Date: 2010-08-13 08:59:28 $

=cut
                </pre><p>
            </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-configuration"></a>Configuration example</h6></div></div></div><p>
There is no configuration needed. Right after installation, the module is available to create a statistic for this module.
            </p></div><div class="section" title="Use case examples"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-use_cases"></a>Use case examples</h6></div></div></div><p>
Use cases.
            </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-caveats"></a>Caveats and Warnings</h6></div></div></div><p>
Caveats and Warnings for static stats.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-releases"></a>Release Availability</h6></div></div></div><p>
Static stat modules are available since OTRS 1.3.
            </p></div><div class="section" title="Using old static stats"><div class="titlepage"><div><div><h6 class="title"><a name="module-stats-static-using-old-stats"></a>Using old static stats</h6></div></div></div><p>
Standard OTRS versions 1.3 and 2.0 already facilitated the generation of stats.
Various stats for OTRS versions 1.3 and 2.0 which have been specially
developed to meet customers' requirements can be used in more recent versions too.
            </p><p>
The files must merely be moved from the
<code class="filename">Kernel/System/Stats/</code> path to
<code class="filename">Kernel/System/Stats/Static/</code>. Additionally
the package name of the respective script must be amended by
"::Static".
            </p><p>
The following example shows how the first path is amended.
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::AccountedTime;
                </pre><p>
            </p><p>
                </p><pre class="programlisting">
    package Kernel::System::Stats::Static::AccountedTime;
                </pre><p>
            </p></div></div></div><div class="section" title="Ticket Number Generator Modules"><div class="titlepage"><div><div><h4 class="title"><a name="ticketnumber-generator"></a>Ticket Number Generator Modules</h4></div></div></div><p>
        Ticket number generators are used to create distinct identifiers aka TicketNumber for
        new tickets.
        Any method of creating a string of numbers is possible, you should use common sense about
        the length of the resulting string (guideline: 5-10).
        When creating a ticket number, make sure the result is prefixed by the SysConfig-Variable
        SystemID in order to enable the detection of ticket numbers on inbound email responses.
        A ticket number generator module needs the two functions TicketCreateNumber() and
        GetTNByString().
        The method TicketCreateNumber() is called without parameters and returns the new ticket
        number.
        The method GetTNByString() is called with the param String which contains the string to be
        parsed for a ticket number and returns the ticket number if found.
    </p><div class="section" title="Code example"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-code"></a>Code example</h5></div></div></div><p>
            See Kernel/System/Ticket/Number/UserRandom.pm in the package TemplateModule.
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-configuration"></a>Configuration example</h5></div></div></div><p>
            See Kernel/Config/Files/TicketNumberGenerator.xml in the package TemplateModule.
        </p></div><div class="section" title="Use Cases"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-usecases"></a>Use Cases</h5></div></div></div><div class="section" title="Ticket numbers should follow a specific scheme."><div class="titlepage"><div><div><h6 class="title"><a name="ticketnumber-generator-usecase-10"></a>Ticket numbers should follow a specific scheme.</h6></div></div></div><p>
                You will need to create a new ticket number generator if the default modules don't
                provide the ticket number scheme you'd like to use.
            </p></div></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
            You should stick to the code of GetTNByString() as used in existing ticket number
            generators to prevent problems with ticket number parsing.
            Also the routine to detect a loop in TicketCreateNumber() should be kept intact to
            prevent duplicate ticket numbers.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="ticketnumber-generator-releases"></a>Release Availability</h5></div></div></div><p>
            Ticket number generators have been available in OTRS since OTRS 1.1.
        </p></div></div><div class="section" title="Ticket Event Module"><div class="titlepage"><div><div><h4 class="title"><a name="ticketevent"></a>Ticket Event Module</h4></div></div></div><p>
        Ticket event modules are running right after a ticket action takes place.
        Per convention these modules are located in the directory "Kernel/System/Ticket/Event".
        An ticket event module needs only the two functions new() and Run().
        The method Run() receives at least the parameters Event, UserID, and Data.
        Data is a hash ref containing data of the ticket, and in case of Article-related events also
        containing Article data.
    </p><div class="section" title="Code example"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-code"></a>Code example</h5></div></div></div><p>
            See Kernel/System/Ticket/Event/EventModulePostTemplate.pm in the package TemplateModule.
        </p></div><div class="section" title="Configuration example"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-configuration"></a>Configuration example</h5></div></div></div><p>
            See Kernel/Config/Files/EventModulePostTemplate.xml in the package TemplateModule.
        </p></div><div class="section" title="Use Cases"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-usecases"></a>Use Cases</h5></div></div></div><div class="section" title="A ticket should be unlocked after a move action."><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-10"></a>A ticket should be unlocked after a move action.</h6></div></div></div><p>
                This standard feature has been implemented with the ticket event module
                Kernel::System::Ticket::Event::ForceUnlock.
                When this feature is not wanted, then it can be turned off by
                unsetting the SysConfig entry Ticket::EventModulePost###910-ForceUnlockOnMove.
            </p></div><div class="section" title="Perform extra cleanup action when a ticket is deleted."><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-20"></a>Perform extra cleanup action when a ticket is deleted.</h6></div></div></div><p>
                A customized OTRS might hold non-standard data in additional database tables.
                When a ticket is deleted then this additional data needs to be deleted.
                This functionality can be achieved with a ticket event module listening to 'TicketDelete' events.
            </p></div><div class="section" title="New tickets should be twittered."><div class="titlepage"><div><div><h6 class="title"><a name="ticketevent-usecase-30"></a>New tickets should be twittered.</h6></div></div></div><p>
                A ticket event module listening to 'TicketCreate' can send out tweets.
            </p></div></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
            No caveats are known.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="ticketevent-releases"></a>Release Availability</h5></div></div></div><p>
Ticket events have been available in OTRS since OTRS 2.0.
        </p><p>
Ticket Events for OTRS 2.0:
TicketCreate, TicketDelete, TicketTitleUpdate, TicketUnlockTimeoutUpdate,
TicketEscalationStartUpdate, MoveTicket,
SetCustomerData, TicketFreeTextSet, TicketFreeTimeSet,
TicketPendingTimeSet, LockSet,
StateSet, OwnerSet,
TicketResponsibleUpdate, PrioritySet, HistoryAdd,
HistoryDelete, TicketAccountTime, TicketMerge, ArticleCreate,
ArticleFreeTextSet, ArticleUpdate, ArticleSend,
ArticleBounce, SendAgentNotification,
SendCustomerNotification, SendAutoResponse, ArticleFlagSet;
        </p><p>
Ticket Events for OTRS 2.1 and higher:
TicketCreate, TicketDelete, TicketTitleUpdate, TicketUnlockTimeoutUpdate,
TicketEscalationStartUpdate, TicketQueueUpdate (MoveTicket),
TicketCustomerUpdate (SetCustomerData), TicketFreeTextUpdate
(TicketFreeTextSet), TicketFreeTimeUpdate (TicketFreeTimeSet),
TicketPendingTimeUpdate (TicketPendingTimeSet), TicketLockUpdate (LockSet),
TicketStateUpdate (StateSet), TicketOwnerUpdate (OwnerSet),
TicketResponsibleUpdate, TicketPriorityUpdate (PrioritySet),
TicketSubscribe, TicketUnsubscribe, HistoryAdd,
HistoryDelete, TicketAccountTime, TicketMerge, ArticleCreate,
ArticleFreeTextUpdate (ArticleFreeTextSet), ArticleUpdate, ArticleSend,
ArticleBounce, ArticleAgentNotification (SendAgentNotification),
ArticleCustomerNotification (SendCustomerNotification), ArticleAutoResponse
(SendAutoResponse), ArticleFlagSet, ArticleFlagDelete;
        </p><p>
Ticket Events for OTRS 2.4:
TicketCreate, TicketDelete, TicketTitleUpdate, TicketUnlockTimeoutUpdate,
TicketQueueUpdate(MoveTicket), TicketTypeUpdate, TicketServiceUpdate,
TicketSLAUpdate, TicketCustomerUpdate (SetCustomerData), TicketFreeTextUpdate, TicketFreeTimeUpdate,
TicketPendingTimeUpdate (TicketPendingTimeSet), TicketLockUpdate (LockSet),
TicketStateUpdate (StateSet), TicketOwnerUpdate (OwnerSet),
TicketResponsibleUpdate, TicketPriorityUpdate (PrioritySet),
HistoryAdd, HistoryDelete,
TicketAccountTime, TicketMerge, ArticleCreate, ArticleFreeTextUpdate (ArticleFreeTextSet),
ArticleUpdate, ArticleSend, ArticleBounce, ArticleAgentNotification (SendAgentNotification),
ArticleCustomerNotification (SendCustomerNotification),
ArticleAutoResponse(SendAutoResponse), ArticleFlagSet, ArticleFlagDelete;
        </p></div></div></div><div class="section" title="Frontend Modules"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-modules"></a>Frontend Modules</h3></div></div></div><div class="section" title="Dashboard Module"><div class="titlepage"><div><div><h4 class="title"><a name="module-dashboard"></a>Dashboard Module</h4></div></div></div><p>
Dashboard module to display statistics in the form of a line graph.
        </p><p>
            </p><div class="screenshot"><div><img src="screenshots/dashboard.png"></div></div><p>
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/DashboardTicketStatsGeneric.pm - message of the day
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::DashboardTicketStatsGeneric;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # get needed objects
    for (
        qw(Config Name ConfigObject LogObject DBObject LayoutObject ParamObject TicketObject UserID)
        )
    {
        die "Got no $_!" if !$Self-&gt;{$_};
    }

    return $Self;
}

sub Preferences {
    my ( $Self, %Param ) = @_;

    return;
}

sub Config {
    my ( $Self, %Param ) = @_;

    my $Key = $Self-&gt;{LayoutObject}-&gt;{UserLanguage} . '-' . $Self-&gt;{Name};
    return (
        %{ $Self-&gt;{Config} },
        CacheKey =&gt; 'TicketStats' . '-' . $Self-&gt;{UserID} . '-' . $Key,
    );

}

sub Run {
    my ( $Self, %Param ) = @_;

    my %Axis = (
        '7Day' =&gt; {
            0 =&gt; { Day =&gt; 'Sun', Created =&gt; 0, Closed =&gt; 0, },
            1 =&gt; { Day =&gt; 'Mon', Created =&gt; 0, Closed =&gt; 0, },
            2 =&gt; { Day =&gt; 'Tue', Created =&gt; 0, Closed =&gt; 0, },
            3 =&gt; { Day =&gt; 'Wed', Created =&gt; 0, Closed =&gt; 0, },
            4 =&gt; { Day =&gt; 'Thu', Created =&gt; 0, Closed =&gt; 0, },
            5 =&gt; { Day =&gt; 'Fri', Created =&gt; 0, Closed =&gt; 0, },
            6 =&gt; { Day =&gt; 'Sat', Created =&gt; 0, Closed =&gt; 0, },
        },
    );

    my @Data;
    my $Max = 1;
    for my $Key ( 0 .. 6 ) {

        my $TimeNow = $Self-&gt;{TimeObject}-&gt;SystemTime();
        if ($Key) {
            $TimeNow = $TimeNow - ( 60 * 60 * 24 * $Key );
        }
        my ( $Sec, $Min, $Hour, $Day, $Month, $Year, $WeekDay )
            = $Self-&gt;{TimeObject}-&gt;SystemTime2Date(
            SystemTime =&gt; $TimeNow,
            );

        $Data[$Key]-&gt;{Day} = $Self-&gt;{LayoutObject}-&gt;{LanguageObject}-&gt;Get(
            $Axis{'7Day'}-&gt;{$WeekDay}-&gt;{Day}
        );

        my $CountCreated = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCreateTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCreateTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Created} = $CountCreated;
        if ( $CountCreated &gt; $Max ) {
            $Max = $CountCreated;
        }

        my $CountClosed = $Self-&gt;{TicketObject}-&gt;TicketSearch(

            # cache search result 20 min
            CacheTTL =&gt; 60 * 20,

            # tickets with create time after ... (ticket newer than this date) (optional)
            TicketCloseTimeNewerDate =&gt; "$Year-$Month-$Day 00:00:00",

            # tickets with created time before ... (ticket older than this date) (optional)
            TicketCloseTimeOlderDate =&gt; "$Year-$Month-$Day 23:59:59",

            CustomerID =&gt; $Param{Data}-&gt;{UserCustomerID},
            Result     =&gt; 'COUNT',

            # search with user permissions
            Permission =&gt; $Self-&gt;{Config}-&gt;{Permission} || 'ro',
            UserID =&gt; $Self-&gt;{UserID},
        );
        $Data[$Key]-&gt;{Closed} = $CountClosed;
        if ( $CountClosed &gt; $Max ) {
            $Max = $CountClosed;
        }
    }

    @Data = reverse @Data;
    my $Source = $Self-&gt;{LayoutObject}-&gt;JSONEncode(
        Data =&gt; \@Data,
    );

    my $Content = $Self-&gt;{LayoutObject}-&gt;Output(
        TemplateFile =&gt; 'AgentDashboardTicketStats',
        Data         =&gt; {
            %{ $Self-&gt;{Config} },
            Key    =&gt; int rand 99999,
            Max    =&gt; $Max,
            Source =&gt; $Source,
        },
    );

    return $Content;
}

1;
        </pre><p>
        </p><p>
To use this module add the following to the <code class="filename">Kernel/Config.pm</code>
and restart your webserver (if you use mod_perl).
        </p><pre class="programlisting">
&lt;ConfigItem Name="DashboardBackend###0250-TicketStats" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Parameters for the dashboard backend. "Group" are used to restricted access to the plugin (e. g. Group: admin;group1;group2;). "Default" means if the plugin is enabled per default or if the user needs to enable it manually. "CacheTTL" means the cache time in minutes for the plugin.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Parameter für das Dashboard Backend. "Group" ist verwendet um den Zugriff auf das Plugin einzuschränken (z. B. Group: admin;group1;group2;). ""Default" bedeutet ob das Plugin per default aktiviert ist oder ob dies der Anwender manuell machen muss. "CacheTTL" ist die Cache-Zeit in Minuten nach der das Plugin erneut aufgerufen wird.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Dashboard&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::DashboardTicketStatsGeneric&lt;/Item&gt;
            &lt;Item Key="Title"&gt;7 Day Stats&lt;/Item&gt;
            &lt;Item Key="Created"&gt;1&lt;/Item&gt;
            &lt;Item Key="Closed"&gt;1&lt;/Item&gt;
            &lt;Item Key="Permission"&gt;rw&lt;/Item&gt;
            &lt;Item Key="Block"&gt;ContentSmall&lt;/Item&gt;
            &lt;Item Key="Group"&gt;&lt;/Item&gt;
            &lt;Item Key="Default"&gt;1&lt;/Item&gt;
            &lt;Item Key="CacheTTL"&gt;45&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h5 class="title"><a name="dashboard-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
An excessive number of days or individual lines may lead to performance degradation.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="dashboard-module-releases"></a>Release Availability</h5></div></div></div><p>
from 2.4.0
            </p></div></div><div class="section" title="Notification Module"><div class="titlepage"><div><div><h4 class="title"><a name="notify-module"></a>Notification Module</h4></div></div></div><p>
        Notification modules are used to display a notification below the
        main navigation. You can write and register your own notification
        module.
        There are currently 5 ticket menues in the OTRS framework.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>AgentOnline</p></li><li class="listitem"><p>AgentTicketEscalation</p></li><li class="listitem"><p>CharsetCheck</p></li><li class="listitem"><p>CustomerOnline</p></li><li class="listitem"><p>UIDCheck</p></li></ul></div><p>
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-code"></a>Code Example</h5></div></div></div><p>
            The notification modules are located under
            Kernel/Output/HTML/TicketNotification*.pm.
            There is an example of a notify module below.
            Save it under Kernel/Output/HTML/TicketNotificationCustom.pm.
            You just need 2 functions: new() and Run().
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/NotificationCustom.pm
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::NotificationCustom;

use strict;
use warnings;

use Kernel::System::Custom;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject TimeObject UserID)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }
    $Self-&gt;{CustomObject} = Kernel::System::Custom-&gt;new(%Param);
    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # get session info
    my %CustomParam      = ();
    my @Customs    = $Self-&gt;{CustomObject}-&gt;GetAllCustomIDs();
    my $IdleMinutes = $Param{Config}-&gt;{IdleMinutes} || 60 * 2;
    for (@Customs) {
        my %Data = $Self-&gt;{CustomObject}-&gt;GetCustomIDData( CustomID =&gt; $_, );
        if (
            $Self-&gt;{UserID} ne $Data{UserID}
            &amp;&amp; $Data{UserType} eq 'User'
            &amp;&amp; $Data{UserLastRequest}
            &amp;&amp; $Data{UserLastRequest} + ( $IdleMinutes * 60 ) &gt; $Self-&gt;{TimeObject}-&gt;SystemTime()
            &amp;&amp; $Data{UserFirstname}
            &amp;&amp; $Data{UserLastname}
            )
        {
            $CustomParam{ $Data{UserID} } = "$Data{UserFirstname} $Data{UserLastname}";
            if ( $Param{Config}-&gt;{ShowEmail} ) {
                $CustomParam{ $Data{UserID} } .= " ($Data{UserEmail})";
            }
        }
    }
    for ( sort { $CustomParam{$a} cmp $CustomParam{$b} } keys %CustomParam ) {
        if ( $Param{Message} ) {
            $Param{Message} .= ', ';
        }
        $Param{Message} .= "$CustomParam{$_}";
    }
    if ( $Param{Message} ) {
        return $Self-&gt;{LayoutObject}-&gt;Notify( Info =&gt; 'Custom Message: %s", "' . $Param{Message} );
    }
    else {
        return '';
    }
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom notification module.
            This can be done using the xml configuration below. There may
            be additional parameters in the config hash for your notification
            module.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Frontend::NotifyModule###3-Custom" Required="0" Valid="0"&gt;
    &lt;Description Lang="en"&gt;Module to show custom message in the agent interface.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Mit diesem Modul können eigene Meldungenen innerhalb des Agent-Interfaces angezeigt werden.&lt;/Description&gt;
    &lt;Group&gt;Framework&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::ModuleNotify&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::NotificationCustom&lt;/Item&gt;
            &lt;Item Key="Key1"&gt;1&lt;/Item&gt;
            &lt;Item Key="Key2"&gt;2&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful ticket menu implementation could be a link to a external
            tool if parameters (e.g. FreeTextField) have been set.
        </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="notify-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>NotificationAgentOnline</td><td>2.0</td></tr><tr><td>NotificationAgentTicketEscalation</td><td>2.0</td></tr><tr><td>NotificationCharsetCheck</td><td>1.2</td></tr><tr><td>NotificationCustomerOnline</td><td>2.0</td></tr><tr><td>NotificationUIDCheck</td><td>1.2</td></tr></tbody></table></div><p>
        </p></div></div><div class="section" title="Ticket Menu Module"><div class="titlepage"><div><div><h4 class="title"><a name="ticket-menu-module"></a>Ticket Menu Module</h4></div></div></div><p>
        Ticket menu modules are used to display an addtional link in the
        menu above a ticket. You can write and register your own ticket
        menu module.
        There are 4 ticket menues (Generic, Lock, Responsible and
        TicketWatcher) which come with the OTRS framework. For
        more information please have a look at the OTRS admin manual.
    </p><div class="section" title="Code Example"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-code"></a>Code Example</h5></div></div></div><p>
            The ticket menu modules are located under
            Kernel/Output/HTML/TicketMenu*.pm.
            There is an example of a ticket-menu module below.
            Save it under Kernel/Output/HTML/TicketMenuCustom.pm.
            You just need 2 functions: new() and Run().
        </p><p>
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/TicketMenuCustom.pm
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# Id: TicketMenuCustom.pm,v 1.17 2010/04/12 21:34:06 martin Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::TicketMenuCustom;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Object (qw(ConfigObject LogObject DBObject LayoutObject UserID TicketObject)) {
        $Self-&gt;{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{Ticket} ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; 'Need Ticket!'
        );
        return;
    }

    # check if frontend module registered, if not, do not show action
    if ( $Param{Config}-&gt;{Action} ) {
        my $Module = $Self-&gt;{ConfigObject}-&gt;Get('Frontend::Module')-&gt;{ $Param{Config}-&gt;{Action} };
        return if !$Module;
    }

    # check permission
    my $AccessOk = $Self-&gt;{TicketObject}-&gt;Permission(
        Type     =&gt; 'rw',
        TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
        UserID   =&gt; $Self-&gt;{UserID},
        LogNo    =&gt; 1,
    );
    return if !$AccessOk;

    # check permission
    if ( $Self-&gt;{TicketObject}-&gt;CustomIsTicketCustom( TicketID =&gt; $Param{Ticket}-&gt;{TicketID} ) ) {
        my $AccessOk = $Self-&gt;{TicketObject}-&gt;OwnerCheck(
            TicketID =&gt; $Param{Ticket}-&gt;{TicketID},
            OwnerID  =&gt; $Self-&gt;{UserID},
        );
        return if !$AccessOk;
    }

    # check acl
    return
        if defined $Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} }
            &amp;&amp; !$Param{ACL}-&gt;{ $Param{Config}-&gt;{Action} };

    # if ticket is customized
    if ( $Param{Ticket}-&gt;{Custom} eq 'lock' ) {

        # if it is locked for somebody else
        return if $Param{Ticket}-&gt;{OwnerID} ne $Self-&gt;{UserID};

        # show custom action
        return {
            %{ $Param{Config} },
            %{ $Param{Ticket} },
            %Param,
            Name        =&gt; 'Custom',
            Description =&gt; 'Custom to give it back to the queue!',
            Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
        };
    }

    # if ticket is customized
    return {
        %{ $Param{Config} },
        %{ $Param{Ticket} },
        %Param,
        Name        =&gt; 'Custom',
        Description =&gt; 'Custom it to work on it!',
        Link        =&gt; 'Action=AgentTicketCustom;Subaction=Custom;TicketID=$QData{"TicketID"}',
    };
}

1;

        </pre><p>
        </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-configuration"></a>Configuration Example</h5></div></div></div><p>
            There is the need to activate your custom ticket menu module.
            This can be done using the xml configuration below. There may
            be additional parameters in the config hash for your ticket menu
            module.
        </p><p>
        </p><pre class="programlisting">
&lt;ConfigItem Name="Ticket::Frontend::MenuModule###110-Custom" Required="0" Valid="1"&gt;
    &lt;Description Lang="en"&gt;Module to show custom link in menu.&lt;/Description&gt;
    &lt;Description Lang="de"&gt;Mit diesem Modul wird der Custom-Link in der Linkleiste der Ticketansicht angezeigt.&lt;/Description&gt;
    &lt;Group&gt;Ticket&lt;/Group&gt;
    &lt;SubGroup&gt;Frontend::Agent::Ticket::MenuModule&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Module"&gt;Kernel::Output::HTML::TicketMenuCustom&lt;/Item&gt;
            &lt;Item Key="Name"&gt;Custom&lt;/Item&gt;
            &lt;Item Key="Action"&gt;AgentTicketCustom&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
        </pre><p>
        </p></div><div class="section" title="Use Case Example"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-use_cases"></a>Use Case Example</h5></div></div></div><p>
            Useful ticket menu implementation could be a link to a external
            tool if parameters (e.g. FreeTextField) have been set.
        </p></div><div class="section" title="Caveats and Warnings"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-caveats"></a>Caveats and Warnings</h5></div></div></div><p>
                The ticket menu directs to an URL that can be handled.
                If you want to handle that request via the OTRS framework,
                you have to write your own frontend module.
            </p></div><div class="section" title="Release Availability"><div class="titlepage"><div><div><h5 class="title"><a name="ticket-menu-module-releases"></a>Release Availability</h5></div></div></div><p>
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Release</th></tr></thead><tbody><tr><td>TicketMenuGeneric</td><td>2.0</td></tr><tr><td>TicketMenuLock</td><td>2.0</td></tr><tr><td>TicketMenuResponsible</td><td>2.1</td></tr><tr><td>TicketMenuTicketWatcher</td><td>2.4</td></tr></tbody></table></div><p>
        </p></div></div></div><div class="section" title="Generic Interface Modules"><div class="titlepage"><div><div><h3 class="title"><a name="genericinterface-modules"></a>Generic Interface Modules</h3></div></div></div><div class="section" title="Network Transport"><div class="titlepage"><div><div><h4 class="title"><a name="transport"></a>Network Transport</h4></div></div></div><p>
        The network transport is used as method to send and receive information between OTRS and a
        Remote System. The Generic Interface configuration allows a web service to use different
        network transport modules for provider and requester, but the most common scenario is that
        the same transport module is used for both.
    </p><p>
        <span class="emphasis"><em>OTRS as provider:</em></span>
    </p><p>
        OTRS uses the network transport modules to get the data from the Remote System and the
        operation to be executed. After the operation is performed OTRS uses them again to send the
        response back to the Remote System.
    </p><p>
        <span class="emphasis"><em>OTRS as requester:</em></span>
    </p><p>
        OTRS uses the network transport modules to send petitions to the Remote System to perform a
        remote action along with the required data, OTRS waits for the Remote System response and
        send it back to the Requester module.
    </p><p>
        In both ways network transport modules deals with the data in the Remote System format. it
        is not recommended to do any data transformation in this modules, the Mapping layer is the
        responsible to perform any data transformation needed during the communication.
    </p><div class="section" title="Transport backend"><div class="titlepage"><div><div><h5 class="title"><a name="adding_transport"></a>Transport backend</h5></div></div></div><p>
            Next will see how to develop a new transport backend, each transport backend has to
            implement these subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>ProviderProcessRequest</p></li><li class="listitem"><p>ProviderGenerateResponse</p></li><li class="listitem"><p>RequesterPerformRequest</p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to communicate
            correctly with a Remote System in both ways. All network transport backends are
            handled by the transport module (Kernel/GenericInterface/Transport.pm).
        </p><p>
            Currently Generic Interface implements the HTTP SOAP transport, if the planned web
            service can use HTTP SOAP there is no need to create a new network transport
            module, instead we recommend to take a look into HTTP SOAP configuration to check
            the settings and how it can be tuned.
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="transport_code_example"></a>Code example</h6></div></div></div><p>
                In case that the provided network transports does not match the web service needs,
                then in this section a sample network transport module is shown and each subroutine
                is explained. Normally transport modules uses CPAN modules as backends for example
                the HTTP SOAP transport modules uses SOAP::Lite module as backend.
            </p><p>
                For this example a custom package is used to return the data without doing a real
                network request to a Remote System, instead this custom module acts as a loopback
                interface.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Transport/HTTP/Test.pm - GenericInterface network transport interface for testing
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::GenericInterface::Transport::HTTP::Test;

use strict;
use warnings;

use LWP::UserAgent;
use LWP::Protocol;
use HTTP::Request::Common;

use Kernel::System::Web::Request;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the package keyword.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    for my $Needed (
        qw(LogObject EncodeObject ConfigObject MainObject DebuggerObject TransportConfig)
        )
    {
        $Self-&gt;{$Needed} = $Param{$Needed} || return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Got no $Needed!"
        };
    }

    return $Self;
}
                </pre><p>
            </p><p>
                The constructor 'new' creates a new instance of the class. According to the coding
                guidelines objects of other classes that are needed in this module have to be
                created in "new".
            </p><p>
                </p><pre class="programlisting">
sub ProviderProcessRequest {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {
        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "HTTP status code: 500",
            Data         =&gt; {},
        };
    }

    my $ParamObject = Kernel::System::Web::Request-&gt;new( %{$Self} );

    my %Result;

    for my $ParamName ( $ParamObject-&gt;GetParamNames() ) {
        $Result{$ParamName} = $ParamObject-&gt;GetParam( Param =&gt; $ParamName );
    }

    # special handling for empty post request
    if ( keys %Result == 1 &amp;&amp; exists $Result{POSTDATA} &amp;&amp; !$Result{POSTDATA} ) {
        %Result = ();
    }

    if ( !%Result ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'No request data found.',
        );
    }

    return {
        Success   =&gt; 1,
        Data      =&gt; \%Result,
        Operation =&gt; 'test_operation',
    };

}
                </pre><p>
            </p><p>
                The 'ProviderProcessRequest' function gets the request form the Remote System (in
                this case the same OTRS) and extracts the data and the operation to perform from
                the request. For this example the operation is always 'test_operation'.
            </p><p>
                The way this function parse the request to get the data and the operation name,
                depends completely on the protocol to be implemented and the external modules that
                are used for.
            </p><p>
                </p><pre class="programlisting">
sub ProviderGenerateResponse {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {
        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; 'Test response generation failed',
        };
    }

    my $Response;

    if ( !$Param{Success} ) {
        $Response
            = HTTP::Response-&gt;new( 500 =&gt; ( $Param{ErrorMessage} || 'Internal Server Error' ) );
        $Response-&gt;protocol('HTTP/1.0');
        $Response-&gt;content_type("text/plain; charset=UTF-8");
        $Response-&gt;date(time);
    }
    else {

        # generate a request string from the data
        my $Request
            = HTTP::Request::Common::POST( 'http://testhost.local/', Content =&gt; $Param{Data} );

        $Response = HTTP::Response-&gt;new( 200 =&gt; "OK" );
        $Response-&gt;protocol('HTTP/1.0');
        $Response-&gt;content_type("text/plain; charset=UTF-8");
        $Response-&gt;add_content_utf8( $Request-&gt;content );
        $Response-&gt;date(time);
    }

    $Self-&gt;{DebuggerObject}-&gt;Debug(
        Summary =&gt; 'Sending HTTP response',
        Data    =&gt; $Response-&gt;as_string(),
    );

    # now send response to client
    print STDOUT $Response-&gt;as_string();

    return {
        Success =&gt; 1,
    };
}
                </pre><p>
            </p><p>
                This function send the response back to the Remote System for the requested
                operation.
            </p><p>
                For this particular example we return an standard HTTP response success (200) or
                not (500), along with the required data on each case.
            </p><p>
                </p><pre class="programlisting">
sub RequesterPerformRequest {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{TransportConfig}-&gt;{Config}-&gt;{Fail} ) {
        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "HTTP status code: 500",
            Data         =&gt; {},
        };
    }

    # use custom protocol handler to avoid sending out real network requests
    LWP::Protocol::implementor(
        testhttp =&gt; 'Kernel::GenericInterface::Transport::HTTP::Test::CustomHTTPProtocol'
    );
    my $UserAgent = LWP::UserAgent-&gt;new();
    my $Response = $UserAgent-&gt;post( 'testhttp://localhost.local/', Content =&gt; $Param{Data} );

    return {
        Success =&gt; 1,
        Data    =&gt; {
            ResponseContent =&gt; $Response-&gt;content,
        },
    };
}
                </pre><p>
            </p><p>
                This is the only function that is used by OTRS as requester. It sends the request
                to the Remote System and waits for it response.
            </p><p>
                For this example we use a custom protocol handler to avoid send the request to the
                real network. this custom protocol is specified below.
            </p><p>
                </p><pre class="programlisting">
package Kernel::GenericInterface::Transport::HTTP::Test::CustomHTTPProtocol;

use base qw(LWP::Protocol);

sub new {
    my $Class = shift;
    return $Class-&gt;SUPER::new(@_);
}

sub request {
    my $Self = shift;
    my ( $Request, $Proxy, $Arg, $Size, $Timeout ) = @_;

    my $Response = HTTP::Response-&gt;new( 200 =&gt; "OK" );
    $Response-&gt;protocol('HTTP/1.0');
    $Response-&gt;content_type("text/plain; charset=UTF-8");
    $Response-&gt;add_content_utf8( $Request-&gt;content );
    $Response-&gt;date(time);

    return $Response;
}
                </pre><p>
            </p><p>
                This is the code for the custom protocol that we use. This approach is only useful
                for training or for testing environments where the Remote Systems are not available.
            </p><p>
                For a new module development we do not recommend to use this approach, a real
                protocol needs to be implemented.
            </p><p>
                </p><pre class="programlisting">
1;

=end Internal:

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (L&lt;http://otrs.org/&gt;).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see L&lt;http://www.gnu.org/licenses/agpl.txt&gt;.

=cut

=head1 VERSION

$Revision: 1.1 $ $Date: 2012-03-12 13:53:45 $

=cut
                </pre><p>
            </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="transport-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this network transport module to be accessible in the
                OTRS GUI. This can be done using the xml configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Transport::Module###HTTP::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the transport layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Transport::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Protocol"&gt;HTTP&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceTransportHTTPTest&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section" title="Mapping"><div class="titlepage"><div><div><h4 class="title"><a name="mapping"></a>Mapping</h4></div></div></div><p>
        The mapping is used to convert data from / to OTRS, to / from the external system.
        This data can be represented as key =&gt; value pairs, mapping modules can be developed to
        transform not just values but also the keys.
    </p><p>
        <span class="emphasis"><em>For example:</em></span>
    </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>From</th><th>To</th></tr></thead><tbody><tr><td>Prio =&gt; Warning</td><td>PriorityID =&gt; 3</td></tr></tbody></table></div><p>
        The mapping layer is not absolutely necessary, a web service can skip it completely
        depending on the web service configuration and how invokers and operation are implemented.
        But if some data transformations are needed, is highly recommended to use an existing
        mapping module or create a new one.
    </p><p>
        Mapping modules can be called more than one time during a normal communication, take a
        look to the following examples.
    </p><p>
        <span class="emphasis"><em>OTRS as provider example:</em></span>
    </p><p>
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    The remote system sends the request with the data in the remote system format
                </p></li><li class="listitem"><p>
                    The data is mapped from the remote system format to the OTRS format
                </p></li><li class="listitem"><p>
                    OTRS performs the operation and return the response in OTRS format
                </p></li><li class="listitem"><p>
                    The data is mapped form the OTRS format to the remote system format
                </p></li><li class="listitem"><p>
                    The response with the data in the remote system format is sent to the remote
                    system
                </p></li></ol></div><p>
    </p><p>
        <span class="emphasis"><em>OTRS as requester example:</em></span>
    </p><p>
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    OTRS prepare the request to the remote system using the data in the OTRS format
                </p></li><li class="listitem"><p>
                    The data is mapped from the OTRS format to the remote system format
                </p></li><li class="listitem"><p>
                    The request is sent to the remote system which perform the action and send the
                    response back to OTRS with the response data in remote system format
                </p></li><li class="listitem"><p>
                    The data is mapped form remote system format (again) to the OTRS format
                </p></li><li class="listitem"><p>
                    OTRS process the response
                </p></li></ol></div><p>
    </p><div class="section" title="Mapping backend"><div class="titlepage"><div><div><h5 class="title"><a name="adding_mapping"></a>Mapping backend</h5></div></div></div><p>
            Generic Interface provides a mapping module called <span class="emphasis"><em>Simple</em></span>.
            With this module most of the data transformations including key and value mapping
            can be done, and also it defines rules for to handling the default mappings for both
            keys and values.
        </p><p>
            So it is highly provable that you don't need to develop a custom mapping module.
            Please check Mapping Simple module (Kernel/GenericInterface/Mapping/Simple.pm)
            and its online documentation before continue.
        </p><p>
            If Mapping Simple module does not match your needs then we will see how to develop a
            new Mapping backend, each mapping backend has to implement these subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>Map</p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to map the data in the
            communication, handled either by the requester or provider. All mapping backends are
            handled by the mapping module (Kernel/GenericInterface/Mapping.pm).
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="mapping_code_example"></a>Code example</h6></div></div></div><p>
                In this section a sample mapping module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Mapping/Test.pm - GenericInterface test data mapping backend
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::GenericInterface::Mapping::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsHashRefWithData IsStringWithData);

use vars qw(@ISA $VERSION);
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the package keyword.
            </p><p>
                We also include VariableCheck module to perform certain validation over some
                variables.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed params
    for my $Needed (qw(DebuggerObject MainObject MappingConfig)) {
        if ( !$Param{$Needed} ) {
            return {
                Success      =&gt; 0,
                ErrorMessage =&gt; "Got no $Needed!"
            };
        }
        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    # check mapping config
    if ( !IsHashRefWithData( $Param{MappingConfig} ) ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got no MappingConfig as hash ref with content!',
        );
    }

    # check config - if we have a map config, it has to be a non-empty hash ref
    if (
        defined $Param{MappingConfig}-&gt;{Config}
        &amp;&amp; !IsHashRefWithData( $Param{MappingConfig}-&gt;{Config} )
        )
    {
        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got MappingConfig with Data, but Data is no hash ref with content!',
        );
    }

    return $Self;
}
                </pre><p>
            </p><p>
                The constructor 'new' creates a new instance of the class. According to the coding
                guidelines objects of other classes that are needed in this module have to be
                created in "new".
            </p><p>
                </p><pre class="programlisting">
sub Map {
    my ( $Self, %Param ) = @_;

    # check data - only accept undef or hash ref
    if ( defined $Param{Data} &amp;&amp; ref $Param{Data} ne 'HASH' ) {
        return $Self-&gt;{DebuggerObject}
            -&gt;Error( Summary =&gt; 'Got Data but it is not a hash ref in Mapping Test backend!' );
    }

    # return if data is empty
    if ( !defined $Param{Data} || !%{ $Param{Data} } ) {
        return {
            Success =&gt; 1,
            Data    =&gt; {},
        };
    }

    # no config means that we just return input data
    if (
        !defined $Self-&gt;{MappingConfig}-&gt;{Config}
        || !defined $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption}
        )
    {
        return {
            Success =&gt; 1,
            Data    =&gt; $Param{Data},
        };
    }

    # check TestOption format
    if ( !IsStringWithData( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} ) ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got no TestOption as string with value!',
        );
    }

    # parse data according to configuration
    my $ReturnData = {};
    if ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'ToUpper' ) {
        $ReturnData = $Self-&gt;_ToUpper( Data =&gt; $Param{Data} );
    }
    elsif ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'ToLower' ) {
        $ReturnData = $Self-&gt;_ToLower( Data =&gt; $Param{Data} );
    }
    elsif ( $Self-&gt;{MappingConfig}-&gt;{Config}-&gt;{TestOption} eq 'Empty' ) {
        $ReturnData = $Self-&gt;_Empty( Data =&gt; $Param{Data} );
    }
    else {
        $ReturnData = $Param{Data};
    }

    # return result
    return {
        Success =&gt; 1,
        Data    =&gt; $ReturnData,
    };
}
                </pre><p>
            </p><p>
                The 'map' function is the main part of each mapping module, it receives the mapping
                configuration (rules) and the data in the original format (either OTRS or remote
                system format) and converts it to a new format, even the strucure of the data can be
                changed during the mapping process.
            </p><p>
                In this particular example there are three rules to map the values this rules are
                set in the mapping configuration key "TestOption" and they are ToUpper, ToLower and
                Empty.
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                        ToUpper: converts each data value to upper case.
                    </p></li><li class="listitem"><p>
                        ToLower: converts each data value to lower case.
                    </p></li><li class="listitem"><p>
                        Empty: converts each data value into an empty string.
                    </p></li></ul></div><p>
                In this example no data key transformations were implemented.
            </p><p>
                </p><pre class="programlisting">
sub _ToUpper {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = uc $Param{Data}-&gt;{$Key};
    }

    return $ReturnData;
}

sub _ToLower {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = lc $Param{Data}-&gt;{$Key};
    }

    return $ReturnData;
}

sub _Empty {
    my ( $Self, %Param ) = @_;

    my $ReturnData = {};
    for my $Key ( keys %{ $Param{Data} } ) {
        $ReturnData-&gt;{$Key} = '';
    }

    return $ReturnData;
}
                </pre><p>
            </p><p>
                This are the helper functions that actually performs the string conversions
            </p><p>
                </p><pre class="programlisting">

=end Internal:

=back

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (L&lt;http://otrs.org/&gt;).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see L&lt;http://www.gnu.org/licenses/agpl.txt&gt;.

=cut

=head1 VERSION

$Revision: 1.1 $ $Date: 2012-03-12 13:53:45 $

=cut
                </pre><p>
            </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="mapping-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this mapping module to be accessible in the OTRS GUI.
                This can be done using the xml configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Mapping::Module###Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the mapping layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Mapping::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="ConfigDialog"&gt;&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section" title="Invoker"><div class="titlepage"><div><div><h4 class="title"><a name="invoker"></a>Invoker</h4></div></div></div><p>
        The invoker is used to create a request from OTRS to a Remote System, this part of the GI
        is in charge of perform necessary tasks in OTRS side, to gather the necessary data in order
        to construct the request.
    </p><div class="section" title="Invoker backend"><div class="titlepage"><div><div><h5 class="title"><a name="adding_invoker"></a>Invoker backend</h5></div></div></div><p>
            Next we will see how to develop a new Invoker, each invoker has to implement these
            subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>PrepareRequest</p></li><li class="listitem"><p>HandleResponse</p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to execute a request
            using the request handler ('Kernel/GenericInterface/Requester.pm').
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="invoker_code_example"></a>Code example</h6></div></div></div><p>
                In this section a sample invoker module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Invoker/Test.pm - GenericInterface test data Invoker backend
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::GenericInterface::Invoker::Test::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsString IsStringWithData);

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];
                </pre><p>
            </p><p>
This is common header that can be found in common OTRS modules. The class/package name is declared
via the package keyword.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed params
    for my $Needed (qw(DebuggerObject MainObject TimeObject)) {
        if ( !$Param{$Needed} ) {
            return {
                Success      =&gt; 0,
                ErrorMessage =&gt; "Got no $Needed!"
            };
        }

        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    return $Self;
}
                </pre><p>
            </p><p>
The constructor 'new' creates a new instance of the class. According to the coding guidelines
objects of other classes that are needed in this module have to be created in "new".
            </p><p>
                </p><pre class="programlisting">
sub PrepareRequest {
    my ( $Self, %Param ) = @_;

    # we need a TicketNumber
    if ( !IsStringWithData( $Param{Data}-&gt;{TicketNumber} ) ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error( Summary =&gt; 'Got no TicketNumber' );
    }

    my %ReturnData;

    $ReturnData{TicketNumber} = $Param{Data}-&gt;{TicketNumber};

    # check Action
    if ( IsStringWithData( $Param{Data}-&gt;{Action} ) ) {
        $ReturnData{Action} = $Param{Data}-&gt;{Action} . 'Test';
    }

    # check request for system time
    if ( IsStringWithData( $Param{Data}-&gt;{GetSystemTime} ) &amp;&amp; $Param{Data}-&gt;{GetSystemTime} ) {
        $ReturnData{SystemTime} = $Self-&gt;{TimeObject}-&gt;SystemTime();
    }

    return {
        Success =&gt; 1,
        Data    =&gt; \%ReturnData,
    };
}
                </pre><p>
            </p><p>
            The 'PrepareRequest' function is used to handle and collect all needed data to be sent
            into the request, here we can receive data from the request handler, use it, extend it,
            generate new data, and after that, we can transfer the results to the mapping layer.
            </p><p>
            For this example we are expecting to receive a ticket number, if there isn't then we
            use the debugger method "Error()" that creates an entry in the debug log and also
            returns a structure with the parameter Success as 0 and Error Message as the passed
            summary.
            </p><p>
                Also this example appends the word "Test" to the parameter "Action" and if
                GetSystemTime is requested, it will fill the SystemTime parameter with the current
                system time. This part of the code is to prepare the data to be sent, on a real
                invoker some calls to core modules (Kernel/System/*.pm) should be made here.
            </p><p>
                If during any part of the 'PrepareRequest' function the request need to be stop
                without generating and error an entry in the debug log the following code can be
                used:
            </p><p>
                </p><pre class="programlisting">
# stop requester communication
return {
    Success           =&gt; 1,
    StopCommunication =&gt; 1,
};
                </pre><p>
            </p><p>
                Using this, the Requester will understand that the request should not continue (
                it will not be sent to Mapping layer and will also not be sent to the
                Network Transport) Requester will not send an error on the debug log. it will only
                silently stop.
            </p><p>
                </p><pre class="programlisting">
sub HandleResponse {
    my ( $Self, %Param ) = @_;

    # if there was an error in the response, forward it
    if ( !$Param{ResponseSuccess} ) {
        if ( !IsStringWithData( $Param{ResponseErrorMessage} ) ) {
            return $Self-&gt;{DebuggerObject}-&gt;Error(
                Summary =&gt; 'Got response error, but no response error message!',
            );
        }
        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; $Param{ResponseErrorMessage},
        };
    }

    # we need a TicketNumber
    if ( !IsStringWithData( $Param{Data}-&gt;{TicketNumber} ) ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error( Summary =&gt; 'Got no TicketNumber!' );
    }

    # prepare TicketNumber
    my %ReturnData = (
        TicketNumber =&gt; $Param{Data}-&gt;{TicketNumber},
    );

    # check Action
    if ( IsStringWithData( $Param{Data}-&gt;{Action} ) ) {
        if ( $Param{Data}-&gt;{Action} !~ m{ \A ( .*? ) Test \z }xms ) {
            return $Self-&gt;{DebuggerObject}-&gt;Error(
                Summary =&gt; 'Got Action but it is not in required format!',
            );
        }
        $ReturnData{Action} = $1;
    }

    return {
        Success =&gt; 1,
        Data    =&gt; \%ReturnData,
    };
}
                </pre><p>
            </p><p>
                The 'HandleResponse' function is used to receive  and process the data from the
                previous request, that was made to the Remote System this data already passed by
                Mapping layer, to transform it from Remote System format to OTRS format (if
                needed).
            </p><p>
                For this particular example it checks the ticket number again and check if the
                action ends with the word 'Test' (as was done in the 'PrepareRequest' function).
            </p><p>
                <span class="emphasis"><em>Remember </em></span>
                This invoker is only used for tests, a real invoker will check if the response
                was on the format described by the Remote System and can perform some actions
                like: call another invoker, perform an call to a Core Module, update the database,
                send an error, etc.
            </p><p>
                </p><pre class="programlisting">
1;

=back

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (L&lt;http://otrs.org/&gt;).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see L&lt;http://www.gnu.org/licenses/agpl.txt&gt;.

=cut

=head1 VERSION

$Revision: 1.1 $ $Date: 2012-03-12 13:53:45 $

=cut
                </pre><p>
            </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="invoker-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this invoker module to be accessible in the OTRS GUI.
                This can be done using the xml configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Invoker::Module###Test::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the invoker layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Invoker::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Controller"&gt;Test&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceInvokerDefault&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div><div class="section" title="Operation"><div class="titlepage"><div><div><h4 class="title"><a name="operation"></a>Operation</h4></div></div></div><p>
        The operation is used to perform an action within OTRS,
        this action is requested by the external system and can include special parameters in order
        that OTRS receives to correctly execute the action. After the action is performed, OTRS
        sends a defined confirmation the external system.
    </p><div class="section" title="Operation backend"><div class="titlepage"><div><div><h5 class="title"><a name="adding_operation"></a>Operation backend</h5></div></div></div><p>
            Next we will see how to develop a new Operation, each operation has to implement these
            subroutines
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>Run</p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to execute the action
            handled by the provider ('Kernel/GenericInterface/Provider.pm').
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="operation_code_example"></a>Code example</h6></div></div></div><p>
                In this section a sample operation module is shown and each subroutine is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/GenericInterface/Operation/Test/Test.pm - GenericInterface test operation backend
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::GenericInterface::Operation::Test::Test;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(IsHashRefWithData);

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.1 $) [1];
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the package keyword.
            </p><p>
                We also include VariableCheck module to perform certain validation over some
                variables.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Needed (qw(DebuggerObject)) {
        if ( !$Param{$Needed} ) {
            return {
                Success      =&gt; 0,
                ErrorMessage =&gt; "Got no $Needed!"
            };
        }

        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    return $Self;
}
                </pre><p>
            </p><p>
                The constructor 'new' creates a new instance of the class. According to the coding
                guidelines objects of other classes that are needed in this module have to be
                created in "new".
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # check data - only accept undef or hash ref
    if ( defined $Param{Data} &amp;&amp; ref $Param{Data} ne 'HASH' ) {
        return $Self-&gt;{DebuggerObject}-&gt;Error(
            Summary =&gt; 'Got Data but it is not a hash ref in Operation Test backend)!'
        );
    }

    if ( defined $Param{Data} &amp;&amp; $Param{Data}-&gt;{TestError} ) {
        return {
            Success      =&gt; 0,
            ErrorMessage =&gt; "Error message for error code: $Param{Data}-&gt;{TestError}",
            Data         =&gt; {
                ErrorData =&gt; $Param{Data}-&gt;{ErrorData},
            },
        };
    }

    # copy data
    my $ReturnData;

    if ( ref $Param{Data} eq 'HASH' ) {
        $ReturnData = \%{ $Param{Data} };
    }
    else {
        $ReturnData = undef;
    }

    # return result
    return {
        Success =&gt; 1,
        Data    =&gt; $ReturnData,
    };
}
                </pre><p>
            </p><p>
                The 'Run' function is the main part of each operation, it receives all internal
                mapped data from remote system needed by the provider to execute the action,
                it performs the action and returns the result to the provider to be external mapped
                and deliver back to the remote system.
            </p><p>
                This particular example returns the same data as came from the remote system,
                unless "TestError" parameter is passed in this case it returns an error.
            </p><p>
                </p><pre class="programlisting">
1;

=back

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (L&lt;http://otrs.org/&gt;).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see L&lt;http://www.gnu.org/licenses/agpl.txt&gt;.

=cut

=head1 VERSION

$Revision: 1.1 $ $Date: 2012-03-12 13:53:45 $

=cut
                </pre><p>
            </p></div><div class="section" title="Configuration Example"><div class="titlepage"><div><div><h6 class="title"><a name="operation-configuration"></a>Configuration Example</h6></div></div></div><p>
                There is the need to register this operation module to be accessible in the OTRS
                GUI. This can be done using the xml configuration below.
            </p><p>
                </p><pre class="programlisting">
&lt;ConfigItem Name="GenericInterface::Operation::Module###Test::Test" Required="0" Valid="1"&gt;
    &lt;Description Translatable="1"&gt;GenericInterface module registration for the operation layer.&lt;/Description&gt;
    &lt;Group&gt;GenericInterface&lt;/Group&gt;
    &lt;SubGroup&gt;GenericInterface::Operation::ModuleRegistration&lt;/SubGroup&gt;
    &lt;Setting&gt;
        &lt;Hash&gt;
            &lt;Item Key="Name"&gt;Test&lt;/Item&gt;
            &lt;Item Key="Controller"&gt;Test&lt;/Item&gt;
            &lt;Item Key="ConfigDialog"&gt;AdminGenericInterfaceOperationDefault&lt;/Item&gt;
        &lt;/Hash&gt;
    &lt;/Setting&gt;
&lt;/ConfigItem&gt;
                </pre><p>
            </p></div></div></div></div><div class="section" title="Scheduler Task Handler Modules"><div class="titlepage"><div><div><h3 class="title"><a name="scheduler-taskhandler-modules"></a>Scheduler Task Handler Modules</h3></div></div></div><div class="section" title="Task Handler"><div class="titlepage"><div><div><h4 class="title"><a name="task-handler"></a>Task Handler</h4></div></div></div><p>
        The task handler modules are used to perform actions within OTRS asynchronously via OTRS
        scheduler (a separated "daemon like" process ) made specifically to execute this kind of
        jobs.
    </p><div class="section" title="Task Handler backend"><div class="titlepage"><div><div><h5 class="title"><a name="adding_taskhandler"></a>Task Handler backend</h5></div></div></div><p>
            Next we will see how to develop a new scheduler task handler backend. Each task handler
            backend has to implement these subroutines:
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>new</p></li><li class="listitem"><p>Run</p></li></ul></div><p>
        </p><p>
            We should implement each one of this methods in order to be able to execute tasks.
            All task handler backends are used by main scheduler task handler module
            (Kernel/scheduler/TaskHandler.pm).
        </p><p>
            Currently the scheduler only has one working task handler backend named
            "GenericInterface". This task handler backend executes Generic Interface Invoker
            modules in the background.
        </p><p>
            <span class="emphasis"><em>For example:</em></span>
        </p><p>
            By using the OTRS Scheduler combined with the Generic Interface a user does not need to
            wait in the New phone ticket screen after creating a ticket until a Remote System
            responds to a web service request triggered by an event like "TicketCreate", instead
            this task can be delegated to the OTRS scheduler to run it on the background.
        </p><p>
            There is no need to create a new task handler backend for the Generic Interface, unless
            a different behavior from the current one is needed. to delegate Generic Interface
            Invoker tasks to the OTRS Scheduler you need to configure the Invoker event trigger as
            asynchronous.
        </p><div class="section" title="Code example"><div class="titlepage"><div><div><h6 class="title"><a name="taskhandler_code_example"></a>Code example</h6></div></div></div><p>
                In this section a sample scheduler task handler module is shown and each subroutine
                is explained.
            </p><p>
                </p><pre class="programlisting">
# --
# Kernel/Scheduler/TaskHandler/Test.pm - Scheduler task handler test backend
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Scheduler::TaskHandler::Test;

use strict;
use warnings;

use vars qw(@ISA);
                </pre><p>
            </p><p>
                This is common header that can be found in common OTRS modules. The class/package
                name is declared via the package keyword.
            </p><p>
                </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Needed (qw(MainObject ConfigObject LogObject DBObject TimeObject)) {
        $Self-&gt;{$Needed} = $Param{$Needed} || die "Got no $Needed!";
    }

    return $Self;
}
                </pre><p>
            </p><p>
                The constructor 'new' creates a new instance of the class. According to the coding
                guidelines objects of other classes that are needed in this module have to be
                created in "new".
            </p><p>
                </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    # check data - we need a hash ref
    if ( $Param{Data} &amp;&amp; ref $Param{Data} ne 'HASH' ) {
        $Self-&gt;{LogObject}-&gt;Log(
            Priority =&gt; 'error',
            Message  =&gt; 'Got no valid Data!',
        );

        return {
            Success =&gt; 0,
        };
    }

    # create tmp file
    if ( $Param{Data}-&gt;{File} ) {
        my $Content = 123;
        return if !$Self-&gt;{MainObject}-&gt;FileWrite(
            Location =&gt; $Param{Data}-&gt;{File},
            Content  =&gt; \$Content,
        );
    }

    # re schedule with new time
    return {
        Success    =&gt; $Param{Data}-&gt;{Success},
        ReSchedule =&gt; $Param{Data}-&gt;{ReSchedule},
        DueTime    =&gt; $Param{Data}-&gt;{ReScheduleDueTime},
        Data       =&gt; $Param{Data}-&gt;{ReScheduleData},
    };
}
                </pre><p>
            </p><p>
                The 'Run' function is the main part of the module it checks the incoming data,
                make calls to other OTRS modules to execute the tasks, waits for the task result and
                based on the result information it determines if the task was successfully executed
                or not and if the task needs to be re-schedule itself, when and with which data.
            </p><p>
                For this testing example if the parameter "File" exists in the incoming data, a new
                file is to be created on the file system by the task handler, depending of the
                success of this, the task handler will continue to the rest part of the code where
                base it decisions for the returning structure on the previously provided data.
            </p><p>
                On real task handler backends the decisions for the returning structure could be
                based on the task handler backend logics, the task execution results, configuration
                settings, etc.
            </p><p>
                </p><pre class="programlisting">
1;

=back

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (L&lt;http://otrs.org/&gt;).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see L&lt;http://www.gnu.org/licenses/agpl.txt&gt;.

=cut
                </pre><p>
            </p></div></div></div></div><div class="section" title="Dynamic Fields"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicfields-modules"></a>Dynamic Fields</h3></div></div></div><div class="section" title="Overview"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-overview"></a>Overview</h4></div></div></div><p>
        Dynamic Fields are custom fields that can be added to a screen to enhance and add
        information to an object (e.g. a ticket or an article).
    </p><p>
        The Dynamic Fields are the evolution of the ticket and article Free Fields
        ( "TikcetFreeText", "TicketFreeKey", "TicketFreeTime", "ArticleFreeText", "ArticleFreeKey"
        and "ArticleFreeTime" ) from older versions of OTRS.
    </p><p>
        From OTRS version 3.1 the old Free Fields has been replaced with the new Dynamic Fields,
        for a better backward compatibility and data preservation when updating from previous
        versions, a migration script has been developed to convert the existing Free Fields to
        Dynamic Fields and to move their values from the <span class="emphasis"><em>ticket</em></span> and
        <span class="emphasis"><em>article</em></span> tables in the database to new dynamic fields tables.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Any custom development that uses Free Fields needs to be ported to the new Dynamic
            Fields code structure, otherwise it will not work anymore. For this reason is very
            important to know that only updated installations of OTRS has the old Free
            Fields converted to Dynamic Fields, new or clean installations of OTRS has no Dynamic
            Fields defined "out of the box" and any Dynamic Field needed by the custom development
            needs to be added.
        </p></div><p>
        The restriction on the number of the fields per ticket or article has been removed, this
        means that a ticket or article could have as many fields as needed. and now it is also
        possible to use the Dynamic Fields framework for other objects rather than just ticket or
        article.
    </p><p>
        The new Dynamic Fields can store the same data types as the Free Fields
        (Text and Date/Time), and they can be also defined as them (Single line input, drop-down and
        date-time). but Dynamic Fields goes beyond that, a new data type: Integer, has been added
        and also new options to define the fields like Multiple-line inputs, check-boxes,
        Multiple-select and date (without time) fields. Each field type defines its own data type.
    </p><p>
        Due to its modular design each Dynamic Field type can be seen as a plug-in to a framework,
        and this plug-in can be a OTRS standard package to extend the available types of the
        Dynamic Fields.
    </p></div><div class="section" title="Dynamic Fields Framework"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-framework"></a>Dynamic Fields Framework</h4></div></div></div><p>
        Before creating new Dynamic Fields is necessary to understand its framework and how OTRS
        screens interact with them, as well as their underlying API.
    </p><p>
        The following picture shows the architecture of the Dynamic Fields framework.
    </p><div class="screenshot"><div><img src="screenshots/dfframework.png"></div></div><div class="section" title="Dynamic Field Backend Modules"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-backends"></a>Dynamic Field Backend Modules</h5></div></div></div><div class="section" title="Dynamic Field (Backend)"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-backend"></a>Dynamic Field (Backend)</h6></div></div></div><p>
                Normally called as "BackendObject" in the frontend modules is the mediator between
                the frontend modules and each specific Dynamic Field implementation or Delegate. It
                defines a Generic middle API for all Dynamic Field Delegates, and each Delegate has
                the responsibility to implement the middle API for the specific needs for the field.
            </p><p>
                The Dynamic Field Banckend is the master controller of all the Delegates, each
                function in this module is responsible to check the required parameters and call
                the same function in the specific Delegate according to the Dynamic Field
                Configuration parameter received.
            </p><p>
                This module is also responsible to call specific functions on each Object Type
                Delegate (like Ticket or Article) e.g to add a history entry or fire an event.
            </p><p>
                This module is located in $OTRS_HOME/Kernel/System/DynamicField/Backend.pm.
            </p></div><div class="section" title="Dynamic Field Delegates"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-delegates"></a>Dynamic Field Delegates</h6></div></div></div><p>
                A Dynamic Field Delegate is the implementation of the Dynamic Field. Each Delegate
                must implement all the functions specified in the Backend.
            </p><p>
                A Delegate is responsible to know how to get its own value or values from a web
                request, or from a profile (like a search profile), it also needs to know the HTML
                code to render the field in edit or display screens, or how to interact with the
                stats module, among other functions.
            </p><p>
                This modules are located in $OTRS_HOME/Kernel/System/DynamicField/Backend/*.pm.
            </p></div><div class="section" title="Object Type Delegates"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-backends-object-delegates"></a>Object Type Delegates</h6></div></div></div><p>
                A Dynamic Field Delegate is responsible to perform specific functions on the
                object linked to the dynamic field. this functions are triggered by the
                BackendObject as they are needed.
            </p><p>
                This modules are located in $OTRS_HOME/Kernel/System/DynamicField/ObjectType/*.pm.
            </p></div></div><div class="section" title="Dynamic Fields Admin Modules"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-admin"></a>Dynamic Fields Admin Modules</h5></div></div></div><p>
            To manage the Dynamic Fields (Add, Edit and List) a series of modules has been already
            developed. There is one specific master module (AdminDynamicField.pm) to show the list
            of defined Dynamic Fields, and from within other modules are called to create new
            Dynamic Fields or modify an existing ones.
        </p><p>
            Normally a Dynamic Field Delegate needs its own Admin Module (Admin Dialog) to define
            its properties, that might differ from other Delegates. But this is not mandatory,
            Delegates can share Admin Dialogs, if they can provide add needed information for all
            the Delegates linked to them  no matter if they are from different type. What is
            mandatory is that each Delegate must be linked to an Admin Dialog. (e.g. Text and
            TextArea Delegates share AdminDynamicFieldText.pm Admin Dialog, and Date and Date/Time
            Delegates share AdminDynamicFieldDateTime.pm Admin Dialog).
        </p><p>
            Admin Dialogs follows the normal OTRS Admin Module rules and architecture. But for
            standardization all configuration common parts to all Dynamic Fields should have the
            same look and feel among all Admin Dialogs.
        </p><p>
            This modules are located in $OTRS_HOME/Kernel/Modules/*.pm.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Each Admin Dialog needs its corresponding HTML template file (.dtl).
            </p></div></div><div class="section" title="Dynamic Fields Core Modules"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-core"></a>Dynamic Fields Core Modules</h5></div></div></div><p>
            This modules reads and writes the Dynamic Fields information from and to the database
            tables.
        </p><div class="section" title='"DynamicField.pm" Core Module'><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-core-dynamicfield"></a>"DynamicField.pm" Core Module</h6></div></div></div><p>
                This module is responsible to manage the Dynamic Field definitions, it provides the
                basic API for add, change, delete, list and get Dynamic Fields and is located
                in $OTRS_HOME/Kernel/System/DynamicField.pm.
            </p></div><div class="section" title='"DynamicFieldValue.pm" Core Module'><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-framework-core-dynamicfieldvalue"></a>"DynamicFieldValue.pm" Core Module</h6></div></div></div><p>
                This module is responsible to read and write Dynamic Field values into the from and
                into the database this module is highly use by the Delegates and is located in
                $OTRS_HOME/Kernel/System/DynamicFieldValue.pm.
            </p></div></div><div class="section" title="Dynamic Fields Database Tables"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-database"></a>Dynamic Fields Database Tables</h5></div></div></div><p>
            There are two tables in the database to store the dynamic field information:
        </p><p>
            <span class="emphasis"><em>dynamic_field</em></span>: Used by the Core Module DynamicField.pm, it stores
            the Dynamic Field definitions.
        </p><p>
            <span class="emphasis"><em>dynamic_field_value</em></span>: Used by the Core Module DynamicFieldValue.pm
            to save the Dynamic Field values for each Dynamic Field and each Object Type instance.
        </p></div><div class="section" title="Dynamic Fields Configuration Files"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-framework-configuration-files"></a>Dynamic Fields Configuration Files</h5></div></div></div><p>
            The Backend module needs a way to know which Delegates exists and since the Delegates
            can be easily extended, the easiest way to archive this is to use the system
            configuration, where the information of Dynamic Field Delegates and ObjectType Delegates
            can be stored and extended.
        </p><p>
            The master Admin Module also needs to know this information about the Dynamic Field
            Delegates to use the Admin Dialog linked with, to create or modify the Dynamic Fields.
        </p><p>
            Frontend modules needs to read the system configuration to know which Dynamic Fields
            are active for each screen and which ones are also mandatory. for example:
            Ticket::Frontend::AgentTicketPhone###DynamicField stores the active, mandatory and
            inactive Dynamic Fields for New Phone Ticket Screen.
        </p></div></div><div class="section" title="Dynamic Field Interaction With Frontend Modules"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-interaction"></a>Dynamic Field Interaction With Frontend Modules</h4></div></div></div><p>
        Know about how Frontend modules interact with Dynamic fields is not strictly necessary to
        extend Dynamic Fields for the Ticket or Article objects, since all the screens that could
        use the Dynamic Fields are already prepared. But in case of custom developments or to
        extend the Dynamic Fields to other objects is very useful to know to access
        Dynamic Fields framework from a Frontend Module.
    </p><p>
        The following picture shows a simple example of how the Dynamic Fields interact with other
        OTRS framework parts.
    </p><div class="screenshot"><div><img src="screenshots/dfinteraction.png"></div></div><p>
        The first step is that the Frontend module reads the configured Dynamic Fields for example
        <span class="emphasis"><em>AgentTicketNote</em></span> should read
        <span class="emphasis"><em>Ticket::Frontend::AgentTicketNote###DynamicField</em></span> setting. This setting
        can be used as the filter parameter for DynamicField Core Module function
        <span class="emphasis"><em>DynamicFieldListGet()</em></span>. The screen can store the results of this
        function to have the list of the Dynamic Fields activated for this particular screen.
    </p><p>
        Next, the screen should try to get the values from the web request, it can use the
        BackendObject function <span class="emphasis"><em>EditFieldValueGet()</em></span> for this purpose. and can
        use this values to trigger ACLs. The BackendObject will use each Delegate to perform the
        specific actions for all functions.
    </p><p>
        To continue, the screen should get the HTML for each field to display it, the BackendObject
        function <span class="emphasis"><em>EditFieldRender()</em></span> can be used to perform this action and the
        ACLs restriction as well as the Values from the web request can be passed to this function
        in order to get better results. in case of a submit the screen could also use the
        BackendObject function <span class="emphasis"><em>EditFieldValueValidate()</em></span> to check the mandatory
        fields.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Other screens could use <span class="emphasis"><em>DisplayFieldRender()</em></span> instead of
            <span class="emphasis"><em>EditFieldRender()</em></span> if the screen only shows the field value,
            and in such case no value validation is needed.
        </p></div><p>
        To store the value of the Dynamic Field is necessary to get the Object ID, for this example
        if the Dynamic Field is liked to a ticket object, the screen should already have the
        TicketID, otherwise if the field is liked to an article object in order to set the value of
        the field is necessary to create the article first. <span class="emphasis"><em>ValueSet()</em></span> from
        the BackendObject can be used to set the Dynamic Field value.
    </p><p>
        In summary the Frontend modules does not need to know how each Dynamic Field works
        internally  to get or set their values or to display it, It just need to call the
        BackendObject module and use the fields in a generic way.
    </p></div><div class="section" title="How To Extend The Dynamic Fields"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-extend"></a>How To Extend The Dynamic Fields</h4></div></div></div><p>
        There are many ways to extend the Dynamic Fields, the following sections will try to cover
        the most common scenarios.
    </p><div class="section" title="Create a New Dynamic Field Type (for ticket or article objects)"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-new-field"></a>Create a New Dynamic Field Type (for ticket or article objects)</h5></div></div></div><p>
            To create a new Dynamic Field Type is necessary to:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    Create a Dynamic Field Delegate:
                </p><p>
                    This is the main module of the new field.
                </p></li><li class="listitem"><p>
                    Create or use an existing Admin Dialog:
                </p><p>
                    To have a management interface and set its configuration options.
                </p></li><li class="listitem"><p>
                    Create a Configuration File:
                </p><p>
                    To register the new field in the Backend (or new Admin Dialogs in the framework
                    if needed) and be able to create instances or it.
                </p></li></ul></div></div><div class="section" title="Create a New Dynamic Field Type (for other objects)"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-new-field-new-object"></a>Create a New Dynamic Field Type (for other objects)</h5></div></div></div><p>
            To create a new Dynamic Field Type for other objects is necessary to:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    Create a Dynamic Field Delegate
                </p><p>
                    This is the main module of the new Field.
                </p></li><li class="listitem"><p>
                    Create an Object Type Delegate
                </p><p>
                    This is necessary, even if the "other object" does not require any specific
                    data handling in its functions (e.g. after a value is set). All Object Type
                    Delegates must implement the functions that the Backend requires.
                </p><p>
                    Take a look in the current Object Type Delegates to implement the same
                    functions, event if they just return a successful value for the "other object".
                </p></li><li class="listitem"><p>
                    Create or use an existing Admin Dialog
                </p><p>
                    To have a management interface and set its configuration options.
                </p></li><li class="listitem"><p>
                    Implement Dynamic Fields in the Frontend Modules
                </p><p>
                    To be able to use the Dynamic Fields.
                </p></li><li class="listitem"><p>
                    Create a Configuration File
                </p><p>
                    To register the new field in the Backend (or new Admin Dialogs in the framework
                    if needed) and be able to create instances or it. And make the needed settings
                    to show, hide or show the Dynamic Fields as Mandatory in the new screens.
                </p></li></ul></div></div><div class="section" title="Create a New package to use Dynamic Fields"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-new-packages"></a>Create a New package to use Dynamic Fields</h5></div></div></div><p>
            To create a package to use existing dynamic fields is necessary to:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    Implement Dynamic Fields in the Frontend Modules
                </p><p>
                    To be able to use the Dynamic Fields.
                </p></li><li class="listitem"><p>
                    Create a Configuration File
                </p><p>
                    To give the end user the possibility to show, hide or show the Dynamic Fields as
                    Mandatory in the new screens.
                </p></li></ul></div></div><div class="section" title="Extend Backend and Delegates Functionalities"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-backend-functionalities"></a>Extend Backend and Delegates Functionalities</h5></div></div></div><p>
            It might be possible that the BackendObject does not have a needed function for
            custom developments, or could also be possible that it has the function needed, but the
            return format does not match the needs of the custom development.
        </p><p>
            The easiest way to do this, is to create a new BackendObject that defines the functions
            and/or the return formats needed and create also the Delegates that implement this
            new functions for each fields. This new Delegates will only implement the new functions
            since the original delegates takes cares of the standard functions.
        </p><p>
            Put the new Backend into the DynamicField directory (e.g.
             /$OTRS_HOME/Kernel/System/DynamicField/NewPackage/NewPackageBackend.pm and
             Its Delegates in /$OTRS_HOME/Kernel/System/DynamicField/NewPackage/Backend/*.pm
        </p><p>
            To create new Backend functions or modify the existing ones is needed to:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    Create a New Backend module.
                </p><p>
                    To define only the new or modified functions.
                </p></li><li class="listitem"><p>
                    Create the Dynamic Fields Delegates.
                </p><p>
                    To implement only the new or modified functions.
                </p></li><li class="listitem"><p>
                    Implement New Dynamic Fields functions in the Frontend Modules
                </p><p>
                    To be able to use the new Dynamic Fields functions.
                </p></li><li class="listitem"><p>
                    Create a Configuration File
                </p><p>
                    To register the new Delegates for the new Backend.
                </p></li></ul></div></div><div class="section" title="Other Extensions"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-extend-other"></a>Other Extensions</h5></div></div></div><p>
            Other extensions could be a combination of the above examples.
        </p></div></div><div class="section" title="Creating A New Dynamic Field"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-fields-new-field"></a>Creating A New Dynamic Field</h4></div></div></div><p>
        To illustrate this process a new Dynamic Field "Password" will be created. this new Dynamic
        Field Type will show a New password field to Ticket or Article objects. since is very
        similar to a Text Dynamic Field we will use the Text Delegate and Text Admin Dialog as a
        basis to build this new field.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            This new password field implementation is just for educational purposes, it does not
            provide any level of security and is not recommended for production systems.
        </p></div><p>
        To create this new Dynamic Field we will create 4 files: a Configuration File (XML),
        to register the modules, an Admin Dialog Module (perl), to setup the field options, a
        Template Module (DTL), for the Admin Dialog and a Dynamic Field Delegate (perl).
    </p><p>
        File Structure:
    </p><pre class="programlisting">
$HOME (e. g. /opt/otrs/)
|
...
|--/Kernel/
|   |--/Config/
|   |   |--/Files/
|   |   |   |DynamicFieldPassword.xml
...
|   |--/Modules/
|   |   |AdminDynamicFieldPassword.pm
...
|   |--/Output/
|   |   |--/HTML/
|   |   |   |--/Standard/
|   |   |   |   |AdminDynamicFieldPassword.dtl
...
|   |--/System/
|   |   |--/DynamicField/
|   |   |   |--/Backend/
|   |   |   |   |Password.pm
...
        </pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                The creation of a new Backend and its delegates is not covered in this manual but
                the official package iPhoneHandle v 1.1.1 can be used as an example and reference.
            </p></div><div class="section" title="Dynamic Field Password files"><div class="titlepage"><div><div><h5 class="title"><a name="dynamic-fields-new-field-files"></a>Dynamic Field Password files</h5></div></div></div><div class="section" title="Dynamic Field Configuration File Example"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-config"></a>Dynamic Field Configuration File Example</h6></div></div></div><p>
        The configuration files are used to register the Dynamic Field Types (Delegates) and
        the Object Type Delegates for the BackendObject. They also store standard registrations for
        Admin Modules in the framework.
    </p><div class="section" title="Code Example:"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-config-code"></a>Code Example:</h6></div></div></div><p>
                In this section a configuration file for password Dynamic Field is shown and
                explained.
            </p><p>
            </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;otrs_config version="1.0" init="Application"&gt;
            </pre><p>
        </p><p>
            This is the normal header for a configuration file.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="DynamicFields::Backend###Password" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;DynamicField backend registration.&lt;/Description&gt;
        &lt;Group&gt;DynamicFields&lt;/Group&gt;
        &lt;SubGroup&gt;DynamicFields::Backend::Registration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;Hash&gt;
                &lt;Item Key="DisplayName" Translatable="1"&gt;Password&lt;/Item&gt;
                &lt;Item Key="Module"&gt;Kernel::System::DynamicField::Backend::Password&lt;/Item&gt;
                &lt;Item Key="ConfigDialog"&gt;AdminDynamicFieldPassword&lt;/Item&gt;
            &lt;/Hash&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            This setting registers the Password Dynamic Field Delegate for the Backend module so it
            can be included in the list of avaialbe Dynamic Fields Types, it also specify its own
            Admin Dialog in the key "ConfigDialog", this key is used by the Master Dynamic Field
            Admin Module to manage this new Dynamic Field Type.
        </p><p>
            </p><pre class="programlisting">
    &lt;ConfigItem Name="Frontend::Module###AdminDynamicFieldPassword" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Frontend module registration for the agent interface.&lt;/Description&gt;
        &lt;Group&gt;DynamicFields&lt;/Group&gt;
        &lt;SubGroup&gt;Frontend::Admin::ModuleRegistration&lt;/SubGroup&gt;
        &lt;Setting&gt;
            &lt;FrontendModuleReg&gt;
                &lt;Group&gt;admin&lt;/Group&gt;
                &lt;Description&gt;Admin&lt;/Description&gt;
                &lt;Title Translatable="1"&gt;Dynamic Fields Text Backend GUI&lt;/Title&gt;
                &lt;Loader&gt;
                    &lt;JavaScript&gt;Core.Agent.Admin.DynamicField.js&lt;/JavaScript&gt;
                &lt;/Loader&gt;
            &lt;/FrontendModuleReg&gt;
        &lt;/Setting&gt;
    &lt;/ConfigItem&gt;
            </pre><p>
        </p><p>
            This is an standard module registration for the Password Admin Dialog in the Admin
            Interface.
        </p><p>
            </p><pre class="programlisting">
&lt;/otrs_config&gt;
            </pre><p>
        </p><p>
            Standard closure of a configuration file.
        </p></div></div><div class="section" title="Dynamic Field Admin Dialog Example"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module"></a>Dynamic Field Admin Dialog Example</h6></div></div></div><p>
        The Admin Dialogs are standard Admin modules to manage (add or edit) the Dynamic Fields.
    </p><div class="section" title="Code Example:"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-code"></a>Code Example:</h6></div></div></div><p>
                In this section an Admin Dialog for password dynamic field is shown and
                explained.
            </p><p>
            </p><pre class="programlisting">
# --
# Kernel/Modules/AdminDynamicFieldPassword.pm - provides a dynamic fields password config view for admins
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Modules::AdminDynamicFieldPassword;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);
use Kernel::System::Valid;
use Kernel::System::CheckItem;
use Kernel::System::DynamicField;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.2 $) [1];
            </pre><p>
        </p><p>
            This is the common header that can be found in common OTRS modules. The class/package
            name is declared via the package keyword.
        </p><p>
            </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    my $Self = {%Param};
    bless( $Self, $Type );

    for (qw(ParamObject LayoutObject LogObject ConfigObject)) {
        if ( !$Self-&gt;{$_} ) {
            $Self-&gt;{LayoutObject}-&gt;FatalError( Message =&gt; "Got no $_!" );
        }
    }

    # create additional objects
    $Self-&gt;{ValidObject} = Kernel::System::Valid-&gt;new( %{$Self} );

    $Self-&gt;{DynamicFieldObject} = Kernel::System::DynamicField-&gt;new( %{$Self} );

    # get configured object types
    $Self-&gt;{ObjectTypeConfig} = $Self-&gt;{ConfigObject}-&gt;Get('DynamicFields::ObjectType');

    # get the fields config
    $Self-&gt;{FieldTypeConfig} = $Self-&gt;{ConfigObject}-&gt;Get('DynamicFields::Backend') || {};

    $Self-&gt;{DefaultValueMask} = '****';
    return $Self;
}
            </pre><p>
        </p><p>
            The constructor 'new' creates a new instance of the class. According to the coding
            guidelines objects of other classes that are needed in this module are normally created
            here.
        </p><p>
            </p><pre class="programlisting">
sub Run {
    my ( $Self, %Param ) = @_;

    if ( $Self-&gt;{Subaction} eq 'Add' ) {
        return $Self-&gt;_Add(
            %Param,
        );
    }
    elsif ( $Self-&gt;{Subaction} eq 'AddAction' ) {

        # challenge token check for write action
        $Self-&gt;{LayoutObject}-&gt;ChallengeTokenCheck();

        return $Self-&gt;_AddAction(
            %Param,
        );
    }
    if ( $Self-&gt;{Subaction} eq 'Change' ) {
        return $Self-&gt;_Change(
            %Param,
        );
    }
    elsif ( $Self-&gt;{Subaction} eq 'ChangeAction' ) {

        # challenge token check for write action
        $Self-&gt;{LayoutObject}-&gt;ChallengeTokenCheck();

        return $Self-&gt;_ChangeAction(
            %Param,
        );
    }
    return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
        Message =&gt; "Undefined subaction.",
    );
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>Run</em></span> is the default function to be called by the web request, we
            try to make this function as simple as possible and let the helper functions to do
            the "hard" work.
        </p><p>
            </p><pre class="programlisting">
sub _Add {
    my ( $Self, %Param ) = @_;

    my %GetParam;
    for my $Needed (qw(ObjectType FieldType FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$Needed ) {
            return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
                Message =&gt; "Need $Needed",
            );
        }
    }

    # get the object type and field type display name
    my $ObjectTypeName = $Self-&gt;{ObjectTypeConfig}-&gt;{ $GetParam{ObjectType} }-&gt;{DisplayName} || '';
    my $FieldTypeName  = $Self-&gt;{FieldTypeConfig}-&gt;{ $GetParam{FieldType} }-&gt;{DisplayName}   || '';

    return $Self-&gt;_ShowScreen(
        %Param,
        %GetParam,
        Mode           =&gt; 'Add',
        ObjectTypeName =&gt; $ObjectTypeName,
        FieldTypeName  =&gt; $FieldTypeName,
    );
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>_Add()</em></span> function  is also pretty simple, it just get some parameters
            from the web request and call the <span class="emphasis"><em>_ShowScreen()</em></span> function, normally
            this function is not needed to be modified.
        </p><p>
            </p><pre class="programlisting">
sub _AddAction {
    my ( $Self, %Param ) = @_;

    my %Errors;
    my %GetParam;

    for my $Needed (qw(Name Label FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$GetParam{$Needed} ) {
            $Errors{ $Needed . 'ServerError' }        = 'ServerError';
            $Errors{ $Needed . 'ServerErrorMessage' } = 'This field is required.';
        }
    }

    if ( $GetParam{Name} ) {

        # check if name is alphanumeric
        if ( $GetParam{Name} !~ m{\A ( ?: [a-zA-Z] | \d )+ \z}xms ) {

            # add server error error class
            $Errors{NameServerError} = 'ServerError';
            $Errors{NameServerErrorMessage} =
                'The field does not contain only ASCII letters and numbers.';
        }

        # check if name is duplicated
        my %DynamicFieldsList = %{
            $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldList(
                Valid      =&gt; 0,
                ResultType =&gt; 'HASH',
                )
            };

        %DynamicFieldsList = reverse %DynamicFieldsList;

        if ( $DynamicFieldsList{ $GetParam{Name} } ) {

            # add server error error class
            $Errors{NameServerError}        = 'ServerError';
            $Errors{NameServerErrorMessage} = 'There is another field with the same name.';
        }
    }

    if ( $GetParam{FieldOrder} ) {

        # check if field order is numeric and positive
        if ( $GetParam{FieldOrder} !~ m{\A ( ?: \d )+ \z}xms ) {

            # add server error error class
            $Errors{FieldOrderServerError}        = 'ServerError';
            $Errors{FieldOrderServerErrorMessage} = 'The field must be numeric.';
        }
    }

    for my $ConfigParam (
        qw(
            ObjectType ObjectTypeName FieldType FieldTypeName DefaultValue ValidID ShowValue
            ValueMask
        )
        )
    {
        $GetParam{$ConfigParam} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $ConfigParam );
    }

    # uncorrectable errors
    if ( !$GetParam{ValidID} ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ValidID",
        );
    }

    # return to add screen if errors
    if (%Errors) {
        return $Self-&gt;_ShowScreen(
            %Param,
            %Errors,
            %GetParam,
            Mode =&gt; 'Add',
        );
    }

    # set specific config
    my $FieldConfig = {
        DefaultValue =&gt; $GetParam{DefaultValue},
        ShowValue    =&gt; $GetParam{ShowValue},
        ValueMask    =&gt; $GetParam{ValueMask} || $Self-&gt;{DefaultValueMask},
    };

    # create a new field
    my $FieldID = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldAdd(
        Name       =&gt; $GetParam{Name},
        Label      =&gt; $GetParam{Label},
        FieldOrder =&gt; $GetParam{FieldOrder},
        FieldType  =&gt; $GetParam{FieldType},
        ObjectType =&gt; $GetParam{ObjectType},
        Config     =&gt; $FieldConfig,
        ValidID    =&gt; $GetParam{ValidID},
        UserID     =&gt; $Self-&gt;{UserID},
    );

    if ( !$FieldID ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not create the new field",
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;Redirect(
        OP =&gt; "Action=AdminDynamicField",
    );
}
            </pre><p>
        </p><p>
            The <span class="emphasis"><em>_AddAction()</em></span> function gets the configuration parameters from
            a new dynamic field, it validates the Dynamic Field name only contains letters and
            numbers. This function could validate any other parameter.
        </p><p>
            Name, Label, FieldOrder, Validity are common parameters for all Dynamic Fields and they
            are required. Each Dynamic Field has its specific configuration that must contain at
            least the DefaultValue parameter, in this case it also have ShowValue and ValueMask
            parameters for Password field.
        </p><p>
            If the field has the ability to store a fixed list of values they need should be stored
            in the PossibleValues parameter inside the specific configuration hash.
        </p><p>
            As in other Admin Modules, if a parameter is not valid this function returns to the
            Add screen highlighting the erroneous form fields.
        </p><p>
            If all the parameters are correct it creates a new Dynamic Field.
        </p><p>
            </p><pre class="programlisting">
sub _Change {
    my ( $Self, %Param ) = @_;

    my %GetParam;
    for my $Needed (qw(ObjectType FieldType)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$Needed ) {
            return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
                Message =&gt; "Need $Needed",
            );
        }
    }

    # get the object type and field type display name
    my $ObjectTypeName = $Self-&gt;{ObjectTypeConfig}-&gt;{ $GetParam{ObjectType} }-&gt;{DisplayName} || '';
    my $FieldTypeName  = $Self-&gt;{FieldTypeConfig}-&gt;{ $GetParam{FieldType} }-&gt;{DisplayName}   || '';

    my $FieldID = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; 'ID' );

    if ( !$FieldID ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ID",
        );
    }

    # get dynamic field data
    my $DynamicFieldData = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldGet(
        ID =&gt; $FieldID,
    );

    # check for valid dynamic field configuration
    if ( !IsHashRefWithData($DynamicFieldData) ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not get data for dynamic field $FieldID",
        );
    }

    my %Config = ();

    # extract configuration
    if ( IsHashRefWithData( $DynamicFieldData-&gt;{Config} ) ) {
        %Config = %{ $DynamicFieldData-&gt;{Config} };
    }

    return $Self-&gt;_ShowScreen(
        %Param,
        %GetParam,
        %${DynamicFieldData},
        %Config,
        ID             =&gt; $FieldID,
        Mode           =&gt; 'Change',
        ObjectTypeName =&gt; $ObjectTypeName,
        FieldTypeName  =&gt; $FieldTypeName,
    );
}
            </pre><p>
        </p><p>
            The "_Change" function is very similar to the "_Add" function but since this function is
            used to edit an existing field it needs to validated the FieldID parameter and gather
            the current Dynamic Field data.
        </p><p>
            </p><pre class="programlisting">
sub _ChangeAction {
    my ( $Self, %Param ) = @_;

    my %Errors;
    my %GetParam;

    for my $Needed (qw(Name Label FieldOrder)) {
        $GetParam{$Needed} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $Needed );
        if ( !$GetParam{$Needed} ) {
            $Errors{ $Needed . 'ServerError' }        = 'ServerError';
            $Errors{ $Needed . 'ServerErrorMessage' } = 'This field is required.';
        }
    }

    my $FieldID = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; 'ID' );
    if ( !$FieldID ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ID",
        );
    }

    if ( $GetParam{Name} ) {

        # check if name is lowercase
        if ( $GetParam{Name} !~ m{\A ( ?: [a-zA-Z] | \d )+ \z}xms ) {

            # add server error error class
            $Errors{NameServerError} = 'ServerError';
            $Errors{NameServerErrorMessage} =
                'The field does not contain only ASCII letters and numbers.';
        }

        # check if name is duplicated
        my %DynamicFieldsList = %{
            $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldList(
                Valid      =&gt; 0,
                ResultType =&gt; 'HASH',
                )
            };

        %DynamicFieldsList = reverse %DynamicFieldsList;

        if (
            $DynamicFieldsList{ $GetParam{Name} } &amp;&amp;
            $DynamicFieldsList{ $GetParam{Name} } ne $FieldID
            )
        {

            # add server error class
            $Errors{NameServerError}        = 'ServerError';
            $Errors{NameServerErrorMessage} = 'There is another field with the same name.';
        }
    }

    if ( $GetParam{FieldOrder} ) {

        # check if field order is numeric and positive
        if ( $GetParam{FieldOrder} !~ m{\A ( ?: \d )+ \z}xms ) {

            # add server error error class
            $Errors{FieldOrderServerError}        = 'ServerError';
            $Errors{FieldOrderServerErrorMessage} = 'The field must be numeric.';
        }
    }

    for my $ConfigParam (
        qw(
            ObjectType ObjectTypeName FieldType FieldTypeName DefaultValue ValidID ShowValue
            ValueMask
        )
        )
    {
        $GetParam{$ConfigParam} = $Self-&gt;{ParamObject}-&gt;GetParam( Param =&gt; $ConfigParam );
    }

    # uncorrectable errors
    if ( !$GetParam{ValidID} ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Need ValidID",
        );
    }

    # get dynamic field data
    my $DynamicFieldData = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldGet(
        ID =&gt; $FieldID,
    );

    # check for valid dynamic field configuration
    if ( !IsHashRefWithData($DynamicFieldData) ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not get data for dynamic field $FieldID",
        );
    }

    # return to change screen if errors
    if (%Errors) {
        return $Self-&gt;_ShowScreen(
            %Param,
            %Errors,
            %GetParam,
            ID   =&gt; $FieldID,
            Mode =&gt; 'Change',
        );
    }

    # set specific config
    my $FieldConfig = {
        DefaultValue =&gt; $GetParam{DefaultValue},
        ShowValue    =&gt; $GetParam{ShowValue},
        ValueMask    =&gt; $GetParam{ValueMask},
    };

    # update dynamic field (FieldType and ObjectType cannot be changed; use old values)
    my $UpdateSuccess = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldUpdate(
        ID         =&gt; $FieldID,
        Name       =&gt; $GetParam{Name},
        Label      =&gt; $GetParam{Label},
        FieldOrder =&gt; $GetParam{FieldOrder},
        FieldType  =&gt; $DynamicFieldData-&gt;{FieldType},
        ObjectType =&gt; $DynamicFieldData-&gt;{ObjectType},
        Config     =&gt; $FieldConfig,
        ValidID    =&gt; $GetParam{ValidID},
        UserID     =&gt; $Self-&gt;{UserID},
    );

    if ( !$UpdateSuccess ) {
        return $Self-&gt;{LayoutObject}-&gt;ErrorScreen(
            Message =&gt; "Could not update the field $GetParam{Name}",
        );
    }

    return $Self-&gt;{LayoutObject}-&gt;Redirect(
        OP =&gt; "Action=AdminDynamicField",
    );
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>_ChangeAction()</em></span> is very similar to
            <span class="emphasis"><em>_AddAction()</em></span>", but adapted for the update of an existing field
            instead of creating a new one.
        </p><p>
            </p><pre class="programlisting">
sub _ShowScreen {
    my ( $Self, %Param ) = @_;

    $Param{DisplayFieldName} = 'New';

    if ( $Param{Mode} eq 'Change' ) {
        $Param{ShowWarning}      = 'ShowWarning';
        $Param{DisplayFieldName} = $Param{Name};
    }

    # header
    my $Output = $Self-&gt;{LayoutObject}-&gt;Header();
    $Output .= $Self-&gt;{LayoutObject}-&gt;NavigationBar();

    # get all fields
    my $DynamicFieldList = $Self-&gt;{DynamicFieldObject}-&gt;DynamicFieldListGet(
        Valid =&gt; 0,
    );

    # get the list of order numbers (is already sorted).
    my @DynamicfieldOrderList;
    for my $Dynamicfield ( @{$DynamicFieldList} ) {
        push @DynamicfieldOrderList, $Dynamicfield-&gt;{FieldOrder};
    }

    # when adding we need to create an extra order number for the new field
    if ( $Param{Mode} eq 'Add' ) {

        # get the last element form the order list and add 1
        my $LastOrderNumber = $DynamicfieldOrderList[-1];
        $LastOrderNumber++;

        # add this new order number to the end of the list
        push @DynamicfieldOrderList, $LastOrderNumber;
    }

    my $DynamicFieldOrderSrtg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data          =&gt; \@DynamicfieldOrderList,
        Name          =&gt; 'FieldOrder',
        SelectedValue =&gt; $Param{FieldOrder} || 1,
        PossibleNone  =&gt; 0,
        Class         =&gt; 'W50pc Validate_Number',
    );

    my %ValidList = $Self-&gt;{ValidObject}-&gt;ValidList();

    # create the Validity select
    my $ValidityStrg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data         =&gt; \%ValidList,
        Name         =&gt; 'ValidID',
        SelectedID   =&gt; $Param{ValidID} || 1,
        PossibleNone =&gt; 0,
        Translation  =&gt; 1,
        Class        =&gt; 'W50pc',
    );

    # define config field specific settings
    my $DefaultValue = ( defined $Param{DefaultValue} ? $Param{DefaultValue} : '' );

    # create the Show value select
    my $ShowValueStrg = $Self-&gt;{LayoutObject}-&gt;BuildSelection(
        Data          =&gt; ['No', 'Yes'],
        Name          =&gt; 'ShowValue',
        SelectedValue =&gt; $Param{ShowValue} || 'No',
        PossibleNone  =&gt; 0,
        Translation   =&gt; 1,
        Class         =&gt; 'W50pc',
    );

    # generate output
    $Output .= $Self-&gt;{LayoutObject}-&gt;Output(
        TemplateFile =&gt; 'AdminDynamicFieldPassword',
        Data         =&gt; {
            %Param,
            ValidityStrg          =&gt; $ValidityStrg,
            DynamicFieldOrderSrtg =&gt; $DynamicFieldOrderSrtg,
            DefaultValue          =&gt; $DefaultValue,
            ShowValueStrg         =&gt; $ShowValueStrg,
            ValueMask             =&gt; $Param{ValueMask} || $Self-&gt;{DefaultValueMask},
        },
    );

    $Output .= $Self-&gt;{LayoutObject}-&gt;Footer();

    return $Output;
}
            </pre><p>
        </p><p>
            The <span class="emphasis"><em>_ShowScreen</em></span> function is used to set and define the HTML
            elements and blocks from a DTL template to generate the Admin Dialog HTML code.
        </p></div></div><div class="section" title="Dynamic Field DTL Template for Admin Dialog Example"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-template"></a>Dynamic Field DTL Template for Admin Dialog Example</h6></div></div></div><p>
        The template is the place where the HTML code of the dialog is stored.
    </p><div class="section" title="Code Example:"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-admin-module-template-code"></a>Code Example:</h6></div></div></div><p>
                In this section an Admin Dialog DTL Template for the password Dynamic Field is
                shown and explained.
            </p><p>
            </p><pre class="programlisting">
# --
# AdminDynamicFieldPassword.dtl - provides HTML form for AdminDynamicFieldPassword
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --
            </pre><p>
        </p><p>
            This is common header that can be found in common OTRS modules.
        </p><p>
            </p><pre class="programlisting">
&lt;div class="MainBox ARIARoleMain LayoutFixedSidebar SidebarFirst"&gt;
    &lt;h1&gt;$Text{"Dynamic Fields"} - $Text{"$Data{"ObjectTypeName"}"}: $Text{"$Data{"Mode"}"} $Text{"$Data{"FieldTypeName"}"} $Text{"Field"}&lt;/h1&gt;

    &lt;div class="Clear"&gt;&lt;/div&gt;

    &lt;div class="SidebarColumn"&gt;
        &lt;div class="WidgetSimple"&gt;
            &lt;div class="Header"&gt;
                &lt;h2&gt;$Text{"Actions"}&lt;/h2&gt;
            &lt;/div&gt;
            &lt;div class="Content"&gt;
                &lt;ul class="ActionList"&gt;
                    &lt;li&gt;
                        &lt;a href="$Env{"Baselink"}Action=AdminDynamicField" class="CallForAction"&gt;&lt;span&gt;$Text{"Go back to overview"}&lt;/span&gt;&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
            </pre><p>
        </p><p>
            This is part of the code has the main box and also the actions side bar, no
            modifications are needed in this section.
        </p><p>
            </p><pre class="programlisting">
    &lt;div class="ContentColumn"&gt;
        &lt;form action="$Env{"CGIHandle"}" method="post" class="Validate PreventMultipleSubmits"&gt;
            &lt;input type="hidden" name="Action" value="AdminDynamicFieldPassword" /&gt;
            &lt;input type="hidden" name="Subaction" value="$QData{"Mode"}Action" /&gt;
            &lt;input type="hidden" name="ObjectType" value="$QData{"ObjectType"}" /&gt;
            &lt;input type="hidden" name="FieldType" value="$QData{"FieldType"}" /&gt;
            &lt;input type="hidden" name="ID" value="$QData{"ID"}" /&gt;
            </pre><p>
        </p><p>
            In this section of the code is defined the right part of the dialog, notice that the
            value of the Action hidden input must match with the name of the Admin Dialog.
        </p><p>
            </p><pre class="programlisting">
            &lt;div class="WidgetSimple"&gt;
                &lt;div class="Header"&gt;
                    &lt;h2&gt;$Text{"General"}&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class="Content"&gt;
                    &lt;div class="LayoutGrid ColumnsWithSpacing"&gt;
                        &lt;div class="Size1of2"&gt;
                            &lt;fieldset class="TableLike"&gt;
                                &lt;label class="Mandatory" for="Name"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; $Text{"Name"}:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="Name" class="W50pc $QData{"NameServerError"} $QData{"ShowWarning"}  Validate_Alphanumeric" type="text" maxlength="200" value="$QData{"Name"}" name="Name"/&gt;
                                    &lt;div id="NameError" class="TooltipErrorMessage"&gt;&lt;p&gt;$Text{"This field is required, and the value should be alphabetic and numeric characters only."}&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="NameServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;$Text{"$Data{"NameServerErrorMessage"}"}&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;$Text{"Must be unique and only accept alphabetic and numeric characters."}&lt;/p&gt;
                                    &lt;p class="Warning Hidden"&gt;$Text{"Changing this value will require manual changes in the system."}&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;label class="Mandatory" for="Label"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; $Text{"Label"}:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="Label" class="W50pc $QData{"LabelServerError"} Validate_Required" type="text" maxlength="200" value="$QData{"Label"}" name="Label"/&gt;
                                    &lt;div id="LabelError" class="TooltipErrorMessage"&gt;&lt;p&gt;$Text{"This field is required."}&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="LabelServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;$Text{"$Data{"LabelServerErrorMessage"}"}&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;$Text{"This is the name to be shown on the screens where the field is active."}&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;label class="Mandatory" for="FieldOrder"&gt;&lt;span class="Marker"&gt;*&lt;/span&gt; $Text{"Field order"}:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    $Data{"DynamicFieldOrderSrtg"}
                                    &lt;div id="FieldOrderError" class="TooltipErrorMessage"&gt;&lt;p&gt;$Text{"This field is required and must be numeric."}&lt;/p&gt;&lt;/div&gt;
                                    &lt;div id="FieldOrderServerError" class="TooltipErrorMessage"&gt;&lt;p&gt;$Text{"$Data{"FieldOrderServerErrorMessage"}"}&lt;/p&gt;&lt;/div&gt;
                                    &lt;p class="FieldExplanation"&gt;$Text{"This is the order in which this field will be shown on the screens where is active."}&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;
                            &lt;/fieldset&gt;
                        &lt;/div&gt;
                        &lt;div class="Size1of2"&gt;
                            &lt;fieldset class="TableLike"&gt;
                                &lt;label for="ValidID"&gt;$Text{"Validity"}:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    $Data{"ValidityStrg"}
                                &lt;/div&gt;
                                &lt;div class="Clear"&gt;&lt;/div&gt;

                                &lt;div class="SpacingTop"&gt;&lt;/div&gt;
                                &lt;label for="FieldTypeName"&gt;$Text{"Field type"}:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="FieldTypeName" readonly="readonly" class="W50pc" type="text" maxlength="200" value="$QData{"FieldTypeName"}" name="FieldTypeName"/&gt;
                                    &lt;div class="Clear"&gt;&lt;/div&gt;
                                &lt;/div&gt;

                                &lt;div class="SpacingTop"&gt;&lt;/div&gt;
                                &lt;label for="ObjectTypeName"&gt;$Text{"Object type"}:&lt;/label&gt;
                                &lt;div class="Field"&gt;
                                    &lt;input id="ObjectTypeName" readonly="readonly" class="W50pc" type="text" maxlength="200" value="$QData{"ObjectTypeName"}" name="ObjectTypeName"/&gt;
                                    &lt;div class="Clear"&gt;&lt;/div&gt;
                                &lt;/div&gt;
                            &lt;/fieldset&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            </pre><p>
        </p><p>
            This first widget contains the common form attributes for the Dynamic Fields, for
            consistency with other Dynamic Fields is recommended to leave this part of the code
            unchanged.
        </p><p>
            </p><pre class="programlisting">
            &lt;div class="WidgetSimple"&gt;
                &lt;div class="Header"&gt;
                    &lt;h2&gt;$Text{"$Data{"FieldTypeName"}"} $Text{"Field Settings"}&lt;/h2&gt;
                &lt;/div&gt;
                &lt;div class="Content"&gt;
                    &lt;fieldset class="TableLike"&gt;

                        &lt;label for="DefaultValue"&gt;$Text{"Default value"}:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            &lt;input id="DefaultValue" class="W50pc" type="text" maxlength="200" value="$QData{"DefaultValue"}" name="DefaultValue"/&gt;
                            &lt;p class="FieldExplanation"&gt;$Text{"This is the default value for this field."}&lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                        &lt;label for="ShowValue"&gt;$Text{"Show value"}:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                                $Data{"ShowValueStrg"}
                                &lt;p class="FieldExplanation"&gt;
                                    $Text{"To reveal the field value in non edit screens ( e.g. Ticket Zoom Screen )"}
                                &lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                        &lt;label for="ValueMask"&gt;$Text{"Hidden value mask"}:&lt;/label&gt;
                        &lt;div class="Field"&gt;
                            &lt;input id="ValueMask" class="W50pc" type="text" maxlength="200" value="$QData{"ValueMask"}" name="ValueMask"/&gt;
                            &lt;p class="FieldExplanation"&gt;
                                $Text{"This is the alternate value to show if Show value is set to "No" ( Default: **** )."}
                            &lt;/p&gt;
                        &lt;/div&gt;
                        &lt;div class="Clear"&gt;&lt;/div&gt;

                    &lt;/fieldset&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            </pre><p>
        </p><p>
            The second widget has the Dynamic Field specific form attributes. This is the place
            where new attributes cat be set and it could use Java Script and AJAX technologies to
            make it more easy or friendly for the end user.
        </p><p>
            </p><pre class="programlisting">
            &lt;fieldset class="TableLike"&gt;
                &lt;div class="Field SpacingTop"&gt;
                    &lt;button type="submit" class="Primary" value="$Text{"Save"}"&gt;$Text{"Save"}&lt;/button&gt;
                    $Text{"or"}
                    &lt;a href="$Env{"Baselink"}Action=AdminDynamicField"&gt;$Text{"Cancel"}&lt;/a&gt;
                &lt;/div&gt;
                &lt;div class="Clear"&gt;&lt;/div&gt;
            &lt;/fieldset&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--dtl:js_on_document_complete--&gt;
&lt;script type="text/javascript"&gt;//&lt;![CDATA[
$('.ShowWarning').bind('change keyup', function (Event) {
    $('p.Warning').removeClass('Hidden');
});

Core.Agent.Admin.DynamicField.ValidationInit();
//]]&gt;&lt;/script&gt;
&lt;!--dtl:js_on_document_complete--&gt;
            </pre><p>
        </p><p>
            The final part of the file contains the "Submit" button and the "Cancel" link, as well
            as other needed Java Script code.
        </p></div></div><div class="section" title="Dynamic Field Delegate Example"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-delegate"></a>Dynamic Field Delegate Example</h6></div></div></div><p>
        The delegate <span class="emphasis"><em>is</em></span> the Dynamic Field. It contains several functions that
        are used wide in the OTRS framework. It's mandatory to implement all this functions.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Please refer to the Perl Online Documentation (POD) of the module
            /Kernel/System/DynmicField/Backend.pm to have the list of all attributes and possible
            return data for each function.
        </p></div><div class="section" title="Code Example:"><div class="titlepage"><div><div><h6 class="title"><a name="dynamic-fields-new-field-delegate-code"></a>Code Example:</h6></div></div></div><p>
            In this section the Password Dynamic Field delegate is shown and explained.
         </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/DynamicField/Backend/Password.pm - Delegate for DynamicField Password backend
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::DynamicField::Backend::Password;

use strict;
use warnings;

use Kernel::System::VariableCheck qw(:all);
use Kernel::System::DynamicFieldValue;
use Kernel::System::DynamicField::Backend::BackendCommon;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.1 $) [1];
            </pre><p>
        </p><p>
            This is the common header that can be found in common OTRS modules. The class/package
            name is declared via the package keyword.
        </p><p>
            </p><pre class="programlisting">
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # get needed objects
    for my $Needed (qw(ConfigObject EncodeObject LogObject MainObject DBObject)) {
        die "Got no $Needed!" if !$Param{$Needed};

        $Self-&gt;{$Needed} = $Param{$Needed};
    }

    # create additional objects
    $Self-&gt;{DynamicFieldValueObject} = Kernel::System::DynamicFieldValue-&gt;new( %{$Self} );
    $Self-&gt;{BackendCommonObject}
        = Kernel::System::DynamicField::Backend::BackendCommon-&gt;new( %{$Self} );

    return $Self;
}
            </pre><p>
        </p><p>
            The constructor <span class="emphasis"><em>new</em></span> creates a new instance of the class. According
            to the coding guidelines objects of other classes that are needed in this module should
            be created here.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Delegates are created only by the BankendObject and not directly from any other
                module.
            </p></div><p>
            </p><pre class="programlisting">
sub ValueGet {
    my ( $Self, %Param ) = @_;

    my $DFValue = $Self-&gt;{DynamicFieldValueObject}-&gt;ValueGet(
        FieldID  =&gt; $Param{DynamicFieldConfig}-&gt;{ID},
        ObjectID =&gt; $Param{ObjectID},
    );

    return if !$DFValue;
    return if !IsArrayRefWithData($DFValue);
    return if !IsHashRefWithData( $DFValue-&gt;[0] );

    return $DFValue-&gt;[0]-&gt;{ValueText};
}
            </pre><p>
        </p><p>
            This function retrieves the value from the field on a specified Object. In this case we
            are returning the first text value, since the field only stores one text value at time.
        </p><p>
            </p><pre class="programlisting">
sub ValueSet {
    my ( $Self, %Param ) = @_;

    my $Success = $Self-&gt;{DynamicFieldValueObject}-&gt;ValueSet(
        FieldID  =&gt; $Param{DynamicFieldConfig}-&gt;{ID},
        ObjectID =&gt; $Param{ObjectID},
        Value    =&gt; [
            {
                ValueText =&gt; $Param{Value},
            },
        ],
        UserID =&gt; $Param{UserID},
    );

    return $Success;
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>ValueSet()</em></span> is used to store a Dynamic Field value, in this case
            this field only stores one text type value. Other fields could store more than one
            value on either ValueText, ValueDateTime, or ValueInt format.
        </p><p>
            </p><pre class="programlisting">
sub ValueDelete {
    my ( $Self, %Param ) = @_;

    my $Success = $Self-&gt;{DynamicFieldValueObject}-&gt;ValueDelete(
        FieldID  =&gt; $Param{DynamicFieldConfig}-&gt;{ID},
        ObjectID =&gt; $Param{ObjectID},
        UserID   =&gt; $Param{UserID},
    );

    return $Success;
}
            </pre><p>
        </p><p>
            This function is used to delete one field value attached to a particular object ID, is
            used for example if the instance of object is to be deleted, then there is no reason to
            have the field value stored in the database for that particular object instance.
        </p><p>
            </p><pre class="programlisting">
sub AllValuesDelete {
    my ( $Self, %Param ) = @_;

    my $Success = $Self-&gt;{DynamicFieldValueObject}-&gt;AllValuesDelete(
        FieldID =&gt; $Param{DynamicFieldConfig}-&gt;{ID},
        UserID  =&gt; $Param{UserID},
    );

    return $Success;
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>AllValuesDelete()</em></span> function is used to delete all values from a
            certain Dynamic Field. This function is very useful when a Dynamic Field is going to be
            deleted.
        </p><p>
            </p><pre class="programlisting">
sub ValueValidate {
    my ( $Self, %Param ) = @_;

    my $Success = $Self-&gt;{DynamicFieldValueObject}-&gt;ValueValidate(
        Value =&gt; {
            ValueText =&gt; $Param{Value},
        },
        UserID =&gt; $Param{UserID}
    );

    return $Success;
}
            </pre><p>
        </p><p>
            The <span class="emphasis"><em>ValueValidate()</em></span> function is used to check if the value is
            consistent to its type.
        </p><p>
            </p><pre class="programlisting">
sub SearchSQLGet {
    my ( $Self, %Param ) = @_;

    my %Operators = (
        Equals            =&gt; '=',
        GreaterThan       =&gt; '&gt;',
        GreaterThanEquals =&gt; '&gt;=',
        SmallerThan       =&gt; '&lt;',
        SmallerThanEquals =&gt; '&lt;=',
    );

    if ( $Operators{ $Param{Operator} } ) {
        my $SQL = " $Param{TableAlias}.value_text $Operators{$Param{Operator}} '";
        $SQL .= $Self-&gt;{DBObject}-&gt;Quote( $Param{SearchTerm} ) . "' ";
        return $SQL;
    }

    if ( $Param{Operator} eq 'Like' ) {

        my $SQL = $Self-&gt;{DBObject}-&gt;QueryCondition(
            Key   =&gt; "$Param{TableAlias}.value_text",
            Value =&gt; $Param{SearchTerm},
        );

        return $SQL;
    }

    $Self-&gt;{'LogObject'}-&gt;Log(
        'Priority' =&gt; 'error',
        'Message'  =&gt; "Unsupported Operator $Param{Operator}",
    );

    return;
}
            </pre><p>
        </p><p>
            This function is used by TicketSearch core module to build the internal query to search
            for a ticket based on this field as a search parameter.
        </p><p>
            </p><pre class="programlisting">
sub SearchSQLOrderFieldGet {
    my ( $Self, %Param ) = @_;

    return "$Param{TableAlias}.value_text";
}
            </pre><p>
        </p><p>
            The <span class="emphasis"><em>SearchSQLOrderFieldGet</em></span> is also a helper for TicketSearch
            module, "$Param{TableAlias}." should be kept and "value_text" could be replaced with
            "value_date" or "value_int" depending on the field.
        </p><p>
        </p><pre class="programlisting">
sub EditFieldRender {
    my ( $Self, %Param ) = @_;

    # take config from field config
    my $FieldConfig = $Param{DynamicFieldConfig}-&gt;{Config};
    my $FieldName   = 'DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name};
    my $FieldLabel  = $Param{DynamicFieldConfig}-&gt;{Label};

    my $Value = '';

    # set the field value or default
    if ( $Param{UseDefaultValue} ) {
        $Value = ( defined $FieldConfig-&gt;{DefaultValue} ? $FieldConfig-&gt;{DefaultValue} : '' );
    }
    $Value = $Param{Value} if defined $Param{Value};

    # extract the dynamic field value form the web request
    my $FieldValue = $Self-&gt;EditFieldValueGet(
        %Param,
    );

    # set values from ParamObject if present
    if ( defined $FieldValue ) {
        $Value = $FieldValue;
    }

    # check and set class if necessary
    my $FieldClass = 'DynamicFieldText';
    if ( defined $Param{Class} &amp;&amp; $Param{Class} ne '' ) {
        $FieldClass .= ' ' . $Param{Class};
    }

    # set field as mandatory
    $FieldClass .= ' Validate_Required' if $Param{Mandatory};

    # set error css class
    $FieldClass .= ' ServerError' if $Param{ServerError};

    my $HTMLString = &lt;&lt;"EOF";
&lt;input type="password" class="$FieldClass" id="$FieldName" name="$FieldName" title="$FieldLabel" value="$Value" /&gt;
EOF

    if ( $Param{Mandatory} ) {
        my $DivID = $FieldName . 'Error';

        # for client side validation
        $HTMLString .= &lt;&lt;"EOF";
    &lt;div id="$DivID" class="TooltipErrorMessage"&gt;
        &lt;p&gt;
            \$Text{"This field is required."}
        &lt;/p&gt;
    &lt;/div&gt;
EOF
    }

    if ( $Param{ServerError} ) {

        my $ErrorMessage = $Param{ErrorMessage} || 'This field is required.';
        my $DivID = $FieldName . 'ServerError';

        # for server side validation
        $HTMLString .= &lt;&lt;"EOF";
    &lt;div id="$DivID" class="TooltipErrorMessage"&gt;
        &lt;p&gt;
            \$Text{"$ErrorMessage"}
        &lt;/p&gt;
    &lt;/div&gt;
EOF
    }

    # call EditLabelRender on the common backend
    my $LabelString = $Self-&gt;{BackendCommonObject}-&gt;EditLabelRender(
        DynamicFieldConfig =&gt; $Param{DynamicFieldConfig},
        Mandatory          =&gt; $Param{Mandatory} || '0',
        FieldName          =&gt; $FieldName,
    );

    my $Data = {
        Field =&gt; $HTMLString,
        Label =&gt; $LabelString,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            This function is the responsible to create the HTML representation of the field and its
            label, and is used in the edit screens like "AgentTicketPhone", "AgentTicketNote", etc
        </p><p>
            </p><pre class="programlisting">
sub EditFieldValueGet {
    my ( $Self, %Param ) = @_;

    my $FieldName = 'DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name};

    my $Value;

    # check if there is a Template and retreive the dinalic field value from there
    if ( IsHashRefWithData( $Param{Template} ) ) {
        $Value = $Param{Template}-&gt;{$FieldName};
    }

    # otherwise get dynamic field value form param
    else {
        $Value = $Param{ParamObject}-&gt;GetParam( Param =&gt; $FieldName );
    }

    if ( defined $Param{ReturnTemplateStructure} &amp;&amp; $Param{ReturnTemplateStructure} eq '1' ) {
        return {
            $FieldName =&gt; $Value,
        };
    }

    # for this field the normal return an the ReturnValueStructure are the same
    return $Value;
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>EditFieldValueGet()</em></span> is a function used in the edit screens of OTRS
            and its purpose is to get the value of the field, either form a template like generic
            agent profile or from a web request. This function gets the web request in the
            $Param{ParamObject}, that is a copy of the ParamObject of the Frontend Module or screen.
        </p><p>
            There are two return formats for this function, the normal: that is just the raw value
            or a structure: that is the pair field name =&gt; field value. for example a Date Dynamic
            Field returns normally the date as string, and if it should return the an structure it
            returns a pair for each part of the the date in the hash.
        </p><p>
            The if the result should be a structure then, normally this is used to store its values
            in a template, like a generic agent profile. For example a date field uses several HTML
            components to build the field, like the "Used" check-box and selects for year, month,
            day etc.
        </p><p>
            </p><pre class="programlisting">
sub EditFieldValueValidate {
    my ( $Self, %Param ) = @_;

    # get the field value from the http request
    my $Value = $Self-&gt;EditFieldValueGet(
        DynamicFieldConfig =&gt; $Param{DynamicFieldConfig},
        ParamObject        =&gt; $Param{ParamObject},

        # not necessary for this backend but place it for consistency reasons
        ReturnValueStructure =&gt; 1,
    );

    my $ServerError;
    my $ErrorMessage;

    # perform necessary validations
    if ( $Param{Mandatory} &amp;&amp; $Value eq '' ) {
        $ServerError = 1;
    }

    # create resulting structure
    my $Result = {
        ServerError  =&gt; $ServerError,
        ErrorMessage =&gt; $ErrorMessage,
    };

    return $Result;
}
            </pre><p>
        </p><p>
            This function should provide at least, a method to validate if the field is empty, and
            return an error if the field is empty and mandatory, but it can also do more validations
            for other kind of fields, like if the option selected is valid, or if a date should be
            only in the past etc. It can provide a custom error message also.
        </p><p>
            </p><pre class="programlisting">
sub DisplayValueRender {
    my ( $Self, %Param ) = @_;

    # set HTMLOuput as default if not specified
    if ( !defined $Param{HTMLOutput} ) {
        $Param{HTMLOutput} = 1;
    }

    my $Value;
    my $Title;

    # check if field is set to show password or not
    if (
        defined $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue}
        &amp;&amp; $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue} eq 'Yes'
        )
    {

        # get raw Title and Value strings from field value
        $Value = defined $Param{Value} ? $Param{Value} : '';
        $Title = $Value;
    }
    else{

        # show the mask and not the value
        $Value = $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ValueMask} || '';
        $Title = 'The value of this field is hidden.'
    }

    # HTMLOuput transformations
    if ( $Param{HTMLOutput} ) {
        $Value = $Param{LayoutObject}-&gt;Ascii2Html(
            Text =&gt; $Value,
            Max =&gt; $Param{ValueMaxChars} || '',
        );

        $Title = $Param{LayoutObject}-&gt;Ascii2Html(
            Text =&gt; $Title,
            Max =&gt; $Param{TitleMaxChars} || '',
        );
    }
    else {
        if ( $Param{ValueMaxChars} &amp;&amp; length($Value) &gt; $Param{ValueMaxChars} ) {
            $Value = substr( $Value, 0, $Param{ValueMaxChars} ) . '...';
        }
        if ( $Param{TitleMaxChars} &amp;&amp; length($Title) &gt; $Param{TitleMaxChars} ) {
            $Title = substr( $Title, 0, $Param{TitleMaxChars} ) . '...';
        }
    }

    # create return structure
    my $Data = {
        Value =&gt; $Value,
        Title =&gt; $Title,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>DisplayValueRender()</em></span> function returns the field value as a plain
            text as well as its title (both can be translated). for this particular example we are
            checking if the password should be reveled or display a predefined mask by  a
            configuration parameter in the Dynamic Field.
        </p><p>
            </p><pre class="programlisting">
sub IsSortable {
    my ( $Self, %Param ) = @_;

    # we don't want to sort by password
    return 0;
}
            </pre><p>
        </p><p>
            This functions just return 1, if the field can be used for sorting (e.g. in ticket
            overview screens), or 0 if it can't.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldRender {
    my ( $Self, %Param ) = @_;

    # take config from field config
    my $FieldConfig = $Param{DynamicFieldConfig}-&gt;{Config};
    my $FieldName   = 'Search_DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name};
    my $FieldLabel  = $Param{DynamicFieldConfig}-&gt;{Label};

    # set the field value
    my $Value = ( defined $Param{DefaultValue} ? $Param{DefaultValue} : '' );

    # get the field value, this fuction is always called after the profile is loaded
    my $FieldValue = $Self-&gt;SearchFieldValueGet(%Param);

    # set values from profile if present
    if ( defined $FieldValue ) {
        $Value = $FieldValue;
    }

    # check and set class if necessary
    my $FieldClass = 'DynamicFieldText';

    my $HTMLString = &lt;&lt;"EOF";
&lt;input type="text" class="$FieldClass" id="$FieldName" name="$FieldName" title="$FieldLabel" value="$Value" /&gt;
EOF

    my $AdditionalText;
    if ( $Param{UseLabelHints} ) {
        $AdditionalText = 'e.g. Text or Te*t';
    }

    # call EditLabelRender on the common backend
    my $LabelString = $Self-&gt;{BackendCommonObject}-&gt;EditLabelRender(
        DynamicFieldConfig =&gt; $Param{DynamicFieldConfig},
        FieldName          =&gt; $FieldName,
        AdditionalText     =&gt; $AdditionalText,
    );

    my $Data = {
        Field =&gt; $HTMLString,
        Label =&gt; $LabelString,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            This function is used by ticket search dialog and its similar to "EditFieldRander", but
            normally on a search screen small changes has to be done for all fields, for this
            example we use a HTML text input instead of a password input. In other fields like
            Dropdown field is displayed as a Multiple select in order to let the user search for
            more than one value at a time.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldValueGet {
    my ( $Self, %Param ) = @_;

    my $Value;

    # get dynamic field value form param object
    if ( defined $Param{ParamObject} ) {
        $Value = $Param{ParamObject}
            -&gt;GetParam( Param =&gt; 'Search_DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name} );
    }

    # otherwise get the value from the profile
    elsif ( defined $Param{Profile} ) {
        $Value = $Param{Profile}-&gt;{ 'Search_DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name} };
    }
    else {
        return;
    }

    if ( defined $Param{ReturnProfileStructure} &amp;&amp; $Param{ReturnProfileStructure} eq 1 ) {
        return {
            'Search_DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name} =&gt; $Value,
        };
    }

    return $Value;

}
            </pre><p>
        </p><p>
            Very similar to <span class="emphasis"><em>EditFieldValueGet()</em></span>, but uses a different name
            prefix, adapted for the search dialog screen.
        </p><p>
            </p><pre class="programlisting">
sub SearchFieldParameterBuild {
    my ( $Self, %Param ) = @_;

    # get field value
    my $Value = $Self-&gt;SearchFieldValueGet(%Param);

    # set operator
    my $Operator = 'Equals';

    # search for a wild card in the value
    if ( $Value &amp;&amp; $Value =~ m{\*} ) {

        # change oprator
        $Operator = 'Like';
    }

    # return search parameter structure
    return {
        Parameter =&gt; {
            $Operator =&gt; $Value,
        },
        Display =&gt; $Value,
    };
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>SearchFieldParameterBuild()</em></span> is used also by the ticket search
            dialog to set the correct operator and value to do the search on this field. It also
            returns how the value should be displayed in the used search attributes, in the results
            page.
        </p><p>
            </p><pre class="programlisting">
sub StatsFieldParameterBuild {
    my ( $Self, %Param ) = @_;

    return {
        Name    =&gt; $Param{DynamicFieldConfig}-&gt;{Label},
        Element =&gt; 'DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name},
    };
}
            </pre><p>
        </p><p>
            This function is used by the stats modules, it includes the field definition in the
            stats format. For fields with fixed values it also includes all this possible values
            and if they can be translated, take a look to the Dropdown delegate code for an example
            how to implement those.
        </p><p>
            </p><pre class="programlisting">
sub CommonSearchFieldParameterBuild {
    my ( $Self, %Param ) = @_;

    my $Value = $Param{Value};

    # set operator
    my $Operator = 'Equals';

    # search for a wild card in the value
    if ( $Value &amp;&amp; $Value =~ m{\*} ) {

        # change oprator
        $Operator = 'Like';
    }

    return {
        $Operator =&gt; $Value,
    };
}
            </pre><p>
        </p><p>
            <span class="emphasis"><em>CommonSearchFieldParameterBuild()</em></span> is very similar to the
            <span class="emphasis"><em>SearchFieldParameterBuild()</em></span>, the difference id that the
            <span class="emphasis"><em>SearchFieldParameterBuild()</em></span> gets the value from the search profile
            and this one gets the value directly from its parameters.
        </p><p>
            This function is used by generic agent and stats modules.
        </p><p>
            </p><pre class="programlisting">
sub ReadableValueRender {
    my ( $Self, %Param ) = @_;

    my $Value;
    my $Title;

    # check if field is set to show password or not
    if (
        defined $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue}
        &amp;&amp; $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ShowValue} eq 'Yes'
        )
    {

        # get raw Title and Value strings from field value
        $Value = defined $Param{Value} ? $Param{Value} : '';
        $Title = $Value;
    }
    else{

        # show the mask and not the value
        $Value = $Param{DynamicFieldConfig}-&gt;{Config}-&gt;{ValueMask} || '';
        $Title = 'The value of this field is hidden.'
    }

    # cut strings if needed
    if ( $Param{ValueMaxChars} &amp;&amp; length($Value) &gt; $Param{ValueMaxChars} ) {
        $Value = substr( $Value, 0, $Param{ValueMaxChars} ) . '...';
    }
    if ( $Param{TitleMaxChars} &amp;&amp; length($Title) &gt; $Param{TitleMaxChars} ) {
        $Title = substr( $Title, 0, $Param{TitleMaxChars} ) . '...';
    }

    # create return structure
    my $Data = {
        Value =&gt; $Value,
        Title =&gt; $Title,
    };

    return $Data;
}
            </pre><p>
        </p><p>
            This function is similar to <span class="emphasis"><em>DisplayValueRender()</em></span> but is used  in
            places where there is no LayoutObject.
        </p><p>
            </p><pre class="programlisting">
sub TemplateValueTypeGet {
    my ( $Self, %Param ) = @_;

    my $FieldName = 'DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name};

    # set the field types
    my $EditValueType   = 'SCALAR';
    my $SearchValueType = 'SCALAR';

    # return the correct structure
    if ( $Param{FieldType} eq 'Edit' ) {
        return {
            $FieldName =&gt; $EditValueType,
            }
    }
    elsif ( $Param{FieldType} eq 'Search' ) {
        return {
            'Search_' . $FieldName =&gt; $SearchValueType,
            }
    }
    else {
        return {
            $FieldName             =&gt; $EditValueType,
            'Search_' . $FieldName =&gt; $SearchValueType,
            }
    }
}
            </pre><p>
        </p><p>
            The <span class="emphasis"><em>TemplateValueTypeGet()</em></span> function is used to know how the
            Dynamic Field values stored on a profile should be retrieved, as an SCALAR or as an
            ARRAY, and it also defines the correct name of the field in the profile.
        </p><p>
            </p><pre class="programlisting">
sub IsAJAXUpdateable {
    my ( $Self, %Param ) = @_;

    return 0;
}
            </pre><p>
        </p><p>
            This function is used to define if the values of a Dynamic Field should be refreshed in
            an AJAX update. Returns 1 Only for fields which its resulting HTML code form
            <span class="emphasis"><em>EditFieldRender</em></span> could be updated by the stock or custom
            core.AJAX.js module.
        </p><p>
            </p><pre class="programlisting">
sub RandomValueSet {
    my ( $Self, %Param ) = @_;

    my $Value = int( rand(500) );

    my $Success = $Self-&gt;ValueSet(
        %Param,
        Value =&gt; $Value,
    );

    if ( !$Success ) {
        return {
            Success =&gt; 0,
        };
    }
    return {
        Success =&gt; 1,
        Value   =&gt; $Value,
    };
}
            </pre><p>
        </p><p>
            This function is used by otrs.FillDB.pl script to populate the database with some test
            and random data. The value inserted by this function is not really relevant. The only
            restriction is that the value must be compatible with the field value type.
        </p><p>
            </p><pre class="programlisting">
sub IsMatchable {
    my ( $Self, %Param ) = @_;

    return 1;
}
            </pre><p>
        </p><p>
            Used to define if the <span class="emphasis"><em>ObjectMatch()</em></span> could be called for this field.
        </p><p>
            </p><pre class="programlisting">
sub ObjectMatch {
    my ( $Self, %Param ) = @_;

    my $FieldName = 'DynamicField_' . $Param{DynamicFieldConfig}-&gt;{Name};

    # return false if not match
    if ( $Param{ObjectAttributes}-&gt;{$FieldName} ne $Param{Value} ) {
        return 0;
    }

    return 1;
}
            </pre><p>
        </p><p>
            Used by the notification modules this function returns 1 if the field is present in the
            $Param{ObjectAttributes} parameter and if it match the given value.
        </p><p>
            </p><pre class="programlisting">
sub AJAXPossibleValuesGet {
    my ( $Self, %Param ) = @_;

    # not supported
    return;
}
            </pre><p>
        </p><p>
            If the field supports AJAX updates, this function returns all the possible values
            defined for the field, including the "" =&gt; "-" value (PossibleNone) if configured.
        </p><p>
            </p><pre class="programlisting">
1;

=back

=head1 TERMS AND CONDITIONS

This software is part of the OTRS project (L&lt;http://otrs.org/&gt;).

This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see L&lt;http://www.gnu.org/licenses/agpl.txt&gt;.

=cut

=head1 VERSION

$Revision: 1.1 $ $Date: 2012-03-27 05:46:40 $

=cut
            </pre><p>
        </p><p>
            The normal OTRS footer for a Perl module file.
        </p></div></div></div></div></div><div class="section" title="Old Module Descriptions"><div class="titlepage"><div><div><h3 class="title"><a name="old-module-description"></a>Old Module Descriptions</h3></div></div></div><p>Please remove these old sections if newer ones were created.</p><div class="section" title="Navigation Module"><div class="titlepage"><div><div><h4 class="title"><a name="module-navigation"></a>Navigation Module</h4></div></div></div><p>
In this module layer you can create dynamic navigation bar items with
dynamic content (Name and Description). Navigation Module are located under Kernel/Output/HTML/NavBar*.pm.
        </p><p>
Format:
        </p><pre class="programlisting">
# --
# Kernel/Output/HTML/NavBarABC.pm - shows a navbar item dynamicaly
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::NavBarABC;

use strict;
use warnings;

# --
sub new {
    my ( $Type, %Param ) = @_;
    [...]
    return $Self;
}
# --
sub Run {
    my ( $Self, %Param ) = @_;
    my %Return = ();
    $Return{'0999989'} = {
        Block       =&gt; 'ItemPersonal',
        Description =&gt; 'Some Desctipton',
        Name        =&gt; 'Text',
        Image       =&gt; 'new-message.png',
        Link        =&gt; 'Action=AgentMailbox&amp;amp;Subaction=New',
        AccessKey   =&gt; 'j',
    };
    return %Return;
}
# --
1;
        </pre><p>
        </p><p>
To use this module add the following code to the Kernel/Config.pm and restart
your webserver (if you use mod_perl).
        </p><pre class="programlisting">
[Kernel/Config.pm]
# agent interface notification module
$Self-&gt;{'Frontend::NavBarModule'}-&gt;{'99-ABC'} = {
    Module =&gt; 'Kernel::Output::HTML::NavBarABC',
};
        </pre><p>
        </p></div><div class="section" title="Customer Navigation Module"><div class="titlepage"><div><div><h4 class="title"><a name="module-customer-navigation"></a>Customer Navigation Module</h4></div></div></div><p>
In this module layer you can create dynamic navigation bar items with
dynamic content (Name and Description).
        </p><p>
The format is the same as in the Navigation Module.
        </p><p>
Just the config setting key is different. To use this module, add the following
to the Kernel/Config.pm and restart your webserver (if you use mod_perl).
        </p><p>
        </p><pre class="programlisting">
[Kernel/Config.pm]
# customer notifiacation module
$Self-&gt;{'CustomerFrontend::NavBarModule'}-&gt;{'99-ABC'} = {
    Module =&gt; 'Kernel::Output::HTML::NavBarABC',
};
        </pre><p>
        </p></div><div class="section" title="Ticket PostMaster Module"><div class="titlepage"><div><div><h4 class="title"><a name="ticket-postmaster-module"></a>Ticket PostMaster Module</h4></div></div></div><p>
PostMaster modules are used during the PostMaster process.
There are two kinds of PostMaster modules. PostMasterPre (used after parsing an email)
and PostMasterPost (used after an email is processed and in the database) modules.
            </p><p>
If you want to create your own postmaster filter, just create your own module.
These modules are located under "Kernel/System/PostMaster/Filter/*.pm".
For default modules see the admin manual. You just need two functions:
new() and Run():
            </p><p>
The following is an examplary module to match emails and set X-OTRS-Headers
(see doc/X-OTRS-Headers.txt for more info).
            </p><p>
Kernel/Config.pm:
            </p><p>
            </p><pre class="programlisting">
# Job Name: 1-Match
# (block/ignore all spam email with From: noreply@)
$Self-&gt;{'PostMaster::PreFilterModule'}-&gt;{'1-Example'} = {
    Module =&gt; 'Kernel::System::PostMaster::Filter::Example',
    Match =&gt; {
        From =&gt; 'noreply@',
    },
    Set =&gt; {
        'X-OTRS-Ignore' =&gt; 'yes',
    },
};
            </pre><p>
            </p><p>
Format:
            </p><p>
            </p><pre class="programlisting">
# --
# Kernel/System/PostMaster/Filter/Example.pm - a postmaster filter
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::PostMaster::Filter::Example;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.5 $) [1];

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless ($Self, $Type);

    $Self-&gt;{Debug} = $Param{Debug} || 0;

    # get needed objects
    for (qw(ConfigObject EncodeObject LogObject DBObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;
    # get config options
    my %Config = ();
    my %Match = ();
    my %Set = ();
    if ($Param{JobConfig} &amp;amp;&amp;amp; ref($Param{JobConfig}) eq 'HASH') {
        %Config = %{$Param{JobConfig}};
        if ($Config{Match}) {
            %Match = %{$Config{Match}};
        }
        if ($Config{Set}) {
            %Set = %{$Config{Set}};
        }
    }
    # match 'Match =&gt; ???' stuff
    my $Matched = '';
    my $MatchedNot = 0;
    for (sort keys %Match) {
        if ($Param{GetParam}-&gt;{$_} &amp;amp;&amp;amp; $Param{GetParam}-&gt;{$_} =~ /$Match{$_}/i) {
            $Matched = $1 || '1';
            if ($Self-&gt;{Debug} &gt; 1) {
                $Self-&gt;{LogObject}-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched!",
                );
            }
        }
        else {
            $MatchedNot = 1;
            if ($Self-&gt;{Debug} &gt; 1) {
                $Self-&gt;{LogObject}-&gt;Log(
                    Priority =&gt; 'debug',
                    Message =&gt; "'$Param{GetParam}-&gt;{$_}' =~ /$Match{$_}/i matched NOT!",
                );
            }
        }
    }
    # should I ignore the incoming mail?
    if ($Matched &amp;amp;&amp;amp; !$MatchedNot) {
        for (keys %Set) {
            if ($Set{$_} =~ /\[\*\*\*\]/i) {
                $Set{$_} = $Matched;
            }
            $Param{GetParam}-&gt;{$_} = $Set{$_};
            $Self-&gt;{LogObject}-&gt;Log(
                Priority =&gt; 'notice',
                Message =&gt; "Set param '$_' to '$Set{$_}' (Message-ID: $Param{GetParam}-&gt;{'Message-ID'}) ",
            );
        }
    }

    return 1;
}

1;
            </pre><p>
            </p><p>
The following image shows you the email processing flow.
            </p><div class="screenshot"><div><img src="screenshots/email-processing.png"></div></div><p>
            </p></div><div class="section" title="Ticket Menu Module"><div class="titlepage"><div><div><h4 class="title"><a name="ticket-module-menu"></a>Ticket Menu Module</h4></div></div></div><p>
To add links in the ticket menu, just use ticket menu modules.
            </p><p>
If you want to create your own ticket menu link, just create your own module.
These modules are located under "Kernel/Output/HTML/TicketMenu*.pm".
For default modules see the admin manual. You just need two functions:
new() and Run():
            </p><p>
The following example shows you how to show a lock or a unlock ticket link.
            </p><p>
Kernel/Config.pm:
            </p><p>
            </p><pre class="programlisting">
# for ticket zoom menu
$Self-&gt;{'Ticket::Frontend::MenuModule'}-&gt;{'100-Lock'} =  {
    Action =&gt; 'AgentTicketLock',
    Module =&gt; 'Kernel::Output::HTML::TicketMenuLock',
    Name   =&gt; 'Lock'
};

# for ticket preview menu
$Self-&gt;{'Ticket::Frontend::PreMenuModule'}-&gt;{'100-Lock'} =  {
    Action =&gt; 'AgentTicketLock',
    Module =&gt; 'Kernel::Output::HTML::TicketMenuLock',
    Name   =&gt; 'Lock'
};
            </pre><p>
            </p><p>
Format:
            </p><p>
            </p><pre class="programlisting">
# --
# Kernel/Output/HTML/TicketMenuLock.pm
# Copyright (C) 2001-2013 OTRS AG, http://otrs.com/
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::Output::HTML::TicketMenuLock;

use strict;
use warnings;

use vars qw(@ISA $VERSION);
$VERSION = qw($Revision: 1.5 $) [1];

# --
sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless ($Self, $Type);

    # get needed objects
    for (qw(ConfigObject LogObject DBObject LayoutObject UserID TicketObject)) {
        $Self-&gt;{$_} = $Param{$_} || die "Got no $_!";
    }

    return $Self;
}
# --
sub Run {
    my ( $Self, %Param ) = @_;
    # check needed stuff
    if (!$Param{Ticket}) {
        $Self-&gt;{LogObject}-&gt;Log(Priority =&gt; 'error', Message =&gt; 'Need Ticket!');
        return;
    }

    # check permission
    if ($Self-&gt;{TicketObject}-&gt;LockIsTicketLocked(TicketID =&gt; $Param{TicketID})) {
        my $AccessOk = $Self-&gt;{TicketObject}-&gt;OwnerCheck(
            TicketID =&gt; $Param{TicketID},
            OwnerID =&gt; $Self-&gt;{UserID},
        );
        if (!$AccessOk) {
            return $Param{Counter};
        }
    }

    $Self-&gt;{LayoutObject}-&gt;Block(
        Name =&gt; 'Menu',
        Data =&gt; { },
    );
    if ($Param{Counter}) {
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'MenuItemSplit',
            Data =&gt; {  },
        );
    }
    if ($Param{Ticket}-&gt;{Lock} eq 'lock') {
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'MenuItem',
            Data =&gt; {
                %{$Param{Config}},
                %{$Param{Ticket}},
                %Param,
                Name =&gt; 'Unlock',
                Description =&gt; 'Unlock to give it back to the queue!',
                Link =&gt; 'Action=AgentTicketLock&amp;amp;Subaction=Unlock&amp;amp;TicketID=$QData{"TicketID"}',
            },
        );
    }
    else {
        $Self-&gt;{LayoutObject}-&gt;Block(
            Name =&gt; 'MenuItem',
            Data =&gt; {
                %{$Param{Config}},
                %Param,
                Name =&gt; 'Lock',
                Description =&gt; 'Lock it to work on it!',
                Link =&gt; 'Action=AgentTicketLock&amp;amp;Subaction=Lock&amp;amp;TicketID=$QData{"TicketID"}',
            },
        );
    }
    $Param{Counter}++;
    return $Param{Counter};
}
# --
1;
            </pre><p>
            </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="how-to-extend-otrs.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="how-to-publish-extensions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. How to Extend OTRS </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 4. How to Publish Your OTRS Extensions</td></tr></table></div></body></html>
